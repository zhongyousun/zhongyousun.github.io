[
	{
	
		
	  "url": "http://sunnote.xyz/zh-tw/tutorials/aspnetcore-blazor-cache/",
	  "title": "ASP.NET Core API \u0026 Blazor 實作快取機制提升效能",
	  "summary": "\u003cp\u003e何謂快取? 一些基本介紹與紀錄使用 ASP.NET Core API 實作快取機制。\u003c/p\u003e",
	  "content": "何謂快取? 一些基本介紹與紀錄使用 ASP.NET Core API 實作快取機制。\n前言 最近的專案，因為有大量縮圖與計算，導致每次畫面呈現的速度，都達不到想要的水準，除了本身代碼與 T-SQL 的優化、還可以藉由懶加載 ( Lazy loading ) 等，達到提升資料讀取速度的效果。\n除了這些方式，還能藉由快取，達到更好的性能，此文章紀錄使用 Blazor WASM 架構與 ASP.NET Core API 建立快取機制。\n快取機制 說到快取(緩存)，可以理解為使用或是讀取預先存放好的資料，因為不用重新從資料庫或是伺服器取得檔案，速度可以有效提升，降低網站負荷。\n如果網站為靜態網站，或是有大量靜態資源的需求，若每次使用者進入網站，都需要讀取一次資源，那勢必會有流暢度的問題，這時若使用 CDN（Content Delivery Network）服務，藉由分布於全球的伺服器節點組成的網路，就能有效提升靜態資源的傳輸速度與性能，這其中就有用到快取的技術，藉由預先存放靜態資源在各地，達到高效傳輸。\n而若是在後端 API 的部分，也能使用類似的快取機制達到高效傳輸，預先存放資料的位置則是存放在記憶體中。本篇將介紹如何使用 MemoryCache 類進行緩存，若是大型網站或是分散式系統可使用 IDistributedCache 類等之後有機會再研究。\n使用時機 若要使用 MemoryCache 類進行緩存，因資料存放於記憶體，若應用程式關閉或重啟、系統故障，或是系統本身對於內存進行管理與優化，都會造成存放的資料消失。所以快取並不建議存放重要資料，或是頻繁變動的資料以致網站內容資訊不正確。\n以本篇為例，專案網站在首頁會顯示封面圖，而因為封面圖並不會頻繁更新，且資料也已儲存在資料庫與AWS S3，所以預先儲存在快取，就是一個不錯的方式以提升使用者載入首頁的速度。\n代碼 建立快取 架構不管是 Blazor WASM 還是 一般的 Web API 都是對控制器內的 API 進行修改。 代碼如下:\n1using Microsoft.Extensions.Caching.Memory; 2namespace BlazorApp.Server.Controllers 3{ 4 [Route(\u0026#34;api/[controller]\u0026#34;)] 5 [ApiController] 6 public class StorageController : ControllerBase 7 { 8 private readonly IStorageService _storageService; 9 private readonly IMemoryCache _cache; 10 11 public StorageController(IStorageService storageService, IMemoryCache memoryCache) 12 { 13 _storageService = storageService; 14 _cache = memoryCache; 15 } 16 17 [HttpGet(\u0026#34;logo/admin-no-cache\u0026#34;)] 18 public async Task\u0026lt;List\u0026lt;S3FileInfo\u0026gt;\u0026gt; GetLogoFileNoCache() 19 { 20 List\u0026lt;S3FileInfo\u0026gt; FileInfo = await _storageService.GetFileByKeyAsync(); 21 return FileInfo; 22 } 23 24 [HttpGet(\u0026#34;logo\u0026#34;)] 25 public async Task\u0026lt;List\u0026lt;S3FileInfo\u0026gt;\u0026gt; GetLogoFile() 26 { 27 string cacheKey = \u0026#34;logo\u0026#34;; 28 if (!_cache.TryGetValue\u0026lt;List\u0026lt;S3FileInfo\u0026gt;\u0026gt;(cacheKey, out List\u0026lt;S3FileInfo\u0026gt; cachedData)) 29 { 30 List\u0026lt;S3FileInfo\u0026gt; FileInfo = await _storageService.GetFileByKeyAsync(); 31 cachedData = FileInfo; 32 33 _cache.Set(cacheKey, cachedData, TimeSpan.FromHours(24)); 34 } 35 return cachedData; 36 } 37 } 38} 有兩支 API，一支為logo/admin-no-cache為管理員使用，針對管理員需當下確認資料正確性，為無快取版本。\n另一支為logo，供首頁載入時使用，邏輯為設定快取的Key為logo，每次呼叫時，需確認快取是否有包含Key為logo的資料， 若有則取用，若無則重新取得資料。\n_cache.Set(cacheKey, cachedData, TimeSpan.FromHours(24));\n在取得資料後，儲存資料至快取，並設定24小時候過期。也就是說每過了24小時，快取就會消失，之後的第一個讀取網站的人，載入速度就會回歸正常，因為必須重新讀取資料，而之後的每位使用者就還是一樣的高效快速。😎\n移除快取 有時也有清除快取的需求，例如資料更新後清除快取以讓使用者看到即時內容。\n移除特定快取代碼:\n_cache.Remove(\u0026#34;logo\u0026#34;); 取得快取列表 網站有快取之後，為了部分即時更新的資料還是得提供管理者清除快取功能，可以藉由取得目前記憶體儲存的快取 key 列表後，再配合上方移除快取進一步刪除。\n1[HttpGet(\u0026#34;cache\u0026#34;)] 2public async Task\u0026lt;List\u0026lt;string\u0026gt;\u0026gt; GetCacheList() 3{ 4 var field = typeof(MemoryCache).GetProperty(\u0026#34;EntriesCollection\u0026#34;, BindingFlags.NonPublic | BindingFlags.Instance); 5 var collection = field.GetValue(_cache) as ICollection; 6 var items = new List\u0026lt;string\u0026gt;(); 7 if (collection != null) 8 foreach (var item in collection) 9 { 10 var methodInfo = item.GetType().GetProperty(\u0026#34;Key\u0026#34;); 11 var val = methodInfo.GetValue(item); 12 items.Add(val.ToString()); 13 } 14 return items; 15} 結論 以上就是如何使用 ASP.NET Core 實作內存快取機制，個人是把需要快取的資料分為兩支 API，比較好分類，實際可依照需求增加判斷決定是否取得快取資料或是實際資料。網站若是使用雲端資料庫或是 S3 等服務，如果能好好善用快取，相信可以減少許多傳輸資料的花費呢。😎\n",
	  "pubDate": "2024-01-09T07:44:38+08:00",
	  "cover": "https://sunnote.xyz/img/thumbnail/051.webp"

	}, 
	{
	
		
	  "url": "http://sunnote.xyz/zh-tw/tutorials/aspnetcore-blazor-basic/",
	  "title": "ASP.NET Core Blazor 基本概念淺談與模型選擇",
	  "summary": "\u003cp\u003eBlazor 的一些基礎概念，討論 WebAssembly 與 Server 模型優劣。\u003c/p\u003e",
	  "content": "Blazor 的一些基礎概念，討論 WebAssembly 與 Server 模型優劣。\nBlazor Blazor 是由 Microsoft 所開發的一個用於建立現代 Web 應用程式的框架。最大優點就是開發人員可以直接使用 C# 建立動態、互動性豐富的網頁應用程式。Blazor 在客戶端以 WebAssembly (這項技術讓後端的程式碼能夠以類似 JavaScript 的方式在瀏覽器中運行)技術的方式執行 C# 程序，從而實現高性能的應用程式開發。\n光以上的介紹，應該就足夠以讓平常使用 C# 的後端開發人員有興趣學習了，而我實際學習下來，覺得若已經有一定的 C# 語言基礎，學習曲線可以說是非常平滑，非常建議若想試著學習全端或是對前端還不熟悉的開發人員，可以嘗試以 Blazor 這個框架當作基礎入們。\nBlazor WebAssembly vs. Blazor Server Blazor 提供兩種開發模型選擇，一開始學習時挺苦惱的，來解釋一下兩者有哪些差異。\nBlazor Server Blazor Server\r當進入網站時，前端會透過 SignalR ( C# 實現 WebSocket 雙向通訊功能的套件)與後端伺服器連線，資料主是由後端提供。\n幾個優點為:\n初始的載入速度較 WebAssembly 模式快。 比起 WebAssembly 的靜態網站，Server 模型保有 API 的功能。 缺點:\n因為使用 SignalR 傳遞資訊，若遇到網路不穩或是中途斷線(如果只是瞬間斷線，其瀏覽器會自動重連一次)，網站便無法使用。 使用者需連線才能持續操作網站，連線池數量根據硬體有其上限，也就是說遇到同時大量使用者連線時或許會有問題!? 官網也建議使用 Azure SignalR Service。 此服務允許將 Blazor Server 應用程式向上擴充為大量的並行 SignalR 連線。 看來若是拿來建置大型專案可能是個燒錢的選擇😅。\nBlazor WebAssembly Blazor Webassembly\r可以看到整個架構是直接在用戶端執行，當使用者連線時，即會載入獨立的 Blazor WebAssembly 應用程式，後續的操作都不需要與後端伺服器互動。\n優點為:\n為獨立的，可以想成是直接下載一個應用程式，後續的使用與伺服器無關，若是斷線仍可正常使用。 因為無關後端伺服器，基本上使用者進入網頁後，可以完全運用用戶端資源，而不是依賴伺服器資源。 屬於靜態網站，部署方便。 缺點:\n用戶端需支援 WebAssembly(會越來越普及)。 因為是整個代碼在用戶端被加載，網頁初次載入時需較長時間。 同上，因傳送至用戶端的程式碼無法受到保護，在實作時謹慎考慮代碼內容。 該如何選擇模型 比較兩種模型，其實各有優劣，而劣勢部分也是能使用其他方式解決，例如: Blazor Server 無法連線就無法使用的問題，可用更改代碼為若斷線時，隱藏會跳出的重新連線提示來解決，或是 Blazor WASM 初次載入較耗時也能使用載入特效解決。\n個人認為若專案為後台管理系統，使用人數可預測，需要操作資料庫，Blazor Server 就是一個好的選擇。若專案為小型網站屬於單純顯示資訊性質，就可以選擇 Blazor WASM。\nBlazor Hybrid 又或者若想取兩者之優點，可以選擇以 ASP.NET Core Hosted 的 Blazor WASM Hybrid 模式，簡而言之就是以 WASM 當作前端，後端則是以 .NET Core 提供任何 API 操作。解決了 Blazor Server 需要持續連線還有 WASM 若網站太大預先載入耗時與全部代碼需傳送至用戶端安全性上的問題。\nHybrid 模式可以使用不同的 .NET 原生應用程式架構來建置包括 .NET MAUI、WPF 和 Windows Forms等。而我則是選擇使用 .NET Core API 來建置。要建置這種 Blazor WASM Hosted 的方式很簡單，只要透過 Visual Studio 選擇建置 Blazor WebAssembly 專案，在框架選擇的畫面，勾選 ASP.NET Core Hosted 並創建就行了。 Create Blazor WASM Hybrid Project\r專案結構如下: Blazor WASM Hybrid Project Structure\rBlazorApp1.Client 為 WebAssembly 的部分，主要負責前端畫面顯示。\nBlazorApp1.Server 為後端 Web API 的部分，實作與 ASP.NET Web API 一致，由控制器控管 API。\nBlazorApp1.Shared 為物件存放位置，供 Client 與 Server 使用。\n結論 Blazor 是一個嶄新的框架，靈活性高，高效。非常適合原先使用 C#　語言的開發人員，知道後端工程師對於前端不熟悉的痛點，個人使用過後對於簡單的應用可以在短時間內就能建立一個前後端的應用程式，若想接觸前端或是全端的後端工程師，推薦可以藉由 Blazor 入門。\n參考\nASP.NET Core Blazor 裝載模型 ",
	  "pubDate": "2023-12-26T07:44:38+08:00",
	  "cover": "https://sunnote.xyz/img/thumbnail/050.webp"

	}, 
	{
	
		
	  "url": "http://sunnote.xyz/zh-tw/tutorials/aspnetcore-blazor-lazy-loading/",
	  "title": "ASP.NET Core Blazor 實作圖片延遲載入",
	  "summary": "\u003cp\u003e紀錄在 Blazor 框架，實作圖片延遲載入的方法。\u003c/p\u003e",
	  "content": "紀錄在 Blazor 框架，實作圖片延遲載入的方法。\n為何要使圖片延遲載入? 基本上最大的原因就是效能問題，若某個頁面有 10 張圖片，使用者其實並沒辦法在操作視窗內(螢幕)一次性的看到所有的圖片，所以在頁面載入時若馬上就載入這 10 張或是更多完整的圖片，不僅使用者需要等待全部載完會非常耗時，甚至更慘的是覺得網頁怎麼卡卡的跑不動而關閉。若圖片是放在 S3 等雲端服務上，那長久累積下來資料的傳輸量花費也是很可觀的!!\n實作方法 圖片延遲載入其實有很多種方式，最簡單的當然就是限制圖片的載入數量，每次只載個幾張，若要觀看更多可以往下滑動或是點選載入更多按鈕。但這種方式也只是治標不治本，畢竟每次的載入張數，若太少會讓使用者覺得很麻煩，太多又達不到想要增加效能減少傳輸量的效果。\n瀏覽器本身有支援延遲載入，只要透過此語法就能實現。\n\u0026lt;img src=\u0026#34;image.jpg\u0026#34; loading=\u0026#34;lazy\u0026#34;\u0026gt; 但在 Blazor 框架，可能是因為所有的物件畫面都有額外一層藉由 JS 去渲染，不確定實際原理，但測試下來是無效的。\n目前我選擇的方式是藉由 IntersectionObserver (由 JavaScript 實作的 API 可監測元素在窗口的狀態，也就是元素是否在視窗內)，進而判斷是否要載入圖片。\n代碼 將此代碼複製至 index.html 的 body 中，這樣網站的每個畫面都能使用延遲載入功能。\n1\u0026lt;!-- lzay loading --\u0026gt; 2\u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/intersection-observer@0.12.2/intersection-observer.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 3\u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; 4 window.lazyLoading = function () { 5 const observer = new IntersectionObserver((entries, owner) =\u0026gt; { 6 for (let entry of entries) { 7 if (entry.isIntersecting) { 8 // 圖片進入畫面再載入真實照片 9 const img = entry.target; 10 img.setAttribute(\u0026#39;src\u0026#39;, img.dataset.src); 11 img.removeAttribute(\u0026#39;data-src\u0026#39;); 12 owner.unobserve(img); 13 } 14 } 15 }); 16 const images = document.querySelectorAll(\u0026#39;img.lazy\u0026#39;) 17 for (let image of images) { 18 observer.observe(image); 19 } 20 } 21\u0026lt;/script\u0026gt; 主要就是藉由 IntersectionObserver 判斷圖片是否已進入視窗內，若進入則移除原本 src 顯示data-src 的內容。\n需要有延遲載入圖片的畫面(.rezor):\n@inject IJSRuntime js \u0026lt;img src=\u0026#34;@placeholderImage\u0026#34; data-src=\u0026#34;@o.ImageUrl\u0026#34; class=\u0026#34;lazy\u0026#34;\u0026gt; src為圖片未載入時的顯示畫面，可以是一個低解析度的像素圖。\ndata-src為實際要顯示的圖檔網址。\n@code的部分為:\nprotected override void OnAfterRender(bool firstRender) { if (firstRender) { js.InvokeVoidAsync(\u0026#34;lazyLoading\u0026#34;); } } 用來在第一次加載時載入 IntersectionObserver。\n結論 實際瀏覽效果如下: 可以看到當圖片進入視窗時，會由原本預設的低解析度的像素圖，載入實際圖片達到延遲載入的效果。\n",
	  "pubDate": "2023-12-25T07:44:38+08:00",
	  "cover": "https://sunnote.xyz/img/thumbnail/049.webp"

	}, 
	{
	
		
	  "url": "http://sunnote.xyz/zh-tw/tutorials/aspnetcore-blazor-wasm-prerender/",
	  "title": "Blazor WASM SEO - 使用預渲染解決 SPA 網頁爬蟲無法讀取問題 (Prerender.io \u0026 Cloudflare Workers 操作流程教學)",
	  "summary": "\u003cp\u003e紀錄如何藉由 Prerender.io 與 Cloudflare Workers 解決 SPA 網站在搜尋引擎爬取不到內容的問題。\u003c/p\u003e",
	  "content": "紀錄如何藉由 Prerender.io 與 Cloudflare Workers 解決 SPA 網站在搜尋引擎爬取不到內容的問題。\nBlazor WASM 前置作業(使用 Vue、React等前端框架可跳過) 基本上要讓搜尋引擎正確取得資料，就得在每個頁面的\u0026lt;head\u0026gt;新增 Open Graph。\n詳細資訊可參考 The Open Graph protocol，這裡直接提供 Blazor WASM 的實作方法。為了方便取用，可以把整個 Open Graph，做成一個物件。\n在 Client \u0026gt; Shared 新增一個 Razor component，代碼如下(可根據需求自行更改):\n1\u0026lt;PageTitle\u0026gt;@title\u0026lt;/PageTitle\u0026gt; 2\u0026lt;HeadContent\u0026gt; 3 \u0026lt;meta property=\u0026#34;og:title\u0026#34; content=\u0026#34;@title\u0026#34;\u0026gt; 4 \u0026lt;meta property=\u0026#34;og:type\u0026#34; content=\u0026#34;website\u0026#34;\u0026gt; 5 \u0026lt;meta property=\u0026#34;og:url\u0026#34; content=\u0026#34;@url\u0026#34;\u0026gt; 6 \u0026lt;meta property=\u0026#34;og:description\u0026#34; content=\u0026#34;@description\u0026#34;\u0026gt; 7 \u0026lt;meta property=\u0026#34;og:image\u0026#34; content=\u0026#34;@image\u0026#34;\u0026gt; 8 \u0026lt;meta property=\u0026#34;og:image:alt\u0026#34; content=\u0026#34;Shop\u0026#34;\u0026gt; 9 10 \u0026lt;meta name=\u0026#34;twitter:card\u0026#34; content=\u0026#34;summary_large_image\u0026#34;\u0026gt; 11 \u0026lt;meta name=\u0026#34;twitter:site\u0026#34; content=\u0026#34;@your twitter\u0026#34;\u0026gt; 12 \u0026lt;meta name=\u0026#34;author\u0026#34; content=\u0026#34;alvin\u0026#34;\u0026gt; 13 14 \u0026lt;meta name=\u0026#34;description\u0026#34; content=\u0026#34;@description\u0026#34;\u0026gt; 15 \u0026lt;meta name=\u0026#34;locale\u0026#34; content=\u0026#34;zh-tw\u0026#34;\u0026gt; 16 \u0026lt;meta name=\u0026#34;scope\u0026#34; content=\u0026#34;Accessories\u0026#34;\u0026gt; 17 18\u0026lt;/HeadContent\u0026gt; 19@code { 20 [Parameter] public string title { get; set; } = string.Empty; 21 [Parameter] public string url { get; set; } = string.Empty; 22 [Parameter] public string description { get; set; } = string.Empty; 23 [Parameter] public string image { get; set; } = string.Empty; 24} 建置完成後，只要在想要被搜尋到的頁面添加此物件就可以了(參數依據不同頁面而改變)。\n\u0026lt;C_SEO title=\u0026#34;@pageTitle\u0026#34; description=\u0026#34;@product.Description\u0026#34; image=\u0026#34;@product.ImageUrl\u0026#34; url=\u0026#34;@NavigationManager.Uri\u0026#34; /\u0026gt; 之後在頁面上檢視原始碼就能在\u0026lt;head\u0026gt;看到自定義的 Open Graph。原本以為這樣就解決了，但如果透過瀏覽器搜尋，或是藉由社群媒體分享連結，卻會發現爬蟲竟然讀取不到自定義的 Open Graph !?\n問題 利用 Vue、React 等前端框架建立的 SPA（Single Page Application，單頁應用程式）網站，與傳統靜態網站相比，它使用 JavaScript 動態渲染內容，這讓使用者在進入網站後，不需要每次重新加載整個頁面，而是只在頁面切換時更新所需的資料和畫面。這種機制不僅提升了效能，還允許使用者在頁面之間更加流暢地互動，因為頁面切換更快速、更平滑。單頁應用程式透過在客戶端動態更新內容，有效地優化了使用者體驗。\n但這種方法在瀏覽器搜尋時因爬蟲並不會等到動態渲染內容出現，而導致無法顯示該網站實際的內容。若是使用 Blazor WASM 建立網站，不管任何畫面在搜尋引擎上看到的都是 index.html 的內容。如下:\n1\u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;Loading...\u0026lt;/div\u0026gt; 2 3\u0026lt;div id=\u0026#34;blazor-error-ui\u0026#34;\u0026gt; 4 An unhandled error has occurred. 5 \u0026lt;a href=\u0026#34;\u0026#34; class=\u0026#34;reload\u0026#34;\u0026gt;Reload\u0026lt;/a\u0026gt; 6 \u0026lt;a class=\u0026#34;dismiss\u0026#34;\u0026gt;🗙\u0026lt;/a\u0026gt; 7\u0026lt;/div\u0026gt; 解決方法 若要解決此問題，讓爬蟲可以讀取到正確的資訊，就得使用預渲染技術，主要就是藉由預先儲存每個畫面的資訊，當爬蟲機器人在爬取該網站時，直接顯示即可。\n而預渲染可以使用 Prerender.io 所提供的服務，預先快取網站的實際內容，再藉由 Middleware 去判斷讀取網站的是一般使用者還是爬蟲機器人。Middleware 則是使用 Cloudflare Workers。\n流程圖:\nPrerender Solution Architecture\rCloudflare Workers Cloudflare Workers 是由 Cloudflare 提供的服務，允許開發人員在 Cloudflare 的全球分佈式邊緣網路上執行和部署 JavaScript 或 WebAssembly 代碼。\n而我們就可以藉由 Cloudflare Workers 實作一個 Middleware 判斷發出的 request 是爬蟲機器人還是一般使用者。\n若要使用 Cloudflare Workers，得先讓網站域名讓 Cloudflare 託管，目前專案原先是使用 Godaddy 購買網領域名，需先前往 Cloudflare 新增網站，方案可以選擇免費的，若本身網站已在 Godaddy 有 DNS 紀錄即會自動入，新增成功後就能取得自訂的名稱伺服器 URL，再前往 Godaddy DNS 的名稱伺服器修改即可。\n佈署 Prerender worker 在 Cloudflare 從首頁點選左側功能列(Workers \u0026amp; Pages)。\n建立 Worker 並發佈，第一次建立官網應該會提供 Hello world 的範例，可以不管它先直接建立，之後可以再修改裡面的內容。\n接下來就可以直接複製貼上 Prerender.io 提供 Cloudflare 當 Middleware 的代碼，按下儲存和佈屬就完成了。 (Prerender.io 在連接的方式選擇 Cloudflare 可查看此代碼)\n1// User agents handled by Prerender 2const BOT_AGENTS = [ 3 \u0026#34;googlebot\u0026#34;, 4 \u0026#34;yahoo! slurp\u0026#34;, 5 \u0026#34;bingbot\u0026#34;, 6 \u0026#34;yandex\u0026#34;, 7 \u0026#34;baiduspider\u0026#34;, 8 \u0026#34;facebookexternalhit\u0026#34;, 9 \u0026#34;twitterbot\u0026#34;, 10 \u0026#34;rogerbot\u0026#34;, 11 \u0026#34;linkedinbot\u0026#34;, 12 \u0026#34;embedly\u0026#34;, 13 \u0026#34;quora link preview\u0026#34;, 14 \u0026#34;showyoubot\u0026#34;, 15 \u0026#34;outbrain\u0026#34;, 16 \u0026#34;pinterest/0.\u0026#34;, 17 \u0026#34;developers.google.com/+/web/snippet\u0026#34;, 18 \u0026#34;slackbot\u0026#34;, 19 \u0026#34;vkshare\u0026#34;, 20 \u0026#34;w3c_validator\u0026#34;, 21 \u0026#34;redditbot\u0026#34;, 22 \u0026#34;applebot\u0026#34;, 23 \u0026#34;whatsapp\u0026#34;, 24 \u0026#34;flipboard\u0026#34;, 25 \u0026#34;tumblr\u0026#34;, 26 \u0026#34;bitlybot\u0026#34;, 27 \u0026#34;skypeuripreview\u0026#34;, 28 \u0026#34;nuzzel\u0026#34;, 29 \u0026#34;discordbot\u0026#34;, 30 \u0026#34;google page speed\u0026#34;, 31 \u0026#34;qwantify\u0026#34;, 32 \u0026#34;pinterestbot\u0026#34;, 33 \u0026#34;bitrix link preview\u0026#34;, 34 \u0026#34;xing-contenttabreceiver\u0026#34;, 35 \u0026#34;chrome-lighthouse\u0026#34;, 36 \u0026#34;telegrambot\u0026#34;, 37 \u0026#34;integration-test\u0026#34;, // Integration testing 38 \u0026#34;google-inspectiontool\u0026#34; 39]; 40 41// These are the extensions that the worker will skip prerendering 42// even if any other conditions pass. 43const IGNORE_EXTENSIONS = [ 44 \u0026#34;.js\u0026#34;, 45 \u0026#34;.css\u0026#34;, 46 \u0026#34;.xml\u0026#34;, 47 \u0026#34;.less\u0026#34;, 48 \u0026#34;.png\u0026#34;, 49 \u0026#34;.jpg\u0026#34;, 50 \u0026#34;.jpeg\u0026#34;, 51 \u0026#34;.gif\u0026#34;, 52 \u0026#34;.pdf\u0026#34;, 53 \u0026#34;.doc\u0026#34;, 54 \u0026#34;.txt\u0026#34;, 55 \u0026#34;.ico\u0026#34;, 56 \u0026#34;.rss\u0026#34;, 57 \u0026#34;.zip\u0026#34;, 58 \u0026#34;.mp3\u0026#34;, 59 \u0026#34;.rar\u0026#34;, 60 \u0026#34;.exe\u0026#34;, 61 \u0026#34;.wmv\u0026#34;, 62 \u0026#34;.doc\u0026#34;, 63 \u0026#34;.avi\u0026#34;, 64 \u0026#34;.ppt\u0026#34;, 65 \u0026#34;.mpg\u0026#34;, 66 \u0026#34;.mpeg\u0026#34;, 67 \u0026#34;.tif\u0026#34;, 68 \u0026#34;.wav\u0026#34;, 69 \u0026#34;.mov\u0026#34;, 70 \u0026#34;.psd\u0026#34;, 71 \u0026#34;.ai\u0026#34;, 72 \u0026#34;.xls\u0026#34;, 73 \u0026#34;.mp4\u0026#34;, 74 \u0026#34;.m4a\u0026#34;, 75 \u0026#34;.swf\u0026#34;, 76 \u0026#34;.dat\u0026#34;, 77 \u0026#34;.dmg\u0026#34;, 78 \u0026#34;.iso\u0026#34;, 79 \u0026#34;.flv\u0026#34;, 80 \u0026#34;.m4v\u0026#34;, 81 \u0026#34;.torrent\u0026#34;, 82 \u0026#34;.woff\u0026#34;, 83 \u0026#34;.ttf\u0026#34;, 84 \u0026#34;.svg\u0026#34;, 85 \u0026#34;.webmanifest\u0026#34;, 86]; 87 88export default { 89 /** 90 * Hooks into the request, and changes origin if needed 91 */ 92 async fetch(request, env) { 93 return await handleRequest(request, env).catch( 94 (err) =\u0026gt; new Response(err.stack, { status: 500 }) 95 ); 96 }, 97}; 98 99/** 100 * @param {Request} request 101 * @param {any} env 102 * @returns {Promise\u0026lt;Response\u0026gt;} 103 */ 104async function handleRequest(request, env) { 105 const url = new URL(request.url); 106 const userAgent = request.headers.get(\u0026#34;User-Agent\u0026#34;)?.toLowerCase() || \u0026#34;\u0026#34;; 107 const isPrerender = request.headers.get(\u0026#34;X-Prerender\u0026#34;); 108 const pathName = url.pathname.toLowerCase(); 109 const extension = pathName 110 .substring(pathName.lastIndexOf(\u0026#34;.\u0026#34;) || pathName.length) 111 ?.toLowerCase(); 112 113 // Prerender loop protection 114 // Non robot user agent 115 // Ignore extensions 116 if ( 117 isPrerender || 118 !BOT_AGENTS.some((bot) =\u0026gt; userAgent.includes(bot)) || 119 (extension.length \u0026amp;\u0026amp; IGNORE_EXTENSIONS.includes(extension)) 120 ) { 121 return fetch(request); 122 } 123 124 // Build Prerender request 125 const newURL = `https://service.prerender.io/${request.url}`; 126 const newHeaders = new Headers(request.headers); 127 128 newHeaders.set(\u0026#34;X-Prerender-Token\u0026#34;, env.PRERENDER_TOKEN); 129 130 return fetch(new Request(newURL, { 131 headers: newHeaders, 132 redirect: \u0026#34;manual\u0026#34;, 133 })); 134} 代碼主要為處理 HTTP 請求的服務。藉由使用者代理（User-Agent）和檔案擴展名（extensions）來判斷是否應該使用 Prerender 服務。\n接下來返回此 worker 的預覽畫面，點選 Triggers 後，下方點選 Add route，並填上網站的路由像是 *your-domain.com/* 與 Zone 是屬於哪個網站，最後點選 Add route 儲存。 Triggers\r下一步就是要添加 Prerender Token 至環境變數。點選 Settings\u0026gt; Variables \u0026gt; Add Variable。並複製貼上由 Prerender.io 提供的 Token。 Prerender Token\rAdd a Variable\r!!變數名稱必須為 PRERENDER_TOKEN。\n按下儲存後，這個 Prerender worker 就能順利運行了。\n以上步驟完成後，就能至 Prerender.io 上傳 Sitemap，供爬蟲爬取再儲存快取。\n結論 目前 Prerender.io 免付費額度為每月可執行1000次預渲染，對於小型或是變更不頻繁的網站已經足夠了，而使用此種方式解決 SPA 網頁 SEO 遇到的問題，也算是比較容易上手的，畢竟不用修改原本的專案代碼，不過經歷這次經驗，下次開發專案就得依據是否有需求做 SEO 而考慮選擇的框架與方法，畢竟專案一多，若之後改成要收費那就會衍生出其他問題了😶。\n參考\nBlazor WebAssembly Client Side SEO Pre-rendering，\nDeploy your Prerender worker on Cloudflare，\nCloudflare Workers，\nPrerender.io如何幫助CSR的SEO - 原理介紹與使用教學，\nBlazor WASM SEO - You have a broken website according to Google!，\n",
	  "pubDate": "2023-12-20T07:44:38+08:00",
	  "cover": "https://sunnote.xyz/img/thumbnail/048.webp"

	}, 
	{
	
		
	  "url": "http://sunnote.xyz/zh-tw/tutorials/aspnetcore-sitemap/",
	  "title": "使用 ASP.NET Core API \u0026 Blazor 產生 Sitemap",
	  "summary": "\u003cp\u003e紀錄使用 Blazor WebAssembly Hybrid 產生網站地圖的過程。\u003c/p\u003e",
	  "content": "紀錄使用 Blazor WebAssembly Hybrid 產生網站地圖的過程。\n何謂網站地圖\n網站地圖（Sitemap）就像一份網站的清單或目錄一樣。這份清單列出了網站上所有可供訪問的頁面、文章、圖片等內容，讓搜索引擎和網站爬蟲（例如 Googlebot、Bingbot 等）更輕鬆地了解和探索網站的構成方式。它幫助搜索引擎更快速、更準確地找到並記錄網站上的內容，這樣用戶在進行搜索時就能更容易地找到他們需要的內容。\n總之，網站地圖就是為了讓搜索引擎更好地理解和記錄網站內容結構的一種方式，從而讓用戶更輕鬆地找到他們想要的資訊。\n前言 目前有使用 Hugo (使用Go語言編寫的靜態網頁生成器) 建立網站的經驗，基本上編譯完後此框架就能自動生成 Sitemap.xml 供使用，而網路爬蟲也因為每個網頁屬於靜態網站可以輕易取得網站的資料。\n但對於使用 Blazor WebAssembly Hybrid 或是使用 Vue、React 等前端框架建立的網站，因為屬於 SPA(Single Page Application)，在網站曝光、SEO\u0026hellip;等，總是遇到很多問題。\n此文章主要紀錄屬於 SPA 類型的網站，為了做預渲染時，方便相關服務如 Prerender.io，爬蟲所需的網站地圖的建立方式。\n關於 SPA 類型的網站，如何使用預渲染，解決 google 爬蟲爬不到網站資料的問題，可以參考這篇:\nBlazor WASM SEO - 使用預渲染解決 SPA 網頁爬蟲無法讀取問題 (Prerender.io \u0026amp; Cloudflare Workers)\n方法 基本上沒有什麼快速的方法，只能依照本身網站結構，產出網站地圖。對於使用 Blazor WebAssembly Hybrid，本來在思考是否能由 Server 端自動產生，這樣若網站資料有變動，也能即時修改 Sitemap，但即時意味著有做到資料更改的 API 都要連動，想想覺得複雜化了，改為使用獨立的 API，依據需求再產出 Sitemap 即可。\n至於 Hybrid 類型的框架，檔案生成後位於根目錄也就是 Server 端，目前就是在部署網站時多一道步驟把 Server 端的 sitemap.xml 移至 Client 端。這樣在上線時就能透過 https://your domain/sitemap.xml 取得檔案。\nCode 先參考一下 Google 提供的範例\n1\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; 2\u0026lt;urlset xmlns=\u0026#34;http://www.sitemaps.org/schemas/sitemap/0.9\u0026#34;\u0026gt; 3 \u0026lt;url\u0026gt; 4 \u0026lt;loc\u0026gt;https://www.example.com/foo.html\u0026lt;/loc\u0026gt; 5 \u0026lt;lastmod\u0026gt;2022-06-04\u0026lt;/lastmod\u0026gt; 6 \u0026lt;/url\u0026gt; 7\u0026lt;/urlset\u0026gt; 包含\u0026lt;loc\u0026gt;網址、\u0026lt;lastmod\u0026gt;最後修改時間，還可以增加\u0026lt;priority\u0026gt;網頁權重和 \u0026lt;changefreq\u0026gt;更新頻率。所以就是要藉由 API，去組出相同格式的檔案。以下為範例:\n建立sitemap需要的基本參數。 1public class Page 2{ 3 public string Url { get; set; } 4 public DateTime LastModified { get; set; } 5 public string ChangeFrequency { get; set; } 6 public double Priority { get; set; } 7} API 1[HttpGet] 2public async Task\u0026lt;bool\u0026gt; GetSiteMap() 3{ 4 XNamespace xmlns = \u0026#34;http://www.sitemaps.org/schemas/sitemap/0.9\u0026#34;; // Define namespace 5 6 // Create XML document 7 XDocument sitemap = new XDocument( 8 new XDeclaration(\u0026#34;1.0\u0026#34;, \u0026#34;utf-8\u0026#34;, \u0026#34;yes\u0026#34;), 9 new XElement(xmlns + \u0026#34;urlset\u0026#34; // Using XNamespace 10 ) 11 ); 12 13 string baseUrl = \u0026#34;https://your domain/\u0026#34;; 14 15 // Create List\u0026lt;Page\u0026gt; object 16 var pages = new List\u0026lt;Page\u0026gt; 17 { 18 new Page { Url = baseUrl, LastModified = DateTime.Now, ChangeFrequency = \u0026#34;daily\u0026#34;, Priority = 1.0 } 19 }; 20 //Add pages according to your website structure 21 ServiceResponse\u0026lt;List\u0026lt;Category\u0026gt;\u0026gt; result = await _categoryService.GetCategories(); 22 List\u0026lt;Product\u0026gt; products = await _productService.GetAvailableProducts(); 23 foreach (Category category in result.Data) 24 { 25 category.Product = products.Where(o =\u0026gt; o.CategoryId == category.Id \u0026amp;\u0026amp; o.IsImage == true).OrderBy(o =\u0026gt; o.Order).ToList(); 26 pages.Add(new Page { Url = baseUrl + \u0026#34;category/\u0026#34; + category.Url, LastModified = DateTime.Now, ChangeFrequency = \u0026#34;daily\u0026#34;, Priority = 1.0 }); 27 28 foreach (Product product in products) 29 { 30 pages.Add(new Page { Url = baseUrl + \u0026#34;product/\u0026#34; + product.Url, LastModified = DateTime.Now, ChangeFrequency = \u0026#34;daily\u0026#34;, Priority = 1.0 }); 31 } 32 } 33 34 // Add each page to the Sitemap 35 foreach (var page in pages) 36 { 37 XElement urlElement = new XElement(xmlns + \u0026#34;url\u0026#34;, 38 new XElement(xmlns + \u0026#34;loc\u0026#34;, page.Url), 39 new XElement(xmlns + \u0026#34;lastmod\u0026#34;, page.LastModified.ToString(\u0026#34;yyyy-MM-dd\u0026#34;)), 40 new XElement(xmlns + \u0026#34;changefreq\u0026#34;, page.ChangeFrequency), 41 new XElement(xmlns + \u0026#34;priority\u0026#34;, page.Priority.ToString(\u0026#34;0.0\u0026#34;, System.Globalization.CultureInfo.InvariantCulture)) 42 ); 43 sitemap.Root.Add(urlElement); 44 } 45 46 // Save XML 47 string filePath = \u0026#34;sitemap.xml\u0026#34;; 48 sitemap.Save(filePath); 49 return true; 50} 結論 以上為建立 Sitemap.xml 的方法，任何網站若要提升 SEO，或是藉由 GA4 分析流量來源，都需要 Sitemap 的提供。下一篇會講解 SPA 類型的網站，如何解決網路爬蟲爬取不到網站資料的問題。\n參考\n建立並提交 Sitemap， ",
	  "pubDate": "2023-12-18T07:44:38+08:00",
	  "cover": "https://sunnote.xyz/img/thumbnail/047.webp"

	}, 
	{
	
		
	  "url": "http://sunnote.xyz/zh-tw/tutorials/api-with-synology-nas/",
	  "title": "使用 API 串接 Synology NAS 服務",
	  "summary": "\u003cp\u003e紀錄使用 API 串接 Synology NAS 服務遇到的坑。\u003c/p\u003e",
	  "content": "紀錄使用 API 串接 Synology NAS 服務遇到的坑。\n前言 最近公司的系統為了因應大量的資料儲存，選擇改為把資料存放在NAS，所以就來研究一下如何透過API串接此服務。\n基本上如何使用都可以參考官方文檔 Synology_File_Station_API_Guide，此篇主要紀錄幾個使用過的 API 與遇到的問題。\n登入 要使用此服務的各項 API 基本上都得先登入取得權限。而各個參數都是以查詢字串的方式夾帶。\nAPI Request:\nGet\rhttp://myds.com:port/webapi/auth.cgi?api=SYNO.API.Auth\u0026amp;version=3\u0026amp;method=login\u0026amp;account=admin\u0026amp;passwd=12345\u0026amp;session=FileStation\u0026amp;format=cookie 網址：http://{nasurl}:5000/webapi/auth.cgi\nhttp的port為5000，https為5001\n查詢字串為:\napi=SYNO.API.Auth\nversion=3\nmethod=login\naccount=your account\npasswd=your passwd\nsession=FileStation\nformat=cookie\nResponse:\n{\r\u0026#34;data\u0026#34;: {\r\u0026#34;did\u0026#34;: \u0026#34;WeoBfHknZ4EllXoN4Jjds8ukcgyWyVJfQvoz60xTTpzMSpEaD8GU_yvrvjxK10h1Z4eMUhaxtyH5OphCCGl5Hw\u0026#34;,\r\u0026#34;sid\u0026#34;: \u0026#34;2ZLVB8UbL6EHnkI4uCO730lqNgJyzjBfhDcodeqNETcG_pMHr5yjt-gTYI0OtpzbmXAxlmZMXi3PyHkEyZHI0E\u0026#34;\r},\r\u0026#34;success\u0026#34;: true\r} did 為 nas 服務的 ID，sid 為登入後取得的權限證明，之後呼叫任何 API 可以選擇以 cookie 或是查詢字串的方式攜帶。\n此篇都使以查詢字串的方式攜帶 sid，參數為 _sid=sid。\n登出 API Request:\nGet\rhttp://myds.com:5000/webapi/auth.cgi?api=SYNO.API.Auth\u0026amp;version=1\u0026amp;method=logout\u0026amp;session=FileStation 查詢字串為:\napi=SYNO.API.Auth\nversion=1\nmethod=logout\nsession=FileStation\n_sid=sid\nResponse:\n{\r\u0026#34;success\u0026#34;: true\r} 經測試 sid 的權限，時效蠻久的，所以並不需要頻繁的登入與登出，目前是採用每次與NAS操作時，先判斷 sid 是否還可以使用，若不行再執行登入的動作取得新的 sid。\n新建資料夾 API Request:\nGet\rhttp://myds.com:5000/webapi/entry.cgi?api=SYNO.FileStation.CreateFolder\u0026amp;version=2\u0026amp;method=create\u0026amp;folder_path=%5B%22%2Fvideo%22%5D\u0026amp;name=%5B%22test%22%5D 查詢字串為:\napi=SYNO.FileStation.CreateFolder\nversion=2\nmethod=create\nfolder_path=/path\nname=folderName\n_sid=sid\nResponse:\n{\r\u0026#34;data\u0026#34;: {\r\u0026#34;folders\u0026#34;: [\r{\r\u0026#34;isdir\u0026#34;: true,\r\u0026#34;name\u0026#34;: \u0026#34;XDS\u0026#34;,\r\u0026#34;path\u0026#34;: \u0026#34;/SPM/XDS\u0026#34;\r}\r]\r},\r\u0026#34;success\u0026#34;: true\r} 刪除 API Request:\nGet\rhttp://myds.com:5000/webapi/entry.cgi?api=SYNO.FileStation.Delete\u0026amp;version=2\u0026amp;method=start\u0026amp;path=%22%2Fvideo%2Fdel_folder%22 查詢字串為:\napi=SYNO.FileStation.Delete\nversion=2\nmethod=start\npath=/filePath\nname=folderName\n_sid=sid\nResponse:\n{\r\u0026#34;data\u0026#34;: {\r\u0026#34;taskid\u0026#34;: \u0026#34;FileStation_657A5A3DF1C925ED\u0026#34;\r},\r\u0026#34;success\u0026#34;: true\r} 執行刪除會回傳一個 taskid，這代表是一個執行刪除的動作。若要查詢是否刪除成功則需呼叫另一個 API。\nAPI Request:\nGet\rhttp://myds.com:5000/webapi/entry.cgi?api=SYNO.FileStation.Delete\u0026amp;version=2\u0026amp;method=status\u0026amp;taskid=%22FileStation_51CEC9C979340E5A%22 查詢字串為:\napi=SYNO.FileStation.Delete\nversion=2\nmethod=status\ntaskid=FileStation_657A5A483B021703\n_sid=sid\nResponse:\n{\r\u0026#34;data\u0026#34;: {\r\u0026#34;finished\u0026#34;: true,\r\u0026#34;path\u0026#34;: \u0026#34;\u0026#34;,\r\u0026#34;processed_num\u0026#34;: 0,\r\u0026#34;processing_path\u0026#34;: \u0026#34;\u0026#34;,\r\u0026#34;progress\u0026#34;: 1,\r\u0026#34;total\u0026#34;: -1\r},\r\u0026#34;success\u0026#34;: true\r} 即可確認此檔案或資料夾是否刪除成功。\n檔案上傳 API Request:\nPost\rhttp://myds.com:5000/webapi/entry.cgi?api=SYNO.FileStation.Upload\u0026amp;version=2\u0026amp;method=upload\u0026amp;path=/SPM/XD\u0026amp;create_parents=true\u0026amp;_sid=AgQzS8bUN7bJcfwfwHj4n2ZT_pjmC5PQAiKV_Xt27AgTO8B9uySZqhK9uQg8UosfMvBLUKrtYqrZtQKp1fJVqU 查詢字串為:\napi=SYNO.FileStation.Upload\nversion=2\nmethod=upload\npath=/folderPath\ncreate_parents=true\n_sid=sid\nBody 的部分需使用 form-data 的格式:\nPostman form-data\rResponse:\n{\r\u0026#34;data\u0026#34;: {\r\u0026#34;blSkip\u0026#34;: false,\r\u0026#34;file\u0026#34;: \u0026#34;unnamed.png\u0026#34;,\r\u0026#34;pid\u0026#34;: 30385,\r\u0026#34;progress\u0026#34;: 1\r},\r\u0026#34;success\u0026#34;: true\r} 檔案上傳的部分官方文檔寫的有看沒有懂，不太清楚參數到底是得放在查詢字串裡還是 orm-data 裡，結果兩邊都放檔案才上傳成功\u0026hellip;。\n檔案下載 API Request:\nGet\rhttp://myds.com:5000/webapi/entry.cgi?api=SYNO.FileStation.Download\u0026amp;version=2\u0026amp;method=download\u0026amp;path=%5B%22%2Ftest%2FITEMA_20445972-0.mp3%22%5D\u0026amp;mode=%22open%22 查詢字串為:\napi=SYNO.FileStation.Download\nversion=2\nmethod=download\npath=/filePath\nmode=open or download\n使用open為開啟檔案或資料夾，HTTP標頭的 Content-Type 可設置為根據檔案對應的 MIME 類型。\n使用download 為下載檔案或資料夾，HTTP標頭的 Content-Type 設置為 application/octet-stream，而 Content-Disposition 設置為 attachment，這樣可以告訴瀏覽器將其視為附件並提示下載。\n_sid=sid\n結論 需要注意的為檔案上傳的部分，參數使用查詢字串攜帶的同時，也需使用 form-data 傳遞才能成功，這個地方嘗試了許久\u0026hellip;。這次算是第一次串接 NAS 服務，平常都是提供 API 給人串接，經歷過這次體會到 API 文件書一定要寫好，不然遇到問題一直靠通靈真的是頗麻煩。\n",
	  "pubDate": "2023-12-14T07:44:38+08:00",
	  "cover": "https://sunnote.xyz/img/thumbnail/046.webp"

	}, 
	{
	
		
	  "url": "http://sunnote.xyz/zh-tw/tutorials/url-querystring-encoding-decoding/",
	  "title": "URL 查詢字串與編、解碼淺談",
	  "summary": "\u003cp\u003eURL查詢字串傳遞參數時，使用編碼與解碼與該注意的細節。\u003c/p\u003e",
	  "content": "URL查詢字串傳遞參數時，使用編碼與解碼與該注意的細節。\n問題 工作許久最近才被這個問題搞到，原本已經剛上線的服務提供檔案上傳與下載，不知為何部分檔案無法順利下載。系統邏輯為客戶上傳檔案時，會生成UUID，並把客戶資訊一起寫進DB，同時儲存檔案。下載時則時藉由當下使用者的資訊與檔案UUID，即時產生包含限制時間資訊的JWT，用來派發一次性下載網址。\n而JWT則是由前端藉由Query string的方式夾帶在檔案下載的API中呼叫取得檔案，在使用者介面很常發生下載錯誤的問題，但使用Swagger直接呼叫API又能下載成功。\n原因 查了許久才發現是URL傳遞參數包含特殊符號的問題。 一般URL若有使用特殊符號，是有不同的含意的。\n舉幾個例子:\n?： 一般出現在 URL 的開頭或在路徑與查詢字串之間，用於分隔 URL 的主要部分和查詢參數。在 URL 中，? 之後的部分通常是查詢字串（query string），用於向伺服器傳遞參數和數據。 例如：https://www.example.com/search?query=example\n上面的 URL 中 ? 後的 query=example 就是查詢字串，用來傳遞搜尋的參數。\n\u0026amp;： 在 URL 的查詢字串中，用於分隔不同的查詢參數。它允許在同一個 URL 中傳遞多個參數。 例如：https://www.example.com/search?query=example\u0026amp;page=2\n在這個例子中，\u0026amp; 用來將 query=example 和 page=2 這兩個查詢參數分開。\n=： 在 URL 的查詢字串中，用於將參數名稱和參數值分隔開來。它將參數名和參數值相連接。 例如：https://www.example.com/search?query=example\n在這裡，= 將 query（參數名）和 example（參數值）分隔開來。1.\n若查詢字串夾帶的參數有包含這類的特殊符號，基本上瀏覽器在解析上就會有問題。\n還有其他一些有的沒的像是 + 與空格等在使用URL傳遞時都要很小心。\n編碼與解碼 所以若還是硬要透過查詢字串傳遞這類特殊字符的資訊時，就可以透過URL 編碼與解碼解決。\n以我目前遇到的例子，需使用查詢字串夾帶JWT，JWT裡面必定包含很多特殊字符，這時就可以在後端產生JWT後執行編碼，再回傳前端就能使用正確的API下載檔案了。\n範例 :\n若夾帶參數為: =hello+world.\n沒編碼前使用Query String 夾帶參數瀏覽器就會誤判。\n經編碼後為 : %3Dhello%2Bworld.\n再回傳給前端，在呼叫時就不會有問題了。\n至於後端在接收此參數時，大多數後端框架或語言的 HTTP 請求處理器會自動對 URL 參數進行解碼，但在使用時還是可以先確認一下，避免之後出錯又得花時間除錯\u0026hellip;。\n結論 很基本簡單的觀念，所以一直以來都沒去搞清楚，害我花了半小時除錯，所以紀錄一下。😎\n",
	  "pubDate": "2023-12-07T07:44:38+08:00",
	  "cover": "https://sunnote.xyz/img/thumbnail/045.webp"

	}, 
	{
	
		
	  "url": "http://sunnote.xyz/zh-tw/tutorials/aspnetcore-6.0-aws-s3/",
	  "title": "ASP.NET Core Web API \u0026 Blazor 實作Amazon S3 檔案串接",
	  "summary": "\u003cp\u003e使用 ASP.NET Core 串接Amazon S3 流程記錄。\u003c/p\u003e",
	  "content": "使用 ASP.NET Core 串接Amazon S3 流程記錄。\n前言 此篇的專案架構為使用 Blazor WebAssembly Hybrid的方式，結合 Blazor WebAssembly 前端與後端Server API，所以除了紀錄使用Web API 串接S3 外，也順便紀錄 Blazor WebAssembly 呼叫API 傳遞檔案的流程。\n環境 Blazor Webassembly Hybrid .Net 6 一般Web API專案比較單純，若是使用Blazor WebAssembly Hybrid 的方式，整個專案結構分為 Client、Server 與Shared，而Server 就可以把他當成一般的Web API專案，包含Controller 等結構。\nBlazor WebAssembly Hybrid Structure\r前置流程 安裝對應版本的 AWSSDK.S3 Nuget package AWSSDK.S3\n即可透過 AWS SDK 與 .NET 應用程式在 S3 上執行操作，\n取得授權金鑰 這個方法是透過第三方(Web API)來存取 AWS S3，需藉由 AWS Identity and Access Management (IAM) 安全地控制對AWS 資源的存取。也就是取得授權金鑰以便之後透過API 操作。(如何取得金鑰詳情請查閱官網!)\n設定金鑰至專案 C#的專案需要至appsettings.json設置，本專案設置結構如下:\n1{ 2 \u0026#34;AWS\u0026#34;: { 3 \u0026#34;AccessKey\u0026#34;: \u0026#34;Your AccessKey\u0026#34;, 4 \u0026#34;SecretKey\u0026#34;: \u0026#34;Your SecretKey\u0026#34; 5 } 6} 建立S3操作方法 基本設置 1using Amazon.Runtime; 2using Amazon.S3.Transfer; 3using Amazon.S3; 4using Amazon.S3.Model; 5using System.Web; 6 7private IConfiguration configuration; 8private readonly AwsCredentials awsCredentialsValues; 9private readonly BasicAWSCredentials credentials; 10private readonly AmazonS3Config config; 11 12public StorageService() 13{ 14 // Initializing configuration using appsettings.json file 15 configuration = new ConfigurationBuilder() 16 .AddJsonFile(\u0026#34;appsettings.json\u0026#34;) 17 .Build(); 18 19 // Retrieving AWS section from the configuration 20 var awsConfig = configuration.GetSection(\u0026#34;AWS\u0026#34;); 21 22 // Retrieving AccessKey and SecretKey from the AWS section 23 string accessKey = awsConfig[\u0026#34;AccessKey\u0026#34;]; 24 string secretKey = awsConfig[\u0026#34;SecretKey\u0026#34;]; 25 26 // Creating AWS credentials object 27 awsCredentialsValues = new AwsCredentials() 28 { 29 AccessKey = accessKey, 30 SecretKey = secretKey 31 }; 32 33 // Creating BasicAWSCredentials object using AccessKey and SecretKey 34 credentials = new BasicAWSCredentials(awsCredentialsValues.AccessKey, awsCredentialsValues.SecretKey); 35 36 // Configuring Amazon S3 region endpoint to APNortheast1 37 config = new AmazonS3Config() 38 { 39 RegionEndpoint = Amazon.RegionEndpoint.APNortheast1 40 }; 41} RegionEndpoint需根據S3選擇的服務地區修改。\n建立資料夾 1public async Task\u0026lt;bool\u0026gt; CreateFolder(string folderPath) 2{ 3 folderPath = HttpUtility.UrlDecode(folderPath); 4 var s3client = new AmazonS3Client(credentials, config); 5 6 PutObjectRequest request = new PutObjectRequest() 7 { 8 BucketName = \u0026#34;Your BucketName\u0026#34;, 9 Key = folderPath // in S3 key represents a path 10 }; 11 12 PutObjectResponse response = await s3client.PutObjectAsync(request); 13 14 if (response.HttpStatusCode == System.Net.HttpStatusCode.NoContent) 15 { 16 return true; 17 } 18 19 return false; 20} 上傳的物件結構(可根據需求設置)\n1 public class S3Obj 2 { 3 public string Name { get; set; } = null!; 4 public MemoryStream InputStream { get; set; } = null!; 5 public string BucketName { get; set; } = null!; 6 } 上傳檔案 1public async Task\u0026lt;S3ResponseDto\u0026gt; UploadFileAsync(S3Obj obj) 2{ 3 var response = new S3ResponseDto(); 4 try 5 { 6 var uploadRequest = new TransferUtilityUploadRequest() 7 { 8 InputStream = obj.InputStream, 9 Key = obj.Name, 10 BucketName = obj.BucketName, 11 CannedACL = S3CannedACL.NoACL 12 }; 13 14 // Initialize client 15 using var client = new AmazonS3Client(credentials, config); 16 17 // Initialize the transfer/upload tools 18 var transferUtility = new TransferUtility(client); 19 20 // Initiate the file upload 21 await transferUtility.UploadAsync(uploadRequest); 22 23 response.StatusCode = 201; 24 response.Message = $\u0026#34;{obj.Name}\u0026#34;; 25 } 26 catch (AmazonS3Exception s3Ex) 27 { 28 response.StatusCode = (int)s3Ex.StatusCode; 29 response.Message = s3Ex.Message; 30 } 31 catch (Exception ex) 32 { 33 response.StatusCode = 500; 34 response.Message = ex.Message; 35 } 36 return response; 37} 回傳的檔案物件(可根據需求設置)\n1public class S3FileInfo 2 { 3 public string Url { get; set; } = string.Empty; 4 public byte[]? File { get; set; } = null; 5 public string Name { get; set; } = string.Empty; 6 public string str_Id { get; set; } = string.Empty; 7 public int Order { get; set; } = 0; 8 } 因專案需求為使用檔案url在前端顯示。若要預防洩漏永久可使用網址(避免檔案供人任意下載傳遞)，取得檔案時藉由GetPreSignedURL取得預簽署 URL（Pre-signed URL）。\nPre-signed URL 是 Amazon S3（Simple Storage Service）提供的一種機制，允許以安全且有限的方式授予對存儲桶中特定資源的訪問權限。這是一個時間受限的 URL，授予了對於特定 S3 資源（如對象或文件）的暫時訪問權限。\n取得檔案 1public async Task\u0026lt;List\u0026lt;S3FileInfo\u0026gt;\u0026gt; GetFileAsync(ListObjectsV2Request request) 2{ 3 // Initialize Amazon S3 client 4 var s3client = new AmazonS3Client(credentials, config); 5 6 // Get objects list based on the provided request 7 var response = await s3client.ListObjectsV2Async(request); 8 List\u0026lt;S3FileInfo\u0026gt; result = new List\u0026lt;S3FileInfo\u0026gt;(); 9 10 foreach (var obj in response.S3Objects) 11 { 12 // Skip if the object is a folder (ends with \u0026#34;/\u0026#34;) 13 if (obj.Key.EndsWith(\u0026#34;/\u0026#34;)) continue; 14 15 // Generate a pre-signed URL for the object 16 var presignRequest = new GetPreSignedUrlRequest() 17 { 18 BucketName = \u0026#34;Your BucketName\u0026#34;, 19 Key = obj.Key, 20 Expires = DateTime.UtcNow.AddSeconds(86400), 21 }; 22 var presignedUrlResponse = s3client.GetPreSignedURL(presignRequest); 23 24 // The following content depends 25 //on the file\u0026#39;s naming convention 26 //logic and the format of the returned file 27 // Modify this logic according to your file 28 //naming conventions and desired file format 29 30 // Extract file information 31 string name = Path.GetFileName(obj.Key); 32 string[] info = name.Split(\u0026#39;.\u0026#39;); 33 string str_ID = string.Empty; 34 if (info.Length \u0026gt; 0) str_ID = info[0]; 35 36 // Add S3 file info to the result list 37 result.Add(new S3FileInfo 38 { 39 Url = presignedUrlResponse, 40 Name = obj.Key, 41 str_Id = str_ID 42 }); 43 } 44 return result; 45} 刪除檔案 1public async Task\u0026lt;bool\u0026gt; DeleteFileAsync(string key) 2{ 3 key = HttpUtility.UrlDecode(key); 4 var s3client = new AmazonS3Client(credentials, config); 5 var response = await s3client.DeleteObjectAsync(\u0026#34;YourBucketName\u0026#34;, key); 6 if (response.HttpStatusCode == System.Net.HttpStatusCode.NoContent) 7 { 8 return true; 9 } 10 return false; 11} key就是實際檔案的路徑，若要刪除的為資料夾，key為 ForderName/，若資料夾底下有檔案此方法就無法刪除資料夾，需先清空所有資料，才能刪除資料夾。\n以上的流程，主要根據目前專案需求實作幾個方法，包含建立資料夾、上傳檔案、以預簽署的方式取得檔案URL、與刪除檔案。\n接下來則是紀錄API的代碼與前端的部分如何呼叫API。\nBlazor Server端(Web API) 取得檔案 1[HttpGet(\u0026#34;product/{file}\u0026#34;)] 2public async Task\u0026lt;List\u0026lt;S3FileInfo\u0026gt;\u0026gt; GetProductFile(string file) 3{ 4 var request = new ListObjectsV2Request() 5 { 6 BucketName = \u0026#34;YourBucketName\u0026#34;, 7 Prefix = $\u0026#34;YourFolderName/{file}\u0026#34; 8 }; 9 10 List\u0026lt;S3FileInfo\u0026gt; FileInfo = await _storageService.GetFileAsync(request); 11 return FileInfo; 12} 上傳檔案 1[HttpPost(\u0026#34;product/{FileId}\u0026#34;)] 2public async Task\u0026lt;S3ResponseDto\u0026gt; UploadProductFile(IFormFile file, string FileId) 3{ 4 //Prevent unauthorized users from uploading 5 var authorizationHeader = HttpContext.Request.Headers[\u0026#34;Authorization\u0026#34;]; 6 bool IsAuthentication = _authService.CheckToken(authorizationHeader); 7 var result = new S3ResponseDto(); 8 9 if (IsAuthentication) 10 { 11 // Process file 12 await using var memoryStream = new MemoryStream(); 13 await file.CopyToAsync(memoryStream); 14 15 var fileExt = Path.GetExtension(file.FileName); 16 var docName = $\u0026#34;{FileId}{fileExt}\u0026#34;; 17 18 // Call server 19 var s3Obj = new S3Obj() 20 { 21 BucketName = \u0026#34;YourBucketName\u0026#34;, 22 InputStream = memoryStream, 23 Name = \u0026#34;YourFolderName/\u0026#34; + docName 24 }; 25 26 result = await _storageService.UploadFileAsync(s3Obj); 27 } 28 return result; 29} 刪除檔案 1[HttpDelete(\u0026#34;{key}\u0026#34;)] 2public async Task\u0026lt;bool\u0026gt; Delete(string key) 3{ 4 //Prevent unauthorized users from deleting 5 var authorizationHeader = HttpContext.Request.Headers[\u0026#34;Authorization\u0026#34;]; 6 bool IsAuthentication = _authService.CheckToken(authorizationHeader); 7 8 if (IsAuthentication) 9 { 10 return await _storageService.DeleteFileAsync(key); 11 } 12 else 13 { 14 return false; 15 } 16} Blazor Client端 註冊一個StorageService的服務，對應API的取得、上傳與刪除檔案等功能。\n實際代碼為:\n1public class StorageService : IStorageService 2{ 3 private readonly HttpClient _http; 4 5 public StorageService(HttpClient http) 6 { 7 _http = http; 8 } 9 10 public async Task\u0026lt;List\u0026lt;S3FileInfo\u0026gt;\u0026gt; GetProductFile(string file) 11 { 12 var result = await _http.GetFromJsonAsync\u0026lt;List\u0026lt;S3FileInfo\u0026gt;\u0026gt;($\u0026#34;api/Storage/product/{file}\u0026#34;); 13 return result; 14 } 15 16 public async Task\u0026lt;string\u0026gt; UploadFile(string FileId, string fileName, MemoryStream InputStream) 17 { 18 var response = await _http.PostAsync($\u0026#34;api/Storage/product/{FileId}\u0026#34;, 19 new MultipartFormDataContent { 20 { 21 new StreamContent(InputStream), \u0026#34;file\u0026#34;, fileName 22 } 23 }); 24 25 var newFileKey = (await response.Content.ReadFromJsonAsync\u0026lt;ServiceResponse\u0026lt;S3ResponseDto\u0026gt;\u0026gt;()).Message; 26 return newFileKey; 27 } 28 29 public async Task DeleteProductImage(string key) 30 { 31 key = $\u0026#34;YourFolderName/{key}\u0026#34;; 32 string encodedKey = Uri.EscapeDataString(key); 33 var result = await _http.DeleteAsync($\u0026#34;api/Storage/{encodedKey}\u0026#34;); 34 } 35} 結語 本篇主要為記錄如何透過AWS SDK 與.NET 操作 S3，實際API 的設置與Client 端串接其實可以更優化，避免Bucket 結構洩漏的風險，也因代碼已經是原本專案簡化後的結果，如有問題或錯誤歡迎提出。\n參考資料\nWorking with AWS S3 using ASP.NET Core – Upload, Download \u0026amp; Delete Files – Simplified Configuring AWS Credentials for .NET Applications – Detailed Guide Amazon S3 For the .NET Developer: How to Easily Get Started ",
	  "pubDate": "2023-12-05T11:05:34+08:00",
	  "cover": "https://sunnote.xyz/img/thumbnail/044.webp"

	}, 
	{
	
		
	  "url": "http://sunnote.xyz/zh-tw/tutorials/aspnetcore-6.0-blazor-globalization/",
	  "title": "ASP.NET Core Blazor 實作多國語系",
	  "summary": "\u003cp\u003e使用 ASP.NET Core Blazor 建立多國語系過程記錄。\u003c/p\u003e",
	  "content": "使用 ASP.NET Core Blazor 建立多國語系過程記錄。\n前言 因為在做side project常常喜歡中英夾雜顯示網站資訊，被合夥人嫌棄說又不是每個人都看得懂英文，想說乾脆做多語系讓人自由選擇，所以紀錄一下實作的過程。\n原理 要實作網站多語言功能，主要就是得預先把對應的翻譯資料建立好，藉由JS取得使用者慣用語言再顯示對應的語言在畫面上。好在Blazor已經提供了此功能，幾個步驟就能實現。\n環境 Blazor Webassembly .Net 6 流程1-註冊服務 安裝對應版本的套件\nMicrosoft.Extensions.Localization\n在 Program.cs註冊服務\n增加：\n1builder.Services.AddLocalization(); 與\n1var host = builder.Build(); 2CultureInfo culture; 3var js = host.Services.GetRequiredService\u0026lt;IJSRuntime\u0026gt;(); 4var result = await js.InvokeAsync\u0026lt;string\u0026gt;(\u0026#34;blazorCulture.get\u0026#34;); 5if (result != null) 6{ 7 culture = new CultureInfo(result); 8} 9else 10{ 11 culture = new CultureInfo(\u0026#34;zh-TW\u0026#34;); 12 await js.InvokeVoidAsync(\u0026#34;blazorCulture.set\u0026#34;, \u0026#34;zh-TW\u0026#34;); 13} 14CultureInfo.DefaultThreadCurrentCulture = culture; 15CultureInfo.DefaultThreadCurrentUICulture = culture; 主要是藉由JS取得local storage的語系參數，若無則預設為繁體中文。\n並移除 await builder.Build().RunAsync(); 改為await host.RunAsync();\n全部代碼為:\n1builder.Services.AddLocalization(); 2 3var host = builder.Build(); 4CultureInfo culture; 5var js = host.Services.GetRequiredService\u0026lt;IJSRuntime\u0026gt;(); 6var result = await js.InvokeAsync\u0026lt;string\u0026gt;(\u0026#34;blazorCulture.get\u0026#34;); 7if (result != null) 8{ 9 culture = new CultureInfo(result); 10} 11else 12{ 13 culture = new CultureInfo(\u0026#34;zh-TW\u0026#34;); 14 await js.InvokeVoidAsync(\u0026#34;blazorCulture.set\u0026#34;, \u0026#34;zh-TW\u0026#34;); 15} 16CultureInfo.DefaultThreadCurrentCulture = culture; 17CultureInfo.DefaultThreadCurrentUICulture = culture; 18 19//await builder.Build().RunAsync(); 20await host.RunAsync(); 接著需在專案檔增加此項目，點選 你的專案.Client\n\u0026lt;PropertyGroup\u0026gt;\r\u0026lt;BlazorWebAssemblyLoadAllGlobalizationData\u0026gt;true\u0026lt;/BlazorWebAssemblyLoadAllGlobalizationData\u0026gt;\r\u0026lt;/PropertyGroup\u0026gt; 實際會看起來像這樣\n\u0026lt;PropertyGroup\u0026gt;\r\u0026lt;TargetFramework\u0026gt;net6.0\u0026lt;/TargetFramework\u0026gt;\r\u0026lt;BlazorWebAssemblyLoadAllGlobalizationData\u0026gt;true\u0026lt;/BlazorWebAssemblyLoadAllGlobalizationData\u0026gt;\r\u0026lt;Nullable\u0026gt;enable\u0026lt;/Nullable\u0026gt;\r\u0026lt;ImplicitUsings\u0026gt;enable\u0026lt;/ImplicitUsings\u0026gt;\r\u0026lt;/PropertyGroup\u0026gt; 取得local storage參數的JS為(新增至wwwroot/index.html):\n1\u0026lt;script\u0026gt; 2 window.blazorCulture = { 3 get: () =\u0026gt; window.localStorage[\u0026#39;BlazorCulture\u0026#39;], 4 set: (value) =\u0026gt; window.localStorage[\u0026#39;BlazorCulture\u0026#39;] = value 5 }; 6\u0026lt;/script\u0026gt; 流程2-建立對應翻譯資訊 在 你的專案.Client/Shared/ResourceFiles 建立資源檔案\n建立資源檔案\r與其他語系的資源檔，這裡額外新建英文語系結構如下\n專案結構\r然後就能建立好key對應實際語系的文字資料。\n流程3-修改畫面 接下來只要在想要的畫面對應的razor檔案，使用資源檔與注入服務就能達到更換語系的效果。\n1@inject Microsoft.Extensions.Localization.IStringLocalizer\u0026lt;Resource\u0026gt; localizer 2@using ShowcaseBlazorApp.Client.Shared.ResourceFiles 需要做到多語系變換的字串使用\n1@localizer[\u0026#34;key\u0026#34;] 就能順利取得資源檔的value並顯示。\n這裡發現若找不到對應的資源檔，會直接顯示key，所以我就直接用中文版本的翻譯當key來使用，這樣就只需要新增英文語系對應的value就好。\n流程4-增加語系選單 官網的範例為新增一個簡單的下拉選單物件 CultureSelector.razor\n1@using System.Globalization 2@inject IJSRuntime JS 3@inject NavigationManager Navigation 4 5\u0026lt;p\u0026gt; 6 \u0026lt;label\u0026gt; 7 Select your locale: 8 \u0026lt;select @bind=\u0026#34;Culture\u0026#34;\u0026gt; 9 @foreach (var culture in supportedCultures) 10 { 11 \u0026lt;option value=\u0026#34;@culture\u0026#34;\u0026gt;@culture.DisplayName\u0026lt;/option\u0026gt; 12 } 13 \u0026lt;/select\u0026gt; 14 \u0026lt;/label\u0026gt; 15\u0026lt;/p\u0026gt; 16 17@code 18{ 19 private CultureInfo[] supportedCultures = new[] 20 { 21 new CultureInfo(\u0026#34;en-US\u0026#34;), 22 new CultureInfo(\u0026#34;zh-TW\u0026#34;), 23 }; 24 25 private CultureInfo Culture 26 { 27 get =\u0026gt; CultureInfo.CurrentCulture; 28 set 29 { 30 if (CultureInfo.CurrentCulture != value) 31 { 32 var js = (IJSInProcessRuntime)JS; 33 js.InvokeVoid(\u0026#34;blazorCulture.set\u0026#34;, value.Name); 34 35 Navigation.NavigateTo(Navigation.Uri, forceLoad: true); 36 } 37 } 38 } 39} 在MainLayout.razor中增加下拉選單以利使用者能隨時切換語系\n1\u0026lt;article class=\u0026#34;bottom-row px-4\u0026#34;\u0026gt; 2 \u0026lt;CultureSelector /\u0026gt; 3\u0026lt;/article\u0026gt; 下拉選擇語系選單\r以上為針對Blazor Webassembly 增加多語系的實作流程，其實還有部分內容像是自動取得使用者慣用語系..等沒研究，不過使用選單改變語系已剛好符合個人使用需求，所以就先這樣惹。\nReference\nASP.NET Core Blazor 全球化和當地語系化 [Blazor Webassembly] 下拉選單選擇多國語系 ",
	  "pubDate": "2023-11-16T11:05:34+08:00",
	  "cover": "https://sunnote.xyz/img/thumbnail/043.webp"

	}, 
	{
	
		
	  "url": "http://sunnote.xyz/zh-tw/book/just-keep-buying/",
	  "title": "投資的最佳實證方法-持續買進(好書推薦)",
	  "summary": "\u003cp\u003e持續買進：資料科學家的投資終極解答，存錢及致富的實證方法 這本書的閱讀心得分享。\u003c/p\u003e",
	  "content": "持續買進：資料科學家的投資終極解答，存錢及致富的實證方法 這本書的閱讀心得分享。\n前言 摸索投資理財已經一段時間了，從技術分析至價值投資透過各種觀念的迭代，自認也已經是個投資概念合格的一員，認為只要觀念正確，致富也只是時間早晚而已。但在跟親人、朋友討論投資理念時，總是很難把概念、原理清楚的表示，我想就是因為缺乏歷史數據的推倒與佐證吧。\n巴菲特爺爺說過\n\u0026ldquo;In the business world, the rear view mirror is always clearer than the windshield.\u0026rdquo; - Warren Buffett\n數據分析背景出身的我，也清楚知道未來不一定會沿著歷史數據的趨勢走。現實中也不可能只看著後照鏡開車，但以之前的歷史軌跡數據為基礎確實能模擬或是預測之後會經歷怎樣情況的概率，而提前預防或是降低風險。所以偶然發現了這本書大大的標題以資料科學為基底，佐證正確的投資方法，確實吸引我閱讀。\n內容大意-儲蓄 本書主要分為儲蓄與投資兩部分，各部分再細分多個小章節。在儲蓄的部分包含探討你應該存多少錢？、如何存更多錢？、該不該舉債？ 、該租屋還是買房？ 、何時可以退休？\u0026hellip;等章節，相信對投資理財有一定基礎的人，都大概有個底。不過若是投資小白我是認為對於基本觀念的建立很有幫助。\n這裡主要分享幾個對於我的理解算是新概念的部分\n如何無罪惡感地花錢？ 其實對於如何儲蓄，我本來的想法就是，不該花不是必須要的錢，錢自然能存下來，但什麼是必須什麼是不必須，在這日新月異的時代，還真不好判斷，而且若是抱持著我這種觀念，有時候反而會陷入只是在生存而不是生活的處境，錢更多了但反而活的更辛苦了。\n所以書中有闡述如何花錢，我相信除了我這對於月光族派但又很想儲蓄也是很有幫助的。\n生活方式膨脹多少無傷大雅？ 這個部分我也覺得蠻重要的，畢竟現今每個人至少都有理財的概念，平常省吃儉用，但往往在生活處境提升後，例如升官、加薪等，後報復性的花費更多的錢，導致明明領的錢變多了，卻活得比之前更窮。書中說明了該花費的比例與實證計算，可以清楚讓人知道如何賺多花多但又不讓自己的資產縮水。\n內容大意-投資 接下來儲蓄是更進階的的部分，包含為何你應該投資？、你應該投資什麼？、為什麼你不該買個股？、你應該多早開始投資？、為何你不該等到逢低才買進？、為什麼投資靠運氣？ 、為何你不該害怕市場波動？ 、如何在危機時期買進？ 、你應該在何時賣出？\n還有我覺得算是人生哲學的部分， 為何你永遠都不覺得自己有錢？與 最重要的資產 等章節。\n以上關於投資的部份，書中都給予數據實證，讓你可以更確切的知道自己的投資理念背後的數據理論。相信只要效仿排除投機心態與無知，每個人都能慢慢致富。\n但最重要的是最後幾章，像是 最重要的資產 此章節，書中舉例\n我敢打賭，若巴菲特的所有財產端出來給你，沒有任何一個人願意和現在的他交換身分。反之，若巴菲特能多活二十年，他也願意現在變成一窮二白。\n人最重要的資產，其實就是時間，賺錢、儲蓄、投資其實就只是為了能有更多自己的時間，如何在這人生短短的數十年，在賺錢、儲蓄、投資與好好生活間取得一個平衡，靠的是自己清楚知道自己要的，渴望的是什麼。\n結論 本來覺得投資相關的書籍，都是千篇一律，但從以數據為基礎佐證正確的投資概念的書籍實在是少數，至書末提出的時間才是最重要的資產的結論，不管是投資新手或是老手都適合的一本書，希望投資新手能藉由這本書更加深正確的投資概念，也期許自己在追求財富的同時也能享受生活不本末倒置。\n",
	  "pubDate": "2023-11-15T07:44:38+08:00",
	  "cover": "https://sunnote.xyz/img/thumbnail/042.webp"

	}, 
	{
	
		
	  "url": "http://sunnote.xyz/zh-tw/life/nasal-septum-inferior-turbinate-hypertrophy-surgery/",
	  "title": "鼻中膈成形+下鼻甲氣化棒減積手術分享(鼻中膈彎曲+下鼻甲肥大)",
	  "summary": "\u003cp\u003e過敏導致鼻中膈彎曲與下鼻甲肥大手術過程與注意事項分享。\u003c/p\u003e",
	  "content": "過敏導致鼻中膈彎曲與下鼻甲肥大手術過程與注意事項分享。\n前言 從小就飽受過敏困擾，雖然長大後過敏症狀有稍微減輕，但因為有鼻中膈彎曲加上長期過敏導致的下鼻甲肥大，呼吸總是不順暢，如果遇到生病或是免疫力較低過敏症狀加重時，很容易鼻塞導致淺眠，看了一些資訊關於睡不好所會導致心血管疾病，糖尿病風險提升，又不想一直拿藥下定決心做手術看看能否改善。\n醫生選擇 其實一開始是在離家較近的診所，看診拿藥，注意到這位醫生有自己在做縮小鼻甲肥大的手術，標榜不太會流血不用住院，並沒有動刀只是讓鼻甲縮小而詢問，卻被告之，我這是鼻中膈彎曲嚴重，只讓鼻甲縮小不太有效果，就被拒絕了。\n所以決定前往大醫院看診，最後決定執行手術的醫生為 高雄長庚-陳韋至 醫師，在掛號需要注意看診醫師的專業，第一次預約是另外醫師，雖然都是耳鼻喉科，但專業為喉科，實際看診就是驗血測過敏指數，然後說我數值太高，開了也沒用就勸退。第二次不死心，約診了鼻科專業的陳韋至醫師，看診則是觀察我鼻腔構造，告知彎曲嚴重可以選擇動手術，並說明一些風險之類的，還有詢問需要自費的項目包含鼻中膈成形+下鼻甲氣化棒減積手術(30000元)，確認了就預約執行手術的日期。\n手術過程 手術當天為禮拜五，需要在禮拜四中午提前報到住院，並進行麻醉風險評估，麻醉醫生會詢問了是否增加自費項目，有一項是監測儀器，就是監測麻醉深度的，價格為1500元，可以讓麻醉師比較知道目前患者麻醉深度，聽說加了較安全就自費了。接下來就可以去自己的病房，健保房為3人房，然後因為隔天要手術，所以當天晚上12點後就不行進食，包含水。\n凌晨5點，因禁食護理師會來幫忙打葡萄糖液，插針後基本上就是得插到出院，包含手術後的抗生素等都是透過點滴打進身體。早上7點多醫師會來詢問狀況，悲劇的是因為陳韋至醫師當天接受手術的病患很多，順序就是採用老幼青壯年，所以我只能等待至下午兩點多，才能進行手術，因為有打點滴所以基本上身體並不會有任何不適，只是整天就很無聊而已。\n進行手術包含等待、進入手術房，其實都還算是輕鬆愜意，護理師也都很親切，剛到手術台時，護理師還會詢問會不會冷，除了蓋棉被外，還外加一個暖氣直接連通我的棉被，導致當我手術後醒來時，連腳都很溫暖😎。\n手術麻醉開始時，可能劑量不大所以只會頭有點暈，接著麻醉師會說明一些提醒事項，不知道為何會這時才說😎，說著說著就睡著了 \u0026hellip; 然後又醒了。\n醒後，其實身體很舒服，不知道是不是因為有自費加購檢測的，所以完全沒有頭暈想吐之類的，而且鼻子完全暢通!!超開心，接著在恢復室休息一陣子就被推回病房了。\n術後回復 不過隨著麻醉減退後，開始鼻塞了，而且非常嚴重，有長期鼻塞經驗的應該都可以忍受短暫的鼻塞，但這種鼻塞是全部塞住，我認為應該是傷口嚴重腫脹的關係，根本連吞口水都很難。整晚護理師會定時進來確認點滴與抗生素劑量加上超塞的鼻子真的超級難睡。\n禮拜五開完刀，禮拜六一早需回診讓醫師查看傷口，基本上就是做一點點的清潔確認沒有感染，就OK了。接下來醫院有提供購買洗鼻器，也是自費項目，金額為1200元，之後上網爬文，發現其實有更便宜的選擇，但因當時是家人跟護理師諮詢，所以就直接購買了。若本來就有洗鼻習慣的應該就不需要。\n禮拜日中午就能出院，所以待在醫院總耗時大約3天整。\n回家後幾天詳細查閱洗鼻器說明書，才發現若鼻塞嚴重時其實是無法使用洗鼻器的，難怪我在醫院時，嘗試使用時水柱一直往耳朵衝超痛\u0026hellip;，但護理師與醫師又說可以開始洗了，一天還要四次!!!。這邊就是自己斟酌吧，我之後是先暫停，不然感覺會變成中耳炎。\n接下來幾天很艱困，因為鼻塞還是持續，而且是完全塞住的那種。沒什麼能做的，就是多補充營養，看能不能多睡點，恢復更快一點度過這個階段。\n下一個回診時段為禮拜三，距離開刀已經5天了，醫師除了檢查手術情況，基本上就是幫忙清理卡在鼻腔裡的血塊，這就是導致鼻塞的主因，過程不會有什麼疼痛感，清完後，鼻子又瞬間暢通，或許頻繁的洗鼻子，可以避免血塊卡住吧。不過暢通一陣子又塞了\u0026hellip;，不確定是又有血塊，還是傷口還是處於過敏反應較激烈的階段。再過個兩三天，鼻塞的症狀終於減輕了，終於可以好好睡覺了，鼻子也比較不會有血絲夾雜鼻涕，洗鼻子時水流也比較容易通過了，這次手術應該算告一段落了。😆\n結論 醫生預約一個月後再一次回診，我想那時若回復的差不多，應該也可以不用回診了(畢竟還要多花一筆掛號費)，應該沒什麼大問題!?😅\n主要需注意事項，就是自費的部分需自行斟酌，光氣化棒減積手術這部分就有兩種價格可以選擇，據醫生說明是溫度不同所以術後出血與恢復速度也不相同，然後是術後千萬不行擤鼻子，可能會導致傷口無法癒合流更多血，都有照著規則走，我個人在術後是沒有留太多的血，鼻子也不太有疼痛感(也可能是按時吃止痛藥的關係!?😆)。\n從開刀後至現在，大概已經兩個禮拜，目前鼻子通暢，只剩左側主要開刀處(鼻中膈往左歪)，還稍微沒有那麼暢通，但跟以前比也好很多了，應該算手術成功，希望之後睡眠品質能越來越好，非常感謝醫師，還有護理師。去一趟醫院，才知道醫護人員工作有多辛苦，希望台灣的醫療環境能更好👍。\n",
	  "pubDate": "2023-10-06T19:44:38+08:00",
	  "cover": "https://sunnote.xyz"

	}, 
	{
	
		
	  "url": "http://sunnote.xyz/zh-tw/tutorials/hugo-auto-update-last-modified/",
	  "title": "Hugo 自動更新文章最後修改日期:簡化管理步驟、提升SEO",
	  "summary": "\u003cp\u003e由從 Front Matter 設置，改為使用文章檔案的修改日期為預設文章更新日期，簡化繁瑣流程，提升SEO排名。\u003c/p\u003e",
	  "content": "由從 Front Matter 設置，改為使用文章檔案的修改日期為預設文章更新日期，簡化繁瑣流程，提升SEO排名。\n前言 常會有編輯或是更新文章內容的情況，通常為了SEO或是告知讀者此文屬於最新的內容，通常需要標示文章的最後修改日期，原本都是使用Front Matter，在每篇的文章內容裡，若想顯示文章的最後編輯時間，就會加上lastmod 欄位並加上日期，但使用起來其實蠻麻煩的，因為每次修改文章就要對欄位進行編輯，若有大量文章，那步驟就會很繁瑣，查詢了資料，發現其實可以直接在config.toml，新增預設的Front Matter參照順序就能在文章未添加使用lastmod的情況下，自動代入任何想要的值，達到預設顯示lastmod的效果。\n方法 只要在config.toml加上以下語法:\n1[frontmatter] 2lastmod = [\u0026#34;lastmod\u0026#34; ,\u0026#39;:fileModTime\u0026#39;, \u0026#34;:git\u0026#34;, \u0026#34;date\u0026#34;] :fileModTime : 檔案的最後修改時間\nlastmod : 原本的lastmod日期\n:git : 據說是可以使用 git 的 commit 時間當作顯示日期，但這邊沒做更多的研究。\ndate: 文章的發布日期\n這個方法就是修改lastmod的預設資料(由排序第一的優先顯示，若找不到再往下一個尋找。)\n所以語法其實只要這樣就好。\n1[frontmatter] 2lastmod = [\u0026#34;lastmod\u0026#34; ,\u0026#39;:fileModTime\u0026#39;] 若文章沒有lastmod此欄位，則預設使用:fileModTime為文章的最後修改時間。\n但這樣的方式，會導致每篇文章都會顯示最後修改時間，畢竟通常文章的date與:fileModTime都會有差異。\n我的作法是，藉由修改根目錄\\themes\\{your theme}\\layouts\\partials\\post_meta\\date.html去達到部分文章修改日期隱藏的效果。\n程式碼:\n1{{- if not .Date.IsZero }} 2\u0026lt;div class=\u0026#34;meta__item-datetime meta__item\u0026#34;\u0026gt; 3\t{{ partial \u0026#34;svg/calendar.svg\u0026#34; (dict \u0026#34;class\u0026#34; \u0026#34;meta__icon\u0026#34;) -}} 4\t\u0026lt;time class=\u0026#34;meta__text\u0026#34; datetime=\u0026#34;{{ .Date.Format \u0026#34;2006-01-02T15:04:05Z07:00\u0026#34; }}\u0026#34;\u0026gt; 5\t{{- .Date.Format (.Site.Params.dateformat | default \u0026#34;January 02, 2006\u0026#34;) -}} 6\t\u0026lt;/time\u0026gt; 7\t{{- $dateDiff := .Lastmod.Sub .Date -}} 8\t{{- if ge $dateDiff.Hours 100 }} 9\t\u0026lt;time class=\u0026#34;meta__text\u0026#34; datetime=\u0026#34;{{ .Lastmod.Format \u0026#34;2006-01-02T15:04:05Z07:00\u0026#34; }}\u0026#34;\u0026gt;( 10\t{{- T \u0026#34;meta_lastmod\u0026#34; }}: {{ .Lastmod.Format (.Site.Params.dateformat | default \u0026#34;January 02, 2006\u0026#34;) -}} 11\t)\u0026lt;/time\u0026gt; 12\t{{- end -}} 13\u0026lt;/div\u0026gt; 14{{- end }} 修改部分如下，邏輯為先計算文章日期.Date 與 修改日期.Lastmod的時間差異。\n若時間差異大於100小時，則顯示修改日期。(此數值可以自己修改，因為本身習慣從文章撰寫到發佈通常耗時會小於一個禮拜，所以只要修改日期多於文章日期一個禮拜，就代表文章有內容更新即顯示修改日期。)\n1{{- $dateDiff := .Lastmod.Sub .Date -}} 2{{- if ge $dateDiff.Hours 100 }} 3\u0026lt;time class=\u0026#34;meta__text\u0026#34; datetime=\u0026#34;{{ .Lastmod.Format \u0026#34;2006-01-02T15:04:05Z07:00\u0026#34; }}\u0026#34;\u0026gt;( 4\t{{- T \u0026#34;meta_lastmod\u0026#34; }}: {{ .Lastmod.Format (.Site.Params.dateformat | default \u0026#34;January 02, 2006\u0026#34;) -}} 5\t)\u0026lt;/time\u0026gt; 6{{- end -}} 結語 使用此方法可以有效率的管控修改日期，甚至可以只使用最新的修改日期為發佈日期，達到讀者觀看時都會覺得文章是剛發佈的內容是全新的，至於瀏覽器會怎麼判斷，SEO會如何排名就不清楚了😎。\n",
	  "pubDate": "2023-08-21T10:51:46+08:00",
	  "cover": "https://sunnote.xyz/img/thumbnail/040.webp"

	}, 
	{
	
		
	  "url": "http://sunnote.xyz/zh-tw/life/mk870-hand-rest-unboxing/",
	  "title": "開箱腹靈MK870機械鍵盤與非洲花梨木質手托",
	  "summary": "\u003cp\u003e腹靈MK870機械鍵盤的使用體驗~\u003c/p\u003e",
	  "content": "腹靈MK870機械鍵盤的使用體驗~\n前言 身為一個碼農，鍵盤大概是一天使用最頻繁的東西，但窮窮的我總是抱持著東西還能用就不需要換的心態。這次終於下定決心好好犒賞自己一下，雖然對機械式鍵盤沒什麼研究，平常也都是使用剪刀腳鍵盤，但因為使用體驗真的不錯，就來純粹分享一下腹靈MK870機械鍵盤。沒有什麼專業評語，外表質感高、使用感覺爽 就這樣😎。 (淘寶真的太好逛了，下單完鍵盤，又看到手托還可以免費幫刻字，立碼加購 ❗)\n實物 購買的是三模機械鍵盤，平常就是使用無線藍芽與電腦連接，目前使用起來連線順暢也沒有延遲的問題，鍵盤RGB燈也可以自己調整喜歡的樣式，實際測試唯有使用有線模式連接電腦，鍵盤RGB燈的驅動才可以有效讀取並調整，可以調整完再換回無線模式就好。\n側刻鍵帽\rMK870與非洲花梨木質手托\rBe More Than Just a Code Monkey.\n期許自己不管是人生還是程式都可以更精進。\n",
	  "pubDate": "2023-08-09T08:29:23+08:00",
	  "cover": "https://sunnote.xyz/img/thumbnail/039.webp"

	}, 
	{
	
		
	  "url": "http://sunnote.xyz/zh-tw/tutorials/mongodb-atlas-crud/",
	  "title": "使用 .NET 6 進行 MongoDB Atlas CRUD 操作",
	  "summary": "\u003cp\u003e紀錄.net core 6 操作 MongoDB 的一些常用語法。\u003c/p\u003e",
	  "content": "紀錄.net core 6 操作 MongoDB 的一些常用語法。\n前言 雖然使用 C# 還是本身微軟的 MSSQL 最方便好用，但還是試著嘗試藉由學習 NoSQL 這個機會，來嘗試使用 C# 操作 MongoDB 的 CRUD。\n使用 MongoDB Atlas 建立好 Database 還有collection 後，就可以進行 CRUD 的練習，也可以直接使用官方給的範例資料庫。\n相關內容可以查詢上一篇 MongoDB Atlas 資料庫基礎觀念、操作流程與使用 Compass 連線。\n資料庫連線 在官網的Database Deployments 點選 Connect \u0026gt; Drivers 就會顯示依據選擇的語言的連線語法。\n首先需為專案安裝 MongoDB.Driver\ndotnet add package MongoDB.Driver 以下為 C#，版本 2.13 or later 的連線字串\n1const string connectionString = \u0026#34;mongodb+srv://\u0026lt;name\u0026gt;:\u0026lt;password\u0026gt;@cluster0.swvkd15.mongodb.net/?retryWrites=true\u0026amp;w=majority\u0026#34;; 建立連線\n1var client = new MongoClient(connectionString); 2var collection = client.GetDatabase(\u0026#34;sample_analytics\u0026#34;).GetCollection\u0026lt;BsonDocument\u0026gt;(\u0026#34;customers\u0026#34;); 取得sample_analytics中的customers集合，後續可藉由collection進行相關讀寫操作。\nBsonDocument BsonDocument是 MongoDB 中的一種資料類型，用於表示 BSON（Binary JSON）格式的文件。BSON 是一種輕量級的二進制序列化格式，用於在 MongoDB 中儲存和交換資料。BsonDocument可以看作是一個動態的、無模式的文件，類似於 NoSQL 資料庫中的文檔。\n在 MongoDB 中進行儲存和交換資料時都需要先轉換成BsonDocument的格式。\n以下是BsonDocument的一些特點和用途：\n動態結構： BsonDocument 是動態結構的，不需要事先定義欄位或模式，這使得它在處理多樣性資料時非常靈活。\n儲存 MongoDB 文件： BsonDocument 可以代表 MongoDB 集合中的單個文件。它包含了鍵值對，其中鍵是字段名，值可以是各種 BSON 類型（如字符串、數字、日期等）。\n用於操作： 在 MongoDB 的 .NET 驅動程式中，BsonDocument 通常用於執行查詢、插入、更新和刪除等操作。\n可序列化： BsonDocument 可以輕鬆地序列化成 BSON 格式，並且可以在不同應用程式和語言之間進行傳遞。\n應用廣泛： BsonDocument 在 MongoDB 開發中被廣泛使用，特別是在需要處理不同結構的動態資料時。\n接下來紀錄一下CRUD的基本操作語法。\n查詢 取得所有的資料\n1var documents = collection.Find(new BsonDocument()).ToList(); 限制取得前10筆資料\n1var documents = collection.Find(new BsonDocument()).Limit(10).ToList(); 取得排序後的資料，以下為取得按Date欄位降序排序後的資料。\n1var sort = Builders\u0026lt;BsonDocument\u0026gt;.Sort.Descending(\u0026#34;Date\u0026#34;); 2var sortedDocuments = collection.Find(new BsonDocument()).Sort(sort).ToList(); 可以先定義查詢條件再藉由Find方法執行查詢\n查詢 name 欄位為 \u0026quot;Alice\u0026quot; 且 age 欄位大於等於 25 的所有資料\n1var filter = Builders\u0026lt;BsonDocument\u0026gt;.Filter.And( 2 Builders\u0026lt;BsonDocument\u0026gt;.Filter.Eq(\u0026#34;name\u0026#34;, \u0026#34;Alice\u0026#34;), 3 Builders\u0026lt;BsonDocument\u0026gt;.Filter.Gte(\u0026#34;age\u0026#34;, 25) 4 ); 查詢 name 欄位為 \u0026quot;Alice\u0026quot; 且 (age \u0026gt; 30 或 age \u0026lt; 10) 的所有資料\n1var filter = Builders\u0026lt;BsonDocument\u0026gt;.Filter.And( 2 Builders\u0026lt;BsonDocument\u0026gt;.Filter.Eq(\u0026#34;name\u0026#34;, \u0026#34;Alice\u0026#34;), 3 Builders\u0026lt;BsonDocument\u0026gt;.Filter.Or( 4 Builders\u0026lt;BsonDocument\u0026gt;.Filter.Gt(\u0026#34;age\u0026#34;, 30), 5 Builders\u0026lt;BsonDocument\u0026gt;.Filter.Lt(\u0026#34;age\u0026#34;, 10) 6 ) 7 ); 定義好查詢條件後，再使用Find方法執行查詢\n1var queryResult = collection.Find(filter).ToList(); 查詢取得特定參數 範例資料:\n1using MongoDB.Bson; 2 3BsonDocument document = new BsonDocument 4{ 5 { \u0026#34;name\u0026#34;, \u0026#34;Alice\u0026#34; }, 6 { \u0026#34;age\u0026#34;, 30 }, 7 { \u0026#34;email\u0026#34;, \u0026#34;alice@example.com\u0026#34; } 8}; 接下來提供3種方法取得document的值:\n使用索引獲取值 1string name = document[\u0026#34;name\u0026#34;].AsString; 2int age = document[\u0026#34;age\u0026#34;].AsInt32; 3string email = document[\u0026#34;email\u0026#34;].AsString; 使用 GetValue 方法獲取值，此方法可以預防值不存在的情況 1BsonValue nameValue; 2if (document.TryGetValue(\u0026#34;name\u0026#34;, out nameValue)) 3{ 4 string name = nameValue.AsString; 5} 使用 TryGetElement 方法獲取值，可以取得鍵與對應的值 1BsonElement nameElement; 2if (document.TryGetElement(\u0026#34;name\u0026#34;, out nameElement)) 3{ 4 string name = nameElement.Value.AsString; 5} 將 bsonDocument 轉為 List\u0026lt;\u0026gt;\n1List\u0026lt;People\u0026gt; result = documents.Select(bsonDocument =\u0026gt; new People 2 { 3 name = bsonDocument.GetValue(\u0026#34;name\u0026#34;).AsString, 4 age = bsonDocument.GetValue(\u0026#34;age\u0026#34;).AsInt32, 5 email = bsonDocument.GetValue(\u0026#34;email\u0026#34;).AsString, 6 // Map other properties as needed 7 }).ToList(); 新增 Json格式的物件，可以直接轉換成BsonDocument即可存入DB\n1string jsonString = \u0026#34;{ \\\u0026#34;name\\\u0026#34;: \\\u0026#34;Alice\\\u0026#34;, \\\u0026#34;age\\\u0026#34;: 30, \\\u0026#34;email\\\u0026#34;: \\\u0026#34;alice@example.com\\\u0026#34; }\u0026#34;; 2BsonDocument document = BsonDocument.Parse(jsonString); 3collection.InsertOne(document); 若要同時存入多筆則可使用collection.InsertMany(Multiple);\n也可以直接建立BsonDocument物件再存入DB\n範例為儲存多個物件至DB\n1BsonDocument newDocument1 = new BsonDocument 2{ 3 { \u0026#34;name\u0026#34;, \u0026#34;Alice\u0026#34; }, 4 { \u0026#34;age\u0026#34;, 30 } 5}; 6BsonDocument newDocument2 = new BsonDocument 7{ 8 { \u0026#34;name\u0026#34;, \u0026#34;Alvin\u0026#34; }, 9 { \u0026#34;age\u0026#34;, 29 } 10}; 11 List\u0026lt;BsonDocument\u0026gt; Multiple = new List\u0026lt;BsonDocument\u0026gt;(); 12 Multiple.Add(newDocument1); 13 Multiple.Add(newDocument2); 14 // 插入BsonDocument到集合中 15 collection.InsertMany(Multiple); 編輯 定義要查詢的條件，找到 name 為 \u0026ldquo;Alice\u0026rdquo; 的文件。\n1var filter = Builders\u0026lt;BsonDocument\u0026gt;.Filter.Eq(\u0026#34;name\u0026#34;, \u0026#34;Alice\u0026#34;); 定義要進行更新的操作，將 age 欄位更新為 31，email 欄位更新為新的值。\n1var update = Builders\u0026lt;BsonDocument\u0026gt;.Update 2 .Set(\u0026#34;age\u0026#34;, 31) 3 .Set(\u0026#34;email\u0026#34;, \u0026#34;newemail@example.com\u0026#34;); 使用 UpdateOne 方法進行更新，只會更新符合定義的第一筆資料。\n1var result = collection.UpdateOne(filter, update); 使用 UpdateMany 方法進行更新，更新符合定義的所有資料。\n1var result = collection.UpdateMany(filter, update); 刪除 刪除與編輯相同，都是先定義查詢的條件，再進行刪除。\n使用 DeleteOne 方法進行刪除，刪除符合條件的第一筆資料。\n1var result = collection.DeleteOne(filter); 使用 DeleteMany 方法進行刪除，刪除符合條件的所有資料。\n1var result = collection.DeleteMany(filter); ",
	  "pubDate": "2023-08-08T11:24:03+08:00",
	  "cover": "https://sunnote.xyz/img/thumbnail/038.webp"

	}, 
	{
	
		
	  "url": "http://sunnote.xyz/zh-tw/tutorials/cte-lazy-loading-infinite-data-structure/",
	  "title": "使用CTE（Common Table Expression）實現延遲加載(Lazy loading)與查詢無限層資料結構",
	  "summary": "\u003cp\u003e紀錄後端如何實現 Lazy loading 查詢無限層結構的資料。\u003c/p\u003e",
	  "content": "紀錄後端如何實現 Lazy loading 查詢無限層結構的資料。\n前言 普遍社群媒體都有提供留言功能，而使用者又能針對特定的留言回覆，產生多層留言。若系統沒有限制則會產生無限層留言的情況。此篇針對無限層的資料結構，紀錄如何查詢並實現延遲載入的功能。\n無限層資料結構 Field Name Description comment_id 留言ID parent_id 父層留言的ID，若為null代表第一層 此結構可以存儲留言及其層級關係，comment_id 用於標識每個留言，parent_id 用於指示該留言是哪個父留言的回覆。\n實現延遲加載 延遲加載由前端實作，後端則負責依序給予對應的資料，只要使用 OFFSET - FETCH 分頁技巧就能依照自己要的順序，給予對應的資料。\ne.g.\n1 OFFSET 0 ROWS FETCH NEXT 2 ROWS ONLY 表示取從第0筆資料開始的後兩筆資料 = 取第1、2筆資料(可以依據需求更改)。\n使用CTE實現讀取無限層資料結構 留言的部分利用建立時間做排序就能依序取得資料解決延遲載入，但遇到的問題是子留言的建立時間並不是照著順序的，有可能第一層最舊的留言會有新的子留言，這時如果只照著建立時間排序，若回傳最新的10筆資料，就會產生前端拿到這則最新的子留言，卻沒拿到原本第一層的父留言，導致畫面出錯的問題。\n所以為了解決此問題取資料時的分頁排序還是以第一層的建立時間為基準，取最新10筆的第一層留言，並包含10筆全部的子留言，這樣就不會有子層留言對應不到父層留言的問題。\n但也因為可以有無限子留言，要每一層都確實撈取到就要使用CTE。\n假設資料表名為comment_history\ne.g.\n1WITH CommentHierarchy AS ( 2 -- Anchor member definition 3 SELECT 4 comment_id, 5 parent_id, 6 message, 7 created_time, 8 created_user, 9 1 AS Level 10 FROM 11 comment_history 12 WHERE 13 parent_id IS NULL -- Fetching top-level comments 14\tand comment_id in ( 15 select comment_id from comment_history 16 where parent_id is null　17 order by created_time desc 18 OFFSET 0 ROWS FETCH NEXT 10 ROWS ONLY) 19\t20 21 UNION ALL 22 23 -- Recursive member definition 24 SELECT 25 c.comment_id, 26 c.parent_id, 27 c.message, 28 c.created_time, 29 c.created_user, 30 ch.Level + 1 AS Level 31 FROM 32 comment_history c 33 INNER JOIN 34 CommentHierarchy ch ON c.parent_id = ch.comment_id 35) 36SELECT 37 comment_id, 38 parent_id, 39 message, 40 created_time, 41 created_user, 42\tLevel 43FROM 44 CommentHierarchy 45ORDER BY 46 created_time DESC 語法解釋:\n建立 CommentHierarchy ，先取留言的原始資料 where 條件為\nparent_id IS NULL (代表為第一層) 與\ncomment_id in (\rselect comment_id from comment_history\rwhere parent_id is null　order by created_time desc OFFSET 0 ROWS FETCH NEXT 10 ROWS ONLY) 配合延遲載入取前10筆最新的留言，並建立新欄位 Level 值為 1 (第一層留言)。\n有了第一層後，使用原本的資料與 CommentHierarchy JOIN，綁定關係為原本資料的parent_id等於CommentHierarchy的comment_id。(藉由第一層comment_id，取第二層子留言)\n-- Recursive member definition\rSELECT\rc.comment_id,\rc.parent_id,\rc.message,\rc.created_time,\rc.created_user,\rch.Level + 1 AS Level\rFROM\rcomment_history c\rINNER JOIN\rCommentHierarchy ch ON c.parent_id = ch.comment_id 持續藉由 CommentHierarchy的comment_id判斷是否有子留言，是使用遞歸的方式取得每層子留言，最後合併所有資料。\n結語 以上就能取得父層留言的所有子留言，並標示留言的層數。\ncomment_id parent_id message created_time created_user Level 138808E8-5FFA-4F26-927D-3E06654079BC 82D25141-29D3-4135-A162-A588B61AA6EF 2233 2023-07-25 11:55:44.443 Alvin 2 0D46466C-3725-4FBA-9676-C1D364ED0D16 82D25141-29D3-4135-A162-A588B61AA6EF 1112 2023-07-25 11:16:55.977 OKA 2 548439B1-7D6C-4268-88CA-A52570DC5409 30C7A6F8-4E69-4F3C-836B-04AEBAE46F84 test 2023-07-25 11:10:43.610 David 3 30C7A6F8-4E69-4F3C-836B-04AEBAE46F84 82D25141-29D3-4135-A162-A588B61AA6EF XD 2023-07-25 11:10:17.560 Alvin 2 82D25141-29D3-4135-A162-A588B61AA6EF NULL so tired 2023-07-25 11:09:52.187 OKA 1 6722E047-5547-4EE7-8959-938A10534858 B6C20E72-2F7A-4891-B8A3-301DBBF72CC6 cool~ 2023-07-25 11:02:23.717 Alvin 2 2281BDB4-7B21-442F-84C5-A0736BE7DD9A B6C20E72-2F7A-4891-B8A3-301DBBF72CC6 wow new system 2023-07-25 11:02:19.607 Alvin 2 B6C20E72-2F7A-4891-B8A3-301DBBF72CC6 NULL what is this? 2023-07-25 11:02:09.060 JSON 1 ",
	  "pubDate": "2023-07-25T14:00:18+08:00",
	  "cover": "https://sunnote.xyz/img/thumbnail/037.webp"

	}, 
	{
	
		
	  "url": "http://sunnote.xyz/zh-tw/tutorials/aspnetcore-6.0-signalr-websocket-2/",
	  "title": ".NET 6 Web API 使用SignalR實作WebSocket技術實現即時通訊-2",
	  "summary": "\u003cp\u003e使用.NET 6 Web API 建立 WebSocket 通訊，本篇紀錄模擬將使用者對應至連線ID並儲存與發送訊息功能的測試過程。\u003c/p\u003e",
	  "content": "使用.NET 6 Web API 建立 WebSocket 通訊，本篇紀錄模擬將使用者對應至連線ID並儲存與發送訊息功能的測試過程。\n前言Foreword 上一篇已經介紹了全推播的使用方法，只要有連線上的使用者都能接收到訊息，接下來要模擬對特定使用者進行推播的功能。\n原理Principle WebSocket 通訊，只要使用者連線就會自動生成一個連線ID，若程式邏輯是使用者執行某項操作時，就對其推播訊息，是非常容易的，只要針對當下的連線ID發送推播即可。但實際上邏輯可能更複雜，通常會是使用者A執行某項操作，或是想直接對另一使用者B發送推播，這時就必須針對特定的使用者ID與連線ID進行綁定，這樣在進行推播時，才能藉由已知的使用者ID取得連線ID並推播。\n將使用者綁定至連線ID 通常在使用者連線時即需同時儲存使用者ID與連線ID，在實際要推播時才能查詢使用者對應的連線ID，方法主要分為儲存至記憶體與資料庫，儲存在記憶體的優點是效能較好，但若伺服器重啟相關資訊則會遺失;儲存在資料庫則可以永久儲存資料，缺點則是效能會較差一點。至於要選擇使用哪一種則需要考慮實際的應用情況。\n詳細資訊可以查閱教程: Mapping SignalR Users to Connections\n實作 預設使用者連線時需輸入使用者名稱，在按下登入時，會將使用者名稱傳給後端，後端立即將使用者名稱綁定此連線ID。後續若要傳遞給特定使用者，只要從儲存的數據中查詢使用者對應的連線ID，再傳送資訊即可。\n過程大致如下:\n輸入使用者名稱 ➜ 綁定使用者名稱與連線ID並儲存\n使用者B傳遞訊息給A ➜ 搜尋已儲存的使用者名稱A ➜ 取得連線ID並傳送\n使用者離線 ➜ 刪除已儲存的連線ID\n在 Hub/IMessageHub.cs 新增兩個介面:\n1namespace SignalR_Example.Hub 2{ 3 public interface IMessageHub 4 { 5 Task sendToAllConnections(List\u0026lt;string\u0026gt; message); 6 Task JsonDataTransfer(dynamic message); 7 Task StringDataTransfer(string message); 8 } 9} JsonDataTransfer 用來傳遞 JSON 物件\nStringDataTransfer 用來傳遞字串\n在 Hub/MessageHub.cs 新增幾個功能如下:\npublic static Dictionary\u0026lt;string, string\u0026gt; userInfoDict = new Dictionary\u0026lt;string, string\u0026gt;(); 因為只是模擬，資料的儲存僅使用記憶體儲存。\nuserInfoDict 的 key 為使用者名稱，value 為 連線ID。\npublic async Task LoadUserInfo(dynamic message) { dynamic dynParam = JsonConvert.DeserializeObject(Convert.ToString(message)); string userID = dynParam.userId; var ID = Context.ConnectionId; userInfoDict[userID] = ID; await Clients.Client(ID).StringDataTransfer(\u0026#34;Login successfully.\u0026#34;); } 模擬前端在使用者登入時，傳送Json物件給後端，儲存在userInfoDict後，會呼叫StringDataTransfer傳遞登入成功給前端。\nContext.ConnectionId 是 SignalR 套件中的一個屬性，用於取得目前連線的 Connection ID。\npublic async Task SendToConnection(string userID, string message) { if (userInfoDict.ContainsKey(userID)) { await Clients.Client(userInfoDict[userID]).StringDataTransfer(message); } } 模擬前端使用者傳訊息給另一使用者，藉由 userID，查詢userInfoDict是否有連線ID，若有則藉由StringDataTransfer傳遞字串。\n/// \u0026lt;summary\u0026gt; /// Automatically obtaining the connection ID /// \u0026lt;/summary\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public override Task OnConnectedAsync() { //string userId = Context.User.Identity.Name; string connectionId = Context.ConnectionId; return base.OnConnectedAsync(); } 此為SignalR內建的方法，若使用者連線，即可進入此方法。因模擬為使用者需先輸入userID，所以並沒有在這部分測試。\n/// \u0026lt;summary\u0026gt; /// Disconnecting and automatically removing the connection ID /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;exception\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; public override Task OnDisconnectedAsync(Exception exception) { string ID = Context.ConnectionId; string userID = string.Empty; if (userInfoDict.ContainsValue(ID)) { string key = userInfoDict.FirstOrDefault(x =\u0026gt; x.Value == ID).Key; userInfoDict.Remove(key); } return base.OnDisconnectedAsync(exception); } 此為SignalR內建的方法，若使用者離線，即可進入此方法，模擬使用者離線，即移除儲存在userInfoDict的連線資料。\n以上兩種內建方法，可以自行下中斷點測試。\nHub/MessageHub.cs 完整程式碼:\n1namespace SignalR_Example.Hub 2{ 3 public class MessageHub: Hub\u0026lt;IMessageHub\u0026gt; 4 { 5 public async Task sendToAllConnections(List\u0026lt;string\u0026gt; message) 6 { 7 await Clients.All.sendToAllConnections(message); 8 } 9 10 public static Dictionary\u0026lt;string, string\u0026gt; userInfoDict = new Dictionary\u0026lt;string, string\u0026gt;(); 11 public async Task LoadUserInfo(dynamic message) 12 { 13 dynamic dynParam = JsonConvert.DeserializeObject(Convert.ToString(message)); 14 string userID = dynParam.userId; 15 var ID = Context.ConnectionId; 16 userInfoDict[userID] = ID; 17 await Clients.Client(ID).StringDataTransfer(\u0026#34;Login successfully.\u0026#34;); 18 } 19 public async Task SendToConnection(string userID, string message) 20 { 21 if (userInfoDict.ContainsKey(userID)) 22 { 23 await Clients.Client(userInfoDict[userID]).StringDataTransfer(message); 24 } 25 } 26 27 /// \u0026lt;summary\u0026gt; 28 /// Automatically obtaining the connection ID 29 /// \u0026lt;/summary\u0026gt; 30 /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; 31 public override Task OnConnectedAsync() 32 { 33 //string userId = Context.User.Identity.Name; 34 string connectionId = Context.ConnectionId; 35 return base.OnConnectedAsync(); 36 } 37 38 /// \u0026lt;summary\u0026gt; 39 /// Disconnecting and automatically removing the connection ID 40 /// \u0026lt;/summary\u0026gt; 41 /// \u0026lt;param name=\u0026#34;exception\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; 42 /// \u0026lt;returns\u0026gt;\u0026lt;/returns\u0026gt; 43 public override Task OnDisconnectedAsync(Exception exception) 44 { 45 string ID = Context.ConnectionId; 46 string userID = string.Empty; 47 if (userInfoDict.ContainsValue(ID)) 48 { 49 string key = userInfoDict.FirstOrDefault(x =\u0026gt; x.Value == ID).Key; 50 userInfoDict.Remove(key); 51 } 52 return base.OnDisconnectedAsync(exception); 53 } 54 } 55} 在Controllers/MsgController.cs 新增一個對特定使用者傳資訊的API，模擬藉由API啟動即時通訊。\n1[HttpPost] 2[Route(\u0026#34;toUser\u0026#34;)] 3public string toUser([FromBody] JsonElement jobj) 4{ 5 var userID = jobj.GetProperty(\u0026#34;userID\u0026#34;).GetString(); 6 var Msg = jobj.GetProperty(\u0026#34;msg\u0026#34;).GetString(); 7 if (MessageHub.userInfoDict.ContainsKey(userID)) 8 { 9 messageHub.Clients.Client(MessageHub.userInfoDict[userID]).StringDataTransfer(Msg); 10 return \u0026#34;Msg sent successfully to user!\u0026#34;; 11 } 12 else return \u0026#34;Msg sent failed to user!\u0026#34;; 13 14} 前端程式碼 接下來，就是前端的畫面顯示，因為主要是測試連線的功能，前端所收到的訊息為了方便都會顯示在console上。\n1\u0026lt;!DOCTYPE html\u0026gt; 2\u0026lt;html\u0026gt; 3\u0026lt;head\u0026gt; 4 \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; 5 \u0026lt;title\u0026gt;SignalR TEST \u0026lt;/title\u0026gt; 6 \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/@microsoft/signalr@5.0.7/dist/browser/signalr.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 7 \u0026lt;script\u0026gt; 8 // 建立 SignalR Hub 連線 9 const hubConnection = new signalR.HubConnectionBuilder() 10 .withUrl(\u0026#34;https://localhost:7013/messageHub/\u0026#34;) 11 .build(); 12 13 hubConnection.start() 14 .then(() =\u0026gt; { 15 console.log(\u0026#34;Connection started\u0026#34;); 16 }); 17 18 19 20 // 使用者點擊Login按鈕時的處理函式 21 function onLoginClick() { 22 // 取得使用者輸入的使用者ID 23 const userId = document.getElementById(\u0026#34;userIdInput\u0026#34;).value; 24 25 // 將使用者ID包成 JSON 格式 26 const jsonData = { 27 \u0026#34;userId\u0026#34;: userId 28 }; 29 30 // 使用 SignalR Hub 的 LoadUserInfo 方法，將 JSON 資料傳送至後端 31 hubConnection.invoke(\u0026#34;LoadUserInfo\u0026#34;, jsonData) 32 .then(() =\u0026gt; { 33 console.log(\u0026#34;Data sent successfully!\u0026#34;); 34 }) 35 .catch((error) =\u0026gt; { 36 console.error(error); 37 }); 38 } 39 40 41 // 使用者點擊Send按鈕時的處理函式 42 function onSendClick() { 43 // 取得使用者輸入的使用者ID 44 const userId = document.getElementById(\u0026#34;msgUserIdInput\u0026#34;).value; 45 // 取得使用者輸入的訊息 46 const msg = document.getElementById(\u0026#34;msgInput\u0026#34;).value; 47 48 // 使用 SignalR Hub 的 SendToConnection 方法，將資料傳送至另一使用者 49 hubConnection.invoke(\u0026#34;SendToConnection\u0026#34;, userId, msg) 50 .then(() =\u0026gt; { 51 console.log(\u0026#34;Msg sent successfully!\u0026#34;); 52 }) 53 .catch((error) =\u0026gt; { 54 console.error(error); 55 }); 56 } 57 58 // 註冊 MessageHub 的事件 59 hubConnection.on(\u0026#34;sendToAllConnections\u0026#34;, function (msgs) { 60 console.log(\u0026#34;To All Connections:\u0026#34;, msgs); 61 }); 62 63 hubConnection.on(\u0026#34;StringDataTransfer\u0026#34;, (response) =\u0026gt; { 64 console.log(\u0026#34;Received Msg:\u0026#34;, response); 65 }); 66 67 68 \u0026lt;/script\u0026gt; 69\u0026lt;/head\u0026gt; 70\u0026lt;body\u0026gt; 71 SignalR TEST 72 \u0026lt;hr\u0026gt; 73 \u0026lt;label for=\u0026#34;userIdInput\u0026#34;\u0026gt;Please enter user ID：\u0026lt;/label\u0026gt; 74 \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;userIdInput\u0026#34;\u0026gt; 75 \u0026lt;button onclick=\u0026#34;onLoginClick()\u0026#34;\u0026gt;Login\u0026lt;/button\u0026gt; 76 \u0026lt;hr\u0026gt; 77 \u0026lt;label for=\u0026#34;msgUserIdInput\u0026#34;\u0026gt;User ID：\u0026lt;/label\u0026gt; 78 \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;msgUserIdInput\u0026#34;\u0026gt; 79 \u0026lt;label for=\u0026#34;msgInput\u0026#34;\u0026gt;msg:\u0026lt;/label\u0026gt; 80 \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;msgInput\u0026#34;\u0026gt; 81 \u0026lt;button onclick=\u0026#34;onSendClick()\u0026#34;\u0026gt;Send\u0026lt;/button\u0026gt; 82 83\u0026lt;/body\u0026gt; 84\u0026lt;/html\u0026gt; 測試結果 測試時，可以開啟多個網頁，在登入時使用不同的userID，過程中可以開啟中段點，查看執行的過程。\n使用者 B 登入，並傳訊息給使用者 A\r使用者 A 的介面，確認收到訊息\r以上為使用 Web API 簡單的實踐即時通訊功能方式。過程包含綁定使用者、連線ID 並儲存，且提供對特定使用者即時通訊的API。雖然前端畫面有點簡陋，但主要是為了解其中原理，我想應該是任何功能都可以實現了吧。\n專案已上傳至 Github。\n",
	  "pubDate": "2023-06-16T11:05:34+08:00",
	  "cover": "https://sunnote.xyz/img/thumbnail/034.webp"

	}, 
	{
	
		
	  "url": "http://sunnote.xyz/zh-tw/tutorials/aspnetcore-6.0-signalr-websocket-1/",
	  "title": ".NET 6 Web API 使用SignalR實作WebSocket技術實現即時通訊-1",
	  "summary": "\u003cp\u003e使用.NET 6 Web API 建立 WebSocket 通訊，本篇紀錄藉由簡易前端模擬全推播、群組推播、單一推播範例。\u003c/p\u003e",
	  "content": "使用.NET 6 Web API 建立 WebSocket 通訊，本篇紀錄藉由簡易前端模擬全推播、群組推播、單一推播範例。\n前言Foreword 公司的舊專案，若需要即時通訊功能，原本都是串接其他同仁已完成的 Flask-SocketIO，但我們組後端語言都是使用 C#，主管想要自己弄很久了，這次新專案就被指派要自己弄一個 C# 的 WebSocke 通訊。其實對平常只負責生 API 的我，要瞭解整個通訊的過程(包含前端)還蠻艱困的，所以就來記錄一下自己測試的過程。\n原理Principle WebSocket 是一種協議與平常前後端彼此串聯所使用的 API 不同之處在於它可以建立一個持久性的、雙向通訊的連接。而在傳統的 API 請求中，每次客戶端需要向伺服器獲取資料時，都需要發送一個 HTTP 請求，然後等待伺服器的回應。這樣的請求和回應是無狀態的，也就是說每次請求和回應之間都是相互獨立的。\nWebSocket 則可以在建立連接後一直保持通訊狀態，客戶端和伺服器可以直接互相傳送數據，而不需要重新建立連接。這樣可以大大減少通訊的開銷，提高通訊效率，並且可以支援一些即時性要求較高的應用場景，例如多人遊戲、聊天室、實時監控等。\nSignalR SignalR 是一個 ASP.NET Core 框架的庫，用於建立即時 Web 應用程序。SignalR 允許伺服器端代碼推送新資訊到與客戶端建立的 WebSocket 連線，這樣客戶端就可以即時地接收到這些資訊。而 ASP.NET Core 也是有 WebSocket 的庫，但根據微軟建議若要實現即時通訊可以選則 SignalR，因為 SignalR 在 WebSocket 連線的基礎上實現了許多進階功能，例如自動重新連線、分組傳送、廣播、序列化等等。透過 SignalR 可以更加輕鬆地建立高效的即時 Web 應用程序，並且減少開發的複雜性。所以這次的專案就選擇 SignalR 吧。\n測試 一開始被指派要弄出一個即時通訊功能時其實蠻頭大的，畢竟跟傳統資料傳送的模式不一樣。對於後端工程師，如果想要測試API，可以使用 swagger 來進行測試。但對於即時通訊，則需要測試連接、訊息傳遞、斷連，因為前端還蠻忙的，所以就只好自己來😗。\n測試除了連線與斷線，在訊息傳遞的部分，因為連線是都是連線到同一個伺服器的 Hub，(Hub 是一種抽象概念，它用來描述客戶端和伺服器之間的一個邏輯上的連線點)，通常同一種功能都是連線到同一個 Hub，所以對於互相傳送資訊，要從同個 Hub 傳到指定的客戶端就非常重要，傳錯訊息就尷尬了😂。\n接下來訊息傳遞會測試 全部傳遞、群組傳遞與指定傳遞。\n建立 Web API 專案 使用 Visual studio 點選 Create a new project \u0026gt; ASP.NET Core Web API \u0026gt; 取好專案名稱 \u0026gt; 選擇 .Net 6.0 \u0026gt; Create\n專案結構如下:\nSignalR-Example/\r├── Connected Services/\r├── Dependencies/\r├── Properties/\r│ ├── launchSettings.json\r├── Controllers/\r│ ├── WeatherForecastController.cs\r├── appsettings.json\r│ ├── appsettings.Development.json\r├── Program.cs\r├── WeatherForecast.cs 接下來要新增 SignalR 的庫 點選 Visual studio 上方 Tools \u0026gt; NuGet Package Manager \u0026gt; Manage NuGet Package for Solution\n下載 SignalR NuGet package\n建立 SignalR Hub 新增 Hub 資料夾 \u0026gt; 在 Hub 底下新增 IMessageHub.cs 介面 \u0026gt; 新增一個 sendToAllConnections 方法 用於傳送訊息給所有已經連線的使用者\n1namespace SignalR_Example.Hub 2{ 3 public interface IMessageHub 4 { 5 Task sendToAllConnections(List\u0026lt;string\u0026gt; message); 6 } 7} 在 Hub 資料夾底下新增 MessageHub.cs\n1using Microsoft.AspNetCore.SignalR; 2namespace SignalR_Example.Hub 3{ 4 public class MessageHub: Hub\u0026lt;IMessageHub\u0026gt; 5 { 6 public async Task sendToAllConnections(List\u0026lt;string\u0026gt; message) 7 { 8 await Clients.All.sendToAllConnections(message); 9 } 10 } 11} 接下來新增一個提供推播功能的 Controller， 選擇新增 API Controller - Empty : MsgController.cs\n1using Microsoft.AspNetCore.Http; 2using Microsoft.AspNetCore.Mvc; 3using Microsoft.AspNetCore.SignalR; 4using SignalR_Example.Hub; 5 6namespace SignalR_Example.Controllers 7{ 8 [Route(\u0026#34;api/[controller]\u0026#34;)] 9 [ApiController] 10 public class MsgController : ControllerBase 11 { 12 private IHubContext\u0026lt;MessageHub, IMessageHub\u0026gt; messageHub; 13 public MsgController(IHubContext\u0026lt;MessageHub, IMessageHub\u0026gt; _messageHub) 14 { 15 messageHub = _messageHub; 16 } 17 [HttpPost] 18 [Route(\u0026#34;toAll\u0026#34;)] 19 public string ToAll() 20 { 21 List\u0026lt;string\u0026gt; msgs = new List\u0026lt;string\u0026gt;(); 22 msgs.Add(\u0026#34;Don\u0026#39;t forget, the deadline for submitting your expense reports is this Friday.\u0026#34;); 23 msgs.Add(\u0026#34;Friendly reminder, please refrain from using the conference room for personal calls or meetings without prior approval.\u0026#34;); 24 messageHub.Clients.All.sendToAllConnections(msgs); 25 return \u0026#34;Msg sent successfully to all users!\u0026#34;; 26 } 27 } 28} 新增了一個 API 且注入 SignalR 包含的 IHubContext，提供發送消息給所有人的功能。\n為了方便確認前端是否有連接上 Hub 與後續測試訊息傳傳遞，需要在專案新增一個html頁面(還能直接避免CORS): 在專案底下新增 wwwroot，並在底下新增一個html檔。\nwwwroot 是 ASP.NET Core 中的一個特殊目錄，用於存放靜態資源文件，如 HTML、CSS、JavaScript、圖像等等。在 ASP.NET Core 應用程式中，使用者能夠直接從瀏覽器輸入 URL 訪問該目錄下的文件，因為這些文件可以直接從網頁請求中載入。\n新增 htmlpage.html，因為主要是實現後端功能，前端的訊息顯示一率顯示在console上。\n1\u0026lt;!DOCTYPE html\u0026gt; 2\u0026lt;html\u0026gt; 3\u0026lt;head\u0026gt; 4 \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; 5 \u0026lt;title\u0026gt;SignalR TEST \u0026lt;/title\u0026gt; 6 \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/@microsoft/signalr@5.0.7/dist/browser/signalr.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 7 \u0026lt;script\u0026gt; 8 // 建立 SignalR Hub 連線 9 const hubConnection = new signalR.HubConnectionBuilder() 10 .withUrl(\u0026#34;https://localhost:7013/messageHub/\u0026#34;) 11 .build(); 12 13 hubConnection.start() 14 .then(() =\u0026gt; { 15 console.log(\u0026#34;Connection started\u0026#34;); 16 }); 17 // 註冊 MessageHub 的 sendToAllConnections 事件 18 hubConnection.on(\u0026#34;sendToAllConnections\u0026#34;, function (msgs) { 19 console.log(msgs); 20 }); 21 \u0026lt;/script\u0026gt; 22\u0026lt;/head\u0026gt; 23\u0026lt;body\u0026gt; 24 SignalR TEST 25\u0026lt;/body\u0026gt; 26\u0026lt;/html\u0026gt; 接下來就是調整 SignalR 跟 CORS policy 還有讀取靜態資料在 Program.cs 的一些設定。\n加上註解的為新增的項目\n1using SignalR_Example.Hub; 2 3var builder = WebApplication.CreateBuilder(args); 4 5// Add services to the container. 6builder.Services.AddSignalR(); // 註冊 SignalR 服務 7 8builder.Services.AddCors(options =\u0026gt; // 註冊 CORS 服務，允許跨來源請求 9{ 10 options.AddPolicy(\u0026#34;CorsPolicy\u0026#34;, builder =\u0026gt; 11 { 12 builder.AllowAnyOrigin() 13 .AllowAnyHeader() 14 .AllowAnyMethod(); 15 }); 16}); 17builder.Services.AddControllers(); 18builder.Services.AddEndpointsApiExplorer(); 19builder.Services.AddSwaggerGen(); 20 21var app = builder.Build(); 22 23// Configure the HTTP request pipeline. 24if (app.Environment.IsDevelopment()) 25{ 26 app.UseSwagger(); 27 app.UseSwaggerUI(); 28} 29app.UseCors(\u0026#34;CORSPolicy\u0026#34;); // 使用上面定義的 CORS 策略 30app.UseHttpsRedirection(); 31 32app.UseAuthorization(); 33 34app.MapControllers(); 35app.UseFileServer(); // 使用內建的中介軟體提供靜態檔案 36app.MapHub\u0026lt;MessageHub\u0026gt;(\u0026#34;/messageHub\u0026#34;); // 映射 SignalR Hub 到 \u0026#34;/messageHub\u0026#34;(為前端的連線字串) 37app.Run(); 最終專案結構\r結果 啟動專案，開啟 swagger 與 https://localhost:7013/htmlpage.html，用來確認呼叫API時，前端是否有收到訊息。\n進入網站，就會跳出連線已成功。\r呼叫 toALL 後，就會顯示訊息，可以打開多個畫面確認都會收到訊息\r以上實作了對所有連線使用者傳遞訊息的功能。\nReference\nSignalR introduction and implementation using the.NET Core 6 Web API and Angular 14 下一篇將介紹如何針對特定使用者進行推播:\n.NET 6 Web API 使用SignalR實作WebSocket技術實現即時通訊-2\n",
	  "pubDate": "2023-06-15T16:08:13+08:00",
	  "cover": "https://sunnote.xyz/img/thumbnail/029.webp"

	}, 
	{
	
		
	  "url": "http://sunnote.xyz/zh-tw/tutorials/database-optimization-clustered-index-nonclustered-index/",
	  "title": "資料庫查詢性能優化技巧:索引概念、叢集、非叢集",
	  "summary": "\u003cp\u003e紀錄藉由索引優化查詢性能技巧方式，叢集與非叢集索引差異。\u003c/p\u003e",
	  "content": "紀錄藉由索引優化查詢性能技巧方式，叢集與非叢集索引差異。\n前言 當資料表中儲存了大量的資料，就算TSQL語法正確，在讀取寫入時會異常緩滿，這時侯就跟索引的設置有很大的關聯，甚至我覺得在一開始設計schema時，就該設置好對的索引，養成良好的習慣。\n索引 索引是一種數據結構，用於加速資料庫中的查詢操作。它通常是在資料表的一個或多個欄位上建立的，以便快速定位和檢索特定資料行或符合特定條件的資料。簡單來講就是用空間換時間，如果有設定好的索引，在查詢資料時，就能透過B-樹得結構快速查詢到所要的資料，而不是藉由掃描整個資料表來取得。\n點選資料表的索引即可看到有哪些索引。\r索引種類主要有 叢集索引（Clustered Index）、非叢集索引（Non-Clustered Index）、唯一索引（Unique Index）、主鍵索引（Primary Key Index）、聚集索引（Clustered Index）與 全文索引（Full-Text Index）。\n此篇主要討論:\n叢集索引（Clustered Index）：叢集索引決定了資料在資料庫中的物理排序方式。每個資料庫表只能有一個叢集索引，它決定了表的物理存儲順序。\n非叢集索引（Non-Clustered Index）：非叢集索引是建立在叢集索引之外的索引。它包含索引鍵和指向資料頁面的指標，用於快速定位資料，一個資料庫表可以有多個非叢集索引。\n幾個問題釐清 資料表的索引愈多愈好？ 雖然可能提升查詢效率，但佔用的磁碟空間也愈大，在資料表的異動也可能因此變慢。\nPRIMARY KEY 是何種索引？ 建立 PRIMARY KEY 時若無叢集索引，則會自動建立叢集索引，因此應該進一步評估是否合適。\nFOREIGN KEY 是何種索引？ 建立 FOREIGN KEY 時並不會建立任何索引，因此若是經常需要 JOIN，則應該建立索引。\nClustered Index 是 UNIQUE Index？ Clustered Index 不一定是 UNIQUE Index。\n索引選擇原則 索引選擇應該是選擇最常被查詢且重覆性較低(唯一性高)的欄位。\n建立叢集索引 1CREATE CLUSTERED INDEX IX_ClusteredIndexName 2ON YourTableName (ColumnName); 叢集索引會影響資料表實際儲存資料時的排序規則，適用於叢集索引的欄位包含:\nWhere 條件中會搜尋大量重複值的欄位, ex: where city=\u0026lsquo;台北\u0026rsquo; 經常使用 ORDER BY 的欄位 範圍查詢的欄位，ex: where [時間] between \u0026lsquo;20230101\u0026rsquo; and \u0026lsquo;20231231\u0026rsquo; 常用於連結子句中使用的欄位 在 SQL Server 中，建立主索引（Primary Key Index）時預設就是叢集索引。當你為資料表定義主索引時，如果沒有顯式指定索引的類型，SQL Server 將自動將主索引建立為叢集索引。\n若使用 GUID 當 Primary Key 會遇到因GUID具有不連續的隨機性，即使循序寫入資料，常常後寫的資料GUID排序較前，依叢集索引特性，實體儲存位置應擺在前段，造成每次寫入資料都需挪動調整既有資料造成索引破碎，拖累寫入與查詢效能，詳細資訊可以參考 GUID Primary Key資料庫避雷守則。\n建立非叢集索引 1CREATE INDEX index_name 2ON table_name (column_name); 一個以上的欄位建立複合索引\n1CREATE INDEX idx_column1_column2 2ON your_table (column1, column2); 非叢集索引不會影響資料表實際儲存資料時的排序規則。\n顯示估計執行計畫(Ctrl + L) 不管有沒有建立索引，在撰寫複雜TSQL時也能查看執行計畫，確認此查詢哪個部分耗掉大部分的查詢效能。\n點選此按鈕後每次的查詢就能看到執行計畫。\r之後在每次查詢結果中都可點選執行計畫查看。\r其實太複雜的查詢，我也不是看的很懂，還在研究中，但基本上就能明確清楚知道這次查詢是使用索引搜尋還是索引掃描。\n叢集索引搜尋（Clustered Index Seek）和叢集索引掃描（Clustered Index Scan） 叢集索引搜尋（Clustered Index Seek）： 使用叢集索引的搜尋是根據索引鍵值進行查找。搜尋操作是基於索引的 B-樹結構，通過快速定位到特定索引鍵值的節點，從而直接存取所需的資料頁面。叢集索引搜尋通常是一個高效的存取方式，尤其是當查詢的條件可以有效地使用索引鍵值進行過濾時。\n基本上有看到叢集索引搜尋就代表你建立的叢集索引有被此次查詢所使用，若此次查詢不符合叢集索引的鍵值排序順序，那麼資料庫引擎可能無法有效地使用叢集索引，而需要掃描整個資料表或使用其他索引（如非叢集索引）來執行查詢。\n叢集索引掃描（Clustered Index Scan）： 使用叢集索引的掃描是通過遍歷整個叢集索引來查找符合查詢條件的資料。 掃描操作需要遍歷整個索引結構，因此對於較大的資料表或包含大量資料的索引，可能需要較長的執行時間。 叢集索引掃描通常在以下情況下發生：查詢沒有有效的篩選條件、需要檢索整個資料表或索引覆蓋了查詢所需的所有欄位。\n總結來說，叢集索引搜尋是根據索引鍵值快速定位到特定資料，而叢集索引掃描是遍歷整個索引來查找符合條件的資料。搜尋操作通常更有效率，而掃描操作則需要較長的執行時間。若因為掃描操作耗掉大部分查詢時間則可能需要使用其他索引或重新設計索引策略來提高查詢效能。\n結語 索引設計應該是每個後端工程師必定會碰到的問題，雖然部分公司會有專業的資料庫管理師，但還是得好好研究，我也還在努力中，不然每次都在納悶自己code寫的那麼完美，怎麼還是那麼慢卻不知道其實是資料庫的問題🤣。\n",
	  "pubDate": "2023-06-13T13:21:06+08:00",
	  "cover": "https://sunnote.xyz/img/thumbnail/036.webp"

	}, 
	{
	
		
	  "url": "http://sunnote.xyz/zh-tw/cryptocurrency/exchange-recommendations-value-investing-insights/",
	  "title": "虛擬貨幣 交易所推薦 : 分享使用體驗、價值投資、分散風險觀念",
	  "summary": "\u003cp\u003e分享幾個自己使用過的虛擬貨幣交易所(幣安、Bybit、派網、OKX、Bitget)，與一些投資心得，避免新手踩坑。\u003c/p\u003e",
	  "content": "分享幾個自己使用過的虛擬貨幣交易所(幣安、Bybit、派網、OKX、Bitget)，與一些投資心得，避免新手踩坑。\n快速導覽\n➞ 交易所使用經驗與推薦\n➞ 台幣入金交易所推薦\n前言 算算進入幣圈也快兩年了，經歷了 ust 脫鉤與 FTX 破產(三分之一的資產消失😓)。身為軟體工程師的我還是對此產業的信仰保持不變，還是持續的使用交易所投資虛擬貨幣，此篇就對於自己所使用過的交易所體驗進行分享，闡述一些目前學習投資下的收穫與心得。\n投資概念 1. 價值投資: 投資與投機的差異\n先說明一下，本人是以價值投資為理念，而所謂的投資，我認為是對於一個產業、公司或是人，相信其的未來會有成長，而給予金錢上的支助，然後與其共生死。\n當然現實不會這麼笨笨的與其共生死，在投資項目快要完蛋、有風聲公司缺乏競爭力，或是大局勢不穩時，通常就會進行資金贖回的動作也就是套利(我所認為的投機)。 為了本身資產上的增加，投機是不可避免的。但是太多的投機，像是開槓桿、短線進出這種，我則是不建議使用(可以嘗試、小賭怡情哈哈)，畢竟我投資的目的是為了閒閒沒事做(我是這樣啦😂)，而不是多了一份工作或是以此為工作(Ex:上班偷看盤下班加班繼續看盤或是專業交易者)。\n2. 投資方法 : DCA (平均成本法)\n目前在虛擬貨幣領域，我就是一個無腦投資者，採取的方式是DCA，若不懂的可以自行搜尋，這邊並不做專業教學😎。如果與股市作比較，基本上就等於是存股了吧。但因為虛擬貨幣市場有週期循環的關係，所以在持續DCA的同時，還是得在高點做賣出進行套利(投機)，不能笨笨的與其共生死。\n3. 分散風險\n其實我也算是一個投資新手，一開始並不認為有什麼好需要分散風險的，年輕人總是信心滿滿，看中什麼項目就 All in，這是非常不對的，很多人都得等到吃到虧的時候才會開始學乖，所以投資建議在年輕時就開始，畢竟年輕時能虧的錢相對較少。用少少的錢學到寶貴的經驗，是非常好的，而不是一生一帆風順，但卻在65歲時不懂得分散風險的重要性，而導致退休金全部歸零。\n以當時FTX破產的例子，我就是因為稍微有點分散風險的概念，所以當時資產分三間交易所放，所以最終只損失3分之一。現在大概分五間存放加上冷錢包XD。\n冷錢包(硬體錢包) 目前虛擬貨幣最安全的存放方式就是冷錢包了，至於細節原理，也請自行搜尋。\n簡單來講，虛擬貨幣存在自己的冷錢包，才是真正屬於你的，存放在交易所，其實只是存在交易所自己的冷錢包裡，如果今天交易所要跑路，你是拿不回你的錢的。\n以現實世界為例子，錢存進銀行，其實也不完全是屬於你的錢，要領出來放在自己口袋才是，只是因為今天有政府給你擔保，保證你可以隨時贖回你的錢，才會讓你有種安全踏實感。但請仔細想想，為什麼政府肯給你擔保 ? 如果今天給你擔保，政府並沒有獲得好處(Ex:戰爭、破產)，你覺得你還能拿回你的錢嗎?\n但也因為從交易所轉進冷錢包時需要的轉帳費，有時候蠻高的，對於資產還是屬於小資族的我，並不會頻繁的把虛擬貨幣從冷錢包轉進交易所或轉出，反而是存在交易所賺取一些利息。(你也不會一直頻繁的扣提款手續費從銀行領錢吧?)\n但對於大鯨魚(有錢人)來說，因為資產已經大於轉帳手續費很多，並且一次買賣的收益遠大於利息與手續費，所以通常都是要進行買賣時，才會從冷錢包轉入交易所，買賣完就轉進冷錢包。\n有興趣可以點選冷錢包連結購買。 !!冷錢包務必透過官網購買、官網寄送，在第三方平台購買都會有資安的風險。\n點選以下網址購買我們都能各得到等值10美金的BTC。 Home of the first and only certified Hardware wallets\rLedger offers certified crypto asset hardware wallets bringing optimal protection level to your bitcoins, ethereums, XRP and more - without sacrificing usability or control.\nshop.ledger.com\r個人認為購買 LEDGER NANO S PLUS，這款基本款就行了，主要就是少了藍芽功能，該有的功能都有。\n交易所選擇方式 CoinMarketCap是一個全球知名的加密貨幣市場資訊平台，提供全面、準確的加密貨幣市場數據、價格、市值和交易量等資訊。它的網站讓用戶能夠追蹤各種加密貨幣的市場動態，查看價格趨勢圖、市值排名和交易對等數據。此外，CoinMarketCap還提供加密貨幣的詳細資訊頁面、新聞文章和教育資源，幫助用戶了解市場趨勢、技術規格和投資策略。\n所以通常在聽到一間交易所，或是新幣都可以先在CoinMarketCap - Top 加密貨幣現貨交易所上查詢是否有相關的資訊，而交易所的選擇則是藉由網站的現貨、衍生品交易量、借貸等給予交易所排名來評估。\n先說明一下我的選擇方式，基本上，就是要考量規模、交易量與年資，年資高代表經歷過時間歷練，交易量大才代表是家有在賺錢的公司。雖然規模大、交易量大與年資高也不代表絕對安全，畢竟錢還是放在別人那，但保持著一個概念，有賺錢的公司通常還是比較有制度、薪水能給的比較高、工程師技術就會比較好，大幅降低資安上的風險，這邊撇除 FTX 這種 CEO 自己亂搞的，還真的沒有什麼理由去選擇一家默默無名的小交易所。\n交易所使用心得與推薦 接下來，推薦幾家我目前都還在使用的交易所。\nBinance(幣安) 加密貨幣交易所推薦計畫｜幣安官方\r推薦好友，兩人皆可獲得 100USDT 手續費返現券。須遵循條款與條件。\nwww.binance.com\r幣安（Binance）是全球最大的加密貨幣交易平台，於2017年由趙長鵬創立。它提供一個集數字資產交易、投資和金融服務於一身的平台，旨在讓用戶可以方便地買賣和交換各種加密貨幣。\n現貨與衍伸品交易量目前都是排名第一，在 FTX 破產後也經歷了恐慌擠兌，證明真的是一間體質還不錯的公司。\n使用心得 :\n接觸幣圈後就開始使用的交易所，跟其它比起來介面操作都算順暢，提供的金融商品，質押活存利息操作都蠻易懂的，最近還提供了定投機器人與指數型投資相關商品，可以說在各方面都是走在業界最前端。來到幣圈，沒使用過幣安會被笑吧。🤣\nBybit https://www.bybit.com/invite?ref=WNMQMX\rBybit是一家全球知名的加密貨幣衍生品交易平台，成立於2018年。它專注於提供比特幣和其他加密貨幣的衍生品交易服務，包括永續合約（永續合約是一種無到期日的合約）和期貨合約。\n使用心得 :\n可以看的出來，Bybit就是一家以期貨合約交易起家的交易所，在CoinMarketCap的衍伸品排名有第三名。有玩期貨合約的前輩們都覺得交易介面與流暢度都還不錯，所以就算現貨排名不是那麼前面，衍伸品的交易量還是有一定水準的，因為個人有投資此平台贊助與推廣的BitDAO Bit幣(根據BitDAO推出模塊化以太坊Layer 2網絡Mantle，Bit即將更名為Mantle)，所以也在此平台質押Bit，撇除合約交易，個人認為現貨金融服務並不沒有像幣安與OKX一樣流暢，如果可以改善，應該是能吸引更多散戶加入，而不是都是些合約交易玩家。\nPionex(派網) Bitcoin Ethereum Auto buy low and sell high\rPionex is the best crypto trading bot currently available, 24/7 trading automatically in the cloud. Easy to use, powerful, and extremely safe. Trade your cryptocurrency now with Pionex trading robot, the automated crypto trading bot.\nwww.pionex.com\rPionex 提供了多種功能和工具，以滿足不同用戶的投資需求。平台提供直觀的用戶界面和易於操作的功能，使新手和有經驗的交易者都能夠輕鬆進行交易。Pionex 以安全性為首要考量，採用先進的安全技術和措施，保護用戶的資產和個人信息。此外，Pionex 還提供自動交易機器人，幫助用戶自動執行交易策略，增強交易效率。無論您是投資者還是交易者，Pionex 提供了一個全面且可靠的平台，讓您能夠參與全球數字資產市場並實現投資目標。\n使用心得 :\n派網算是量化交易交易所的始祖，提供各式各樣的量化交易機器人。適合沒有專業背景卻想要從事量化交易，還有想要避免情緒交易(因為恐慌而賣幣或追高)的風險的人。\n個人認為量化交易是一定能賺到錢的，畢竟如果把賺錢或輸錢，比喻成賭博，賭越多次勝率基本上會接近50%，如果能藉由一些指標判斷，長期下來只要勝率超過50%，就是賺錢。目前有在派網跟著開了一個 Haze 的 800格網格 ETH/BTC 幣幣天地單，再來看看到了牛市會賺多少。😎\nOKX(歐易) Register in OKX\rSign up and log in OKX App to claim a Mystery Box up to $10,000.\nwww.okx.com\rOKX 是一家全球領先的數字資產交易平台，成立於2017年，由OKCoin創辦的子公司運營。該平台提供全球範圍內的加密貨幣和數字資產交易服務，並在安全性、穩定性和創新性方面不斷努力。CEO Jay Hao 在推動OKX的發展方面發揮著重要作用。\n作為加密貨幣領域的重要參與者，OKX 提供全球範圍內多種加密貨幣的交易服務，並提供進階功能如合約交易和期權交易，讓用戶能夠實現更多的投資策略。OKX注重安全性，採用多重身份驗證和最新的安全技術，以保護用戶的資產和個人信息。無論是新手還是有經驗的交易者，OKX 提供了一個可信賴和便捷的平台來參與全球數字資產市場。\n使用心得 :\n看成立時間，就知道也是一間經歷歲月考驗的交易所，但我卻是在使用Binance、Bybit、Pionex後才嘗試使用，使用下來的心得是 OKX 是目前我認為操作介面最流暢的交易所，以工程還有UI/UX的角度真的是無可挑剔，所以最近也慢慢分配些資產在 OKX。\nBitget 我現在正在 Bitget 上交易，邀請您領取高達 5,005 USDT\r使用電話號碼或電子郵件建立帳戶。立即註冊全球最大的加密貨幣跟單交易平台 Bitget，即可賺取高達 5,005 U 的獎勵。\nhttps://www.bitget.com/zh-TW/referral/register?from=referral\u0026amp;clacCode=NNQX2LFB\rBitget 提供多種加密貨幣和數字資產的交易和衍生品交易服務。作為一家創新的區塊鏈金融平台，Bitget 提供了安全、高效和創新的交易環境，讓用戶能夠輕鬆參與全球數字資產市場。該平台支持多種加密貨幣的交易，並提供合約交易、期權交易和杠杆交易等進階工具，以滿足不同用戶的投資需求。Bitget 著重於用戶體驗，提供直觀且易於使用的界面，並不斷優化和改進其使用者界面和功能，以確保用戶能夠方便快捷地進行交易操作。\n使用心得 :\n算是最近崛起的新交易所，主打跟單系統:就是一種藉由複製專業交易者交易而可以無腦賺錢的功能，雖然我個人是不傾向把交易交給別人來做，但看著平台，對於跟單系統提供多種防範措施，還有獎勵處罰機制，認為多花點心思找到好的交易者並賺錢是可能的，但絕對不是無腦賺，風險控制能力還是非常重要。\n有時候花點小錢玩玩跟單或是自動交易機器人，我相信都是幣圈人會想嘗試的。目前也因為看上 Bitget 短短時間內，衍生品交易量就能到前五，相信淺力無窮，所以也投資的一點 Bitget 的平台幣 BGB 在平台質押賺取額外收益。\n台灣交易所推薦: 台幣入金管道 台灣目前入金最划算的方式，就是藉由註冊台灣本土的交易所，綁定銀行透過轉帳台幣，再藉由交易所的TWD/USDT交易對，兌換成USDT。因為交易池深度問題，一率都是把USDT轉至國外大型交易所進行買賣。並不會在本土交易所進行虛擬貨幣買賣。\n目前本土交易所有 MAX、ACE、幣託、Rybit\u0026hellip;等。這裡就介紹幾個目前有在使用且覺得還順手的。建議新手可以都一起註冊，當要購買USDT時可以查詢哪家交易所匯率較好，再選擇當下要透過哪一下購買。( !! 需注意USDT轉至國外交易所的轉帳費用，每間的優惠都不太相同。)\nMAX max.maicoin.com\rACE 台灣首家合法合規虛擬貨幣交易所\rACE 王牌虛擬貨幣交易所提供新台幣購買虛擬貨幣，例如比特幣（BTC）、以太幣（ETH）、USDT（泰達幣）等主流幣種，24小時隨時可以買賣，加上凱基銀行新台幣價金信託，安全有保障\nace.io\r使用心得 :\n沒什麼好說的，台幣入金必定得註冊，平常幾乎都使用 MAX 交易所入金，因為體驗上轉帳時速度 MAX 會比較快一點。\n結論 以上主要分享各個交易所的使用體驗，為什麼著重在體驗是因為就算交易所的介紹有多麼厲害多麼安全，但還是得申明對於以去中心化為發展主軸的虛擬貨幣。中心化就是危險，把資產放在交易所就是有風險，目前最安全的方法還是把自己的資產存放在冷錢包。\n有興趣可以點選冷錢包連結購買。 !!冷錢包務必透過官網購買、官網寄送，在第三方平台購買都會有資安的風險。\n點選以下網址購買我們都能各得到等值10美金的BTC。 Home of the first and only certified Hardware wallets\rLedger offers certified crypto asset hardware wallets bringing optimal protection level to your bitcoins, ethereums, XRP and more - without sacrificing usability or control.\nshop.ledger.com\r個人認為購買 LEDGER NANO S PLUS，這款基本款就行了，主要就是少了藍芽功能，該有的功能都有。\n但實際操作起來是沒辦法那麼的完美的，總是得在方便與安全做取捨，加上現在主流都會投資點平台幣(Ex: BNB、BGB、BIT\u0026hellip;)，這類平台幣基本上都是存放在各個平台的，畢竟是與平台共存亡的東西，放在交易所還多少能參與活動賺點錢，當交易所破產時就算提領出來也沒什麼用了。還有就是一般散戶也不太可能每次的買賣都負擔的起轉帳的手續費，都是買到一定量後再同時轉入冷錢包。所以交易所的選擇才會那麼重要。\n資產分散在各個你認為發展不錯的交易所，需長期囤放的幣種再轉進冷錢包，是我目前認為最可靠的方式。如果還真的有全部交易所一起倒閉的一天，那我也認了😎。\n上一輩靠房地產，這一輩大概就得靠虛擬貨幣，祝大家提早實現財富自由。\n",
	  "pubDate": "2023-05-29T14:17:01+08:00",
	  "cover": "https://sunnote.xyz/img/thumbnail/033.webp"

	}, 
	{
	
		
	  "url": "http://sunnote.xyz/zh-tw/hokkaido/sapporo-dormyinn-kanihonke/",
	  "title": "北海道-札幌遊記 Dormy Inn 住宿與螃蟹本家體驗",
	  "summary": "\u003cp\u003e北海道-札幌的遊記包含兩晚在 Dormy Inn 的住宿體驗、地下街閒晃、中島公園、大通公園、螃蟹本家嘗鮮與錯過的成吉思汗燒肉。\u003c/p\u003e",
	  "content": "北海道-札幌的遊記包含兩晚在 Dormy Inn 的住宿體驗、地下街閒晃、中島公園、大通公園、螃蟹本家嘗鮮與錯過的成吉思汗燒肉。\n前言 離開函館後，前往札幌，覺得來到這種大城市，主要就是逛街採購，與體驗當地餐廳、平常當地人行徑的區域，並沒有加入一些城市地標，觀景台的行程。因為這次行程緊湊，事前也沒有做太多的行程規劃，臨時詢問了一下之前語言班的日本朋友，來札幌有什麼必吃的，推薦成吉思汗烤羊肉，但之後因為沒預約就只好錯過了，逛了幾家餐廳也是覺得自己很傻，連台灣平常就有很多餐廳是沒預約就吃不到的情況，日本怎麼可能不用預約\u0026hellip;。\n還車、JR新千歲空港駅➞達札幌駅 首先一離開函館後先去原本租車的地方還車，位置距離千歲機場大約15分鐘。之後就是從新千歲機場到札幌，交通相當簡單，靠JR鐵路即可搞定，搭乘JR快速エアポート只要40分鐘即可到達札幌駅。 剛開始蠻少人的，但越接近札幌越多人。\n狸小路商店街 、Dormy Inn Sapporo ANNEX 住宿 到達札幌後，得先去住宿的地方辦理入住，這次選擇 Dormy Inn Sapporo ANNEX 位於狸小路商店街6丁目區內。地理位置便利，距離札幌車站僅約步行10分鐘的距離，附近也有公車和地鐵站，方便前往市內的各個景點和商業區。\n其實旅館除了溫泉這種必須得有的設施外，還提供了免費的冰棒與養樂多，冰棒口味都還蠻和我胃口的，但北海道五月初的氣溫也只有10度而已啊😂，養樂多就台灣就能喝到的那種，但日本的瓶身總是用日文寫著類似多種好菌的、培養之類的文字，特別讓人想嘗試哈哈。 旅館提供的養樂多\r早餐也是目前登別、函館住宿下來，覺得品質還蠻不錯的，非常推薦這個評價的旅館。\n早餐\r地下街閒晃、中島公園、大通公園 一早就隨著當地的人穿梭在地下街! 😎應該說路上的氣溫對南台灣的我來說真的太冷了😂，若想到某個地點，有地下街能走絕對選擇地下街。 摁大家都走蠻快的。\r中島公園\r中島公園\r大通公園\r建議各位可以上札幌電視塔可以觀賞整個大通公園\r此些景點，主要就是跟家人們，逛逛走走散散步，聊聊天。\n札幌螃蟹本家 接下來就是得嘗嘗當地有名的螃蟹本家，其實我對螃蟹並沒有很大的興趣，但因為我老哥非常愛，在被他同事推薦這家後 還特定提早訂位就是想來吃吃看。個人是覺得不管是裝飾還是建築的外觀，都顯得非常的氣派典雅，很有日式的風格。\n至於食材量的部分，我是覺得有點太少，我家老人一直在跟台南的海鮮餐廳做比較😂。 不過這邊可是日本人穿著和服幫你服務擺盤煮粥耶。我是蠻喜歡單純吃個氣氛的，但如果考慮到CP值的話可能就得參考一下真正會吃螃蟹的人的心得了哈哈，畢竟搞不好人家食材非常頂級，只是我吃不出來而已😎。\n北海道大學 吃飽飯特地來北海道大學走走，成立於1876年，是北海道地區歷史最悠久的大學之一，也是日本最早的七所帝國大學之一。去的時間點剛好是下午第一堂課的時間，看到很多騎腳踏車趕上課的大學生們。\n看著這種寒帶針葉林的景色，好奇北海道大學的學生會不會因為冬天太冷而翹課😂。 本來想試試看能不能跟著大學生一起吃他們的學餐，但最後還是選擇去吃其它好料的~\n錯過的成吉思汗（Genghis Khan）「さっぽろジンギスカン本店」 札幌成吉思汗是一家以羊肉燒烤聞名的餐廳。這家餐廳以呈現正宗的成吉思汗燒烤風味而受到廣泛歡迎。\n成吉思汗燒烤是一種以切成薄片的羊肉為主要食材的燒烤料理。在餐廳內，你可以坐在獨特的炭火爐前，享受親自烤製羊肉的樂趣。這種烹飪方式能夠保持肉質的嫩滑和口感，同時使調料完全融入肉中，讓味道更加豐富。\n這間算是我自己還蠻想嘗試的店，聽日本的朋友說還蠻有名的。在台灣我也沒有嘗試過以羊肉為主的燒肉店。可惜的是，人氣的店就是得預約，不然基本上都是沒位子的。唯一覺得不妥的，是當我進入此店時，很明顯抽油煙的設備沒有很好(不曉得是因為是總店比較老舊的關係還是怎樣)，導致燒烤的煙霧瀰漫，如果介意的話，則選擇別家比較好。 結語 來到札幌是這次旅行的最後一個行程，之後就得搭機返台。老實說，最好吃的還是飯店的供餐，或許是沒提前預約餐廳，導致沒嘗試到當地好吃的料理，但也有一種可能是，台灣的伙食真的把我養的太挑剔了😂。下次若還有機會來，還是得好好規劃行程，嘗試當地人平常就在吃的東西。體驗當地人的生活才是旅行。\n不得不說日本的保健食品真的好厲害，這一次買的腸胃藥。讓我回台後腸胃變好很多，之後真的有點閒錢要常駐日本了😎。\nReference\ndormy inn sapporo annex 札幌螃蟹本家 札幌成吉思汗（總店） ",
	  "pubDate": "2023-05-10T08:29:57+08:00",
	  "cover": "https://sunnote.xyz/img/thumbnail/032.webp"

	}, 
	{
	
		
	  "url": "http://sunnote.xyz/zh-tw/hokkaido/hakodate-attractions-lodging/",
	  "title": "北海道-函館景點推薦與萬總飯店(Hakodate Hotel Banso)評價",
	  "summary": "\u003cp\u003e推薦北海道-函館的景點，與萬總飯店的住宿體驗。\u003c/p\u003e",
	  "content": "推薦北海道-函館的景點，與萬總飯店的住宿體驗。\n前言 離開登別後，下一站就是前往函館，這是我第二次來到函館了，上一次體驗了函館朝市、函館山夜景，五稜郭塔、金森紅磚倉庫，都是不錯的景點，非常推薦第一次來到函館的人選擇這些景點。而這次則是因為行程緊湊，也只在函館住一晚，所以沒放多少個行程。主要就是待在旅館泡泡溫泉，去八幡坂散散步還有在附近的函館護國神社逛逛。\n八幡坂 八幡坂（Hachiman-zaka）是位於日本北海道函館市的一條古老街道，也是函館市的代表性觀光景點之一。這條坂道的名字來自於附近的八幡神社，被認為是函館的守護神。八幡坂的起點位於函館車站附近，坡度相當陡峭，沿著整條坡道一直向上延伸。沿途的街道兩旁種植著櫻花樹，每年春天，當櫻花盛開時，八幡坂成為了賞櫻的熱門景點，吸引了大量的遊客。 上次來是夜晚時，順面搭纜車上山欣賞夜景\r沿著八幡坂向上走，可以欣賞到函館市區的美景。在坡道上，有許多古老的建築和保存完好的歷史建築物，其中包括一些傳統的日本風格建築和西式建築，給人一種時光倒流的感覺。\n八幡坂的頂部是函館山的纜車站，遊客可以搭乘纜車前往山頂，欣賞到更壯麗的景色，包括函館市區、函館港和鄰近的山脈。白天來與夜間來的氣氛都不太相同。\n八幡坂街道\r函館護國神社 來八幡坂走走時，也能順便來函館護國神社 : 建於1879年，是為了祭祀戰死的日本士兵而建立的。該神社被認為是函館市的守護神社，也是當地居民和遊客參觀的重要景點之一。上次來時已經沒有什麼印象，這次來覺得有種異常陳舊年久失修的感覺， 鳥居\r鳥居存在於函館護國神社的入口，意味著進入該神社是與神靈相會的一種象徵性行為。它提醒著人們尊重和敬畏神聖，同時也代表著對於戰死士兵的敬意和紀念。此外，鳥居也是護國神社的辨識標誌之一，使其在函館市的城市景觀中顯得獨特而引人注目。遊客在見到紅色拱門時，會自然聯想到神社的存在，並對其產生興趣。\n此次到訪，對神社內並沒有太大的興趣，只是覺得鳥居的位置剛好分割神社內部與八幡坂，並有著長長的階梯，所以留個影。\n萬總飯店(Hotel Banso) 這次的住宿選擇萬總飯店，不管是溫泉、供餐、地理位置、價格，我都覺得非常完美。\n觀察很多日本人，一入住飯店，就會先選擇去泡澡，所以吃晚餐時，基本上都會穿著飯店提供的浴衣，剛來時還真的有點格格不入，因為我們都是穿便服來吃晚餐。 飯店的晚餐\r在日本飯店泡溫泉時，提供的衣服被稱為「浴衣」（Yukata）。浴衣是一種傳統的日本服裝，通常由輕質的棉質或麻質布料製成，非常適合在溫泉或夏季使用。\n浴衣通常是單色或花色的，具有寬鬆的袖子和袖口，並用帶子或腰帶（稱為「帶子」或「帶」）綁在腰部。穿上浴衣後，人們可以感受到舒適輕爽的感覺，同時也能體驗到日本的傳統風格。 浴衣不僅在日本的溫泉飯店中提供，也常見於夏季的祭典、旅遊景點和傳統活動中。許多人喜歡穿著浴衣參加活動或在温泉鄉漫步，以展現他們對於日本文化的喜愛。\n當入住日本的飯店並享受溫泉時，總會提供浴衣供使用。可以將其穿上，感受日本的溫泉文化，同時也能體驗到一種獨特的休閒和放鬆的氛圍。不過我到最後還是比較傾向要去泡溫泉時才穿上就是了。😂\n飯店的早餐\r總之，這次住宿體驗，真心覺得很不錯，若有要來函館旅遊的，可以考慮此間飯店。\n函館市熱帶植物園 位於湯之川溫泉區的熱帶植物園則是我私心喜歡的景點，主要就是展示一些熱帶植物，對於生活在台灣的我來說，其實見怪不怪了。植物園內還有一座溫室，提供了一個恆溫恆濕的環境，使得熱帶植物能夠在北海道的寒冷氣候中生長。溫室內的熱帶植物種類繁多，包括仙人掌、蘭花、熱帶雨林樹木等，讓遊客感受到如同身處於熱帶地區的氛圍。\n但這邊還有一個非常特殊的景色就是可以觀賞獼猴泡溫泉!!熱帶植物園飼養了很多日本獼猴。到了冬天飼育場的水池會注入溫泉，猴子宛如人類般舒服的浸泡在溫泉中的逗趣模樣，儼然成為冬季相當珍奇有趣的畫面之一。我來時已是五月初，還能觀賞到獼猴，當天氣逐漸變熱，就比較難看到此景象，若是為了觀賞獼猴泡溫泉的話，可以在冬季的時候前來。\n結語 這次來到函館算是個快閃的節奏，只住一晚其實並不太能好好到訪每個景點，個人建議至少得住個兩晚包含體驗朝市與欣賞函館山夜景，不過若是能選個好的溫泉旅館，純粹來這體驗高檔的海鮮也不錯。\nReference\n函館市熱帶植物園 Hotel Banso ",
	  "pubDate": "2023-05-07T08:29:57+08:00",
	  "cover": "https://sunnote.xyz/img/thumbnail/031.webp"

	}, 
	{
	
		
	  "url": "http://sunnote.xyz/zh-tw/hokkaido/noboribetsu-jigokudani/",
	  "title": "北海道自駕景點推薦 : 登別地獄谷、泉源公園、湯澤神社、閻魔堂",
	  "summary": "\u003cp\u003e介紹我非常喜歡的景點，以壯觀的火山地貌、噴泉、湯泉和硫磺氣味而聞名的-登別地獄谷。\u003c/p\u003e",
	  "content": "介紹我非常喜歡的景點，以壯觀的火山地貌、噴泉、湯泉和硫磺氣味而聞名的-登別地獄谷。\n前言 算算自己上一次去日本，大概是10年前了，平常如果有時間旅行，是不太會想要去日本的，因為覺得離台灣太近了，再老都還能去，所以總是想跑遠一點的地方。這一次家族旅遊，因為考量到大家的時間與喜好，決定來個北海道自駕旅行，上一次去日本也是去北海道的說\u0026hellip;。\n行程規劃 這一次行程規劃因考量到時間、異地還車費用、還有個人喜好，以新千歲機場為起點，租車後就直達 登別市(一晚) ➞ 函館市(一晚) ➞ 再返回新千歲機場還車後，在札幌住個兩日才回台。其實我覺得行程還蠻緊湊的，喜歡漫遊的或是踩點可以規劃多一點時間，畢竟這個行程大部份時間都是在開車，但我們的目的也就只是家人聚聚，避免搭乘交通運輸工具讓老人家太勞累還有看看風景。\n抵達新千歲機場 ➞ 租車 抵達機場後，就可以藉由指引找到租借車子的地方，或許是疫情還是人力精簡的關係，每個櫃台前都沒人只有放個電話讓你能聯繫實際負責的人。\n我們有事前預訂，原本是以為可以直接在機場取車，沒想到需等15分鐘，讓租車行的人來機場載我們去租車行取車。\n取完車後包含一系列的事前檢查後就可以上路了，接下來就要直接前往登別市。\n嗯~北海道第一次自駕開始\r住宿 登別萬世閣 剛抵達時，已經是晚上了，先入住飯店，吃完晚餐泡個湯，明天再去好好逛逛。\n登別溫泉街\r關於登別的景點，因為我一直最想看的就是登別的地獄谷，所以就選擇直接住宿在地獄谷的附近，這裡基本上算是個度假村，行程就是來這泡泡湯，再去地獄谷踏踏青，還可以逛逛登別溫泉溫泉街，買些伴手禮，完美。 很酷的房間鑰匙\r自助式早餐算還可以\r閻魔堂 在溫泉街的路途，可以看到閻魔堂:專門供奉閻魔大王的神社或神殿。閻魔大王在日本佛教和神道信仰中被視為地獄的統治者和審判者。他被認為負責判斷人們在死後的業報和輪迴，以及監督和管理地獄的運作。閻魔堂代表著人們對地獄、死亡和業報的信仰和敬畏，以及對閻魔大王的虔誠崇拜。在台灣好像沒有這種廟吧。😂\n閻魔堂在特定時間會進行換臉的表演。\n時間:10:00、13:00、15:00、17:00、20:00、21:00\n泉源公園 在前往登別地獄谷的方向，會經過在溫泉街中心泉源公園，雖說是公園，但還是蠻特別的，公園內可以看到熱水噴湧而出的景象。是1996年為紀念溫泉開業150週年，耗資約8000萬日元在“登別天堂酒店”舊址上建成的，也被稱為登別溫泉的發源地。 公園內有一個間歇泉，網路查說每3小時就會噴出約80度的溫泉，最高可達8m。溫泉持續噴發約50分鐘。50分鐘內湧出約2,000升的溫泉，只有在登別市才能體驗到。但因為行程比較緊湊所以就繼續往地獄谷走了，即使不噴出溫泉，間歇泉也有白色的蒸汽搖曳，令人印象深刻。 湯澤神社 泉源公園的附近就能看到湯澤神社路口，不過因為需要爬好多階梯，所以放棄。😂\n偶然路過的湯澤神社路口\r接下來繼續前進，可以看到地獄谷入口招牌，認真覺得日本的鬼怪都蠻可愛的。 登別地獄谷 登別地獄谷是一個火山的溫泉地區，以其獨特的地熱景觀和湧泉而聞名。這裡的地貌和溫泉活動給人一種神秘而火熱的感覺，與地獄的形象相符。\n可以看到告示說明越來越近了!!\r這個招牌應該是在開玩笑!?\r結語 其實整個地獄谷應該是可以花半天以上，如果走到更深入一點的地方還有湯之花地獄、三途の川、、七竈廣、大湯沼等景點，基本上就是包含在整個地獄谷徒步可到達的區域，但也因為時間有限，加上穿的保暖衣物不夠多，不想在外面待太久，就回程了。😂\n第一次來北海道的人可能不會來這裡。畢竟距離新千歲機場很遠，如果是第一次來的話，只能逛逛札幌、小樽、函館等著名景點。但我還是非常推薦登別的這些行程應該說這次來北海道主要就是想來這裡看看，時間多一點的話可以待個兩晚，一天分配給地獄谷與溫泉街，並且好好享受這邊的天然溫泉。\n在前往登別溫泉區時，遇到的野生狐狸，應該是狐狸吧!?😎 Reference\n閻魔堂（Enmado） - 登別国際観光コンベンション協会 ",
	  "pubDate": "2023-05-06T19:02:59+08:00",
	  "cover": "https://sunnote.xyz/img/thumbnail/030.webp"

	}, 
	{
	
		
	  "url": "http://sunnote.xyz/zh-tw/taiwan/kenting-caesarpark/",
	  "title": "墾丁凱薩大飯店住宿體驗-墾丁大街、景點、酒吧",
	  "summary": "\u003cp\u003e墾丁大街、知名景點、酒吧，一趟旅程放鬆身心靈，體驗豪華住宿的心得感想。\u003c/p\u003e",
	  "content": "墾丁大街、知名景點、酒吧，一趟旅程放鬆身心靈，體驗豪華住宿的心得感想。\n前言 這次連假被抓去跟女朋友的大家庭一起出遊，目的地為墾丁，主要是慶祝遠在澳洲的大哥帶著老婆Sophie第一次來台灣，讓他們體驗一下南台灣的知名度假勝地。悲慘的是，剛好腸胃炎的我真的是整個旅程都戰戰兢兢的。風景也沒好好拍，小吃也沒吃多少，酒也喝個一兩口。不過墾丁對於台灣南部人的我來說，還是蠻新奇的畢竟平常覺得地理位置蠻近的，所以壓根就有點懶得去導致好像沒什麼印象有去過😂，就來記錄一下第一次的墾丁度假體驗。\n墾丁凱薩大飯店 中午吃過飯後，就是開車直達墾丁凱薩大飯店，女朋友她爸幫我們訂的房型是池畔花園客房，摁 ~ 嫵媚花影樹語　南洋峇里風情。\n其實是四人房，我只拍了一半\r走出落地窗外為泡溫泉的地方\r很酷的是房間的外圍還能直接連到戶外的椰林泳池。\n泡完湯還能出去游泳\r二樓的景色，可以看到整個椰林泳池。\r光整個凱薩大飯店，應該就能玩很久，根本不需要其他的景點了。 🤣\n墾丁大街-晚餐 基本上，來墾丁晚餐應該就是都會在這解決。\n就蠻類似一般台灣的夜市，但好像賣的東西跟我家附近的夜市很不一樣🤔\r小灣酒吧 吃完晚餐就跑來這續攤，這時其實我已經蠻累的，所以照片就真的隨便拍拍。景色跟氣氛真的是很不錯啦，不管是白天或是晚上都可以來這坐坐。\n十點多來時人還是很多，所以我看有部分人則是直接坐在沙灘上。有點想嘗試直接在海灘上喝到掛然後睡到明天，但腸胃真的不允許🥴。\n酒吧營業到十一點，回去後很累了，直接洗洗倒頭就睡了。\n難得住那麼頂的飯店，覺得不應該在外待那麼晚，都還沒泡到湯呢~\n飯店自助式早餐 早上起床吃著飯店的自助式早餐，菜色就是台灣頂級飯店的那樣就不拍了。用餐環境空間很大，所以不會覺得擁擠，但不知道是不是因為起床得太晚😅。接下來就是把湯泡一泡，十一點準時退房。\n邊吃可以邊看一下整個飯店內圍的景色\r日日海霧 因為大哥還得趕回台北，所以下午行程就簡單一點，選擇一個可以拍個照，吃點冰的日日海霧，然後就得直達高鐵站了。\n來個悠閒的盪鞦韆\r結語 很久沒來墾丁了，或是其實是完全沒來過，我也不清楚😎。以防又忘記，所以就紀錄一下。體驗了頂級的飯店，沙灘、溫泉、美景，如果選擇了凱薩飯店，行程應該是可以安排少一點，畢竟館內設施也是得花時間好好使用，來到台灣的最南端，不像在都市裡生活，得好好體驗一下緩慢的步調。下一次一定得坐在沙灘上好好喝個酒。\n",
	  "pubDate": "2023-04-30T08:56:07+08:00",
	  "cover": "https://sunnote.xyz/img/thumbnail/028kenting.caesarpark_view.webp"

	}, 
	{
	
		
	  "url": "http://sunnote.xyz/zh-tw/tutorials/mongodb-atlas-compass-tips/",
	  "title": "MongoDB Atlas 資料庫基礎觀念、操作流程與使用 Compass 連線",
	  "summary": "\u003cp\u003e紀錄學習MongoDB Atlas過程幾個重點觀念與詳細連線操作教學。\u003c/p\u003e",
	  "content": "紀錄學習MongoDB Atlas過程幾個重點觀念與詳細連線操作教學。\n1. 前言 平常使用慣了RDBMS(關聯式資料庫)，但因為在做個人專案時，若要部署上線資料庫的花費總是不小，偶然發現了MongoDB的雲端服務Atlas竟然有提供免費的學習版，所以來學習使用一下這種屬於document database，NoSQL（Not Only SQL）的資料庫 MongoDB。\n以下是官方介紹\nMongoDB Atlas 是 MongoDB 官方提供的全托管雲資料庫服務，它提供了一個簡單、安全和可靠的方式來運行 MongoDB，無需進行任何基礎架構的配置和管理。MongoDB Atlas 運行在 AWS、Azure 和 Google Cloud 等雲平台上，讓用戶可以輕鬆地在全球範圍內運行、擴展和管理 MongoDB。它提供了自動化的部署和管理，包括備份和恢復、監控、性能優化、安全性等。使用 MongoDB Atlas，您可以輕鬆地配置、部署和管理 MongoDB 集群，並使用它提供的各種工具和服務來簡化 MongoDB 開發和運營。例如，它提供了一個簡單易用的管理控制台，讓您可以輕鬆地管理您的 MongoDB 集群、用戶和權限。此外，MongoDB Atlas 還提供了一些高級功能，例如全文搜索、圖形搜索、視圖、聚合管道等。這些功能可以幫助您更輕鬆地處理海量數據和複雜查詢。\n2. NoSQL 使用時機 MongoDB設計目的是處理大量非結構化數據，上網找到了一些適合使用MongoDB的情況。\n非結構化數據：如果今天需要儲存的資料格式有著不確定性，就可以選擇，例如日誌、多媒體、網頁內容、社交媒體數據等。 可擴展性：MongoDB可以輕鬆擴展，通過添加新的節點或分片，以處理更多的數據。 高性能：MongoDB是一個高性能的資料庫，它可以處理高速的讀寫操作，通常比關聯式資料庫更快。 靈活的數據模型：MongoDB的文檔數據模型非常靈活，可以根據應用程序的需要進行更改，而不需要改變整個資料庫的結構。 目前所理解的，如果在資料上不確定資料結構，或是想保留擴充性，之後預期不太會需要使用join各種表，且需要較快的讀寫操作，就可以考慮使用NoSQL類型的資料庫。\n3. Atlas 註冊 因為是直接使用雲服務的資料庫，過程很簡單，從官網 MongoDB，直接註冊帳號後，在產品的地方選擇Atlas，照著步驟建立基本資料、連線權限就能直接使用。\n4. 權限管理 在 MongoDB Atlas 中，可以建立多個組織（Organization），每個組織下可以建立多個專案（Project），每個專案下可以建立多個集群（Cluster）。以下是它們之間的差異：\n組織（Organization）：組織是 MongoDB Atlas 中的最高級別。您可以使用一個電子郵件地址註冊並建立一個組織，並在該組織中邀請其他使用者加入。您可以將不同的專案分配給不同的團隊或使用者，管理組織中的所有資源和設定。\n專案（Project）：專案是一個或多個 MongoDB 集群的集合。在專案中，您可以設定相關的安全性、監控和自動化功能，也可以設定存取權限和通知規則等。一個專案可以被一個團隊或一個使用者所擁有和管理。\n集群（Cluster）：集群是 MongoDB 的實例，它是由一組 MongoDB 伺服器組成的分佈式系統。每個集群都有自己的存儲空間、計算資源和設定，並由 MongoDB Atlas 提供管理和監控。您可以在每個集群中設定各種選項，例如可用區域、資料庫版本、存儲引擎和安全設定等。\n簡單來說，就是由這三個層級，由上到下去管理規範每個資料庫的使用權限。\n5. 資料庫操作 我的話習慣使用GUI來操作資料庫，MongoDB也有提供GUI供使用者操作資料庫，可以去 MongoDB Compass Download (GUI) 在Tools的地方，選擇下載MongoDB Compass。 安裝好後，執行會出現提示要求你輸入用於連線資料庫的字串。連線字串可以在Atlas的Cluster管理畫面上右側有個connect，點選就能找到各種的連線方式。\n因為是使用Compass 連線，所以就點選Compass，畫面就會出現對於Compass的連線字串。\nmongodb+srv://\u0026lt;user\u0026gt;:\u0026lt;password\u0026gt;@cluster0.swvkd15.mongodb.net/test \u0026lt;user\u0026gt; \u0026lt;password\u0026gt;就是當初建立Cluster時建立的帳號與密碼。\n再複製連線字串並修改\u0026lt;user\u0026gt; \u0026lt;password\u0026gt;後，記得要在Network Access的地方設定可以連線的IP位置， 設定好後，在 MongoDB Compass 貼上連線字串後就能連線成功了。\n6. 資料庫結構 在 MongoDB 中，資料是以文件（document）的形式儲存的。一個集合（collection）則是一個文件的集合。換句話說，一個 MongoDB 資料庫可以包含多個集合，而每個集合裡面包含多個文件。\n與關聯式資料庫比較，我覺得是這種感覺 :\nMySQL MongoDB database database table collection per row document 每一行資料就是一個文件。和關聯式資料庫不同的是，MongoDB 的文件可以包含非常彈性的結構和內容，而且不需要先定義欄位。\n簡單來說，集合是存儲文件的地方，而文件則是實際存儲資料的容器。如果把 MongoDB 視為一個文件數據庫系統，那麼集合就是這個系統中的表格，而文件就是這個表格中的行。\n7. 結語 大致瞭解了 MongoDB 的數據結構，與如何連線至 Atlas 的雲資料庫，接下來要學習如何使用node.js進行 MongoDB 的讀寫操作。\n",
	  "pubDate": "2023-04-24T15:33:44+08:00",
	  "cover": "https://sunnote.xyz/img/thumbnail/026.webp"

	}, 
	{
	
		
	  "url": "http://sunnote.xyz/zh-tw/tutorials/database-optimization-index-tips/",
	  "title": "資料庫查詢性能優化技巧 : 語句優化、添加索引",
	  "summary": "\u003cp\u003e當系統資料量日益龐大常會遇到資料庫查詢時間過久的情況，此篇提供資料庫查詢性能優化的幾個方法。\u003c/p\u003e",
	  "content": "當系統資料量日益龐大常會遇到資料庫查詢時間過久的情況，此篇提供資料庫查詢性能優化的幾個方法。\n主要紀錄自己所使用過的幾個技巧包含優化查詢語句、優化索引、減少資料庫中的資料量。\n1. 優化查詢語句 以下提供幾個平常在撰寫SQL就需注意的小技巧\nselect 查詢避免使用 *\n效能：SELECT * 會查詢整個表格中的所有欄位，包括不需要的欄位。這會增加資料庫的工作負載，降低查詢效率。而只查詢需要的欄位可以減少查詢的資料量，提高查詢效率。\n可讀性：SELECT * 不清楚地表明查詢的欄位，這可能會使程式碼難以理解和維護。而明確指定需要的欄位可以使程式碼更加清晰和易於理解。\n衝突：如果表格中有相同名稱的欄位，使用 SELECT * 可能會導致衝突，例如使用 JOIN 時。而使用明確指定欄位名稱的方式可以避免此類問題的發生。\n避免在 where 子句中使用!=或\u0026lt;\u0026gt;\n使用此語句等於是需要查詢整個資料表，導致效能下降。\n避免在 where 子句中使用 or 連接\nOR操作符也是需要搜尋整個資料表，以查找符合任一條件的資料導致效能下降。可以藉由union all先分別取得兩個條件的資料再組合。\n避免在 where 子句中進行表達式與函數操作\nEx:\nselect name from table where age-10 = 20 基本上這種寫法，會先對整個table的age-10再去比對是否等於20，所以應該改為\nselect name from table where age = 30 當然這個例子比較極端一點，正常都不會這樣寫，主要重點就是，盡量避免在等號左側使用表達式或函數修改欄位資料，而是在右側修改。\n2. 添加索引 索引（Index）是資料庫管理系統中用於加速數據查詢的一種數據結構。索引透過對欄位或欄位組進行排序，創建一個數據結構來加快查詢和排序的速度。在資料庫中，索引可視為一個指向實際數據的指針或地址。\n簡單來說若針對特定欄位添加索引(Ex: 此欄位有A、B、C、D\u0026hellip;等資料)，可以在查詢欄位 = B的相關資料時，迅速找到B相關資料的區塊組再比對資料，而不用把A、B、C、D都全部查詢一遍，增加查詢速度。\n● 建議加上索引的情況 索引可以創建在單個欄位或多個欄位上，以下提供可以加上索引的情況：\n主鍵和外鍵欄位：主鍵和外鍵欄位是資料表中最重要的欄位之一，它們通常會被用作查詢和關聯表格時的連結條件。在這些欄位上建立索引，可以讓查詢和關聯操作更快速。\n經常被查詢的欄位：如果某個欄位被頻繁地作為查詢條件使用，那麼建立索引可以大幅提升查詢效率。\n!!需注意唯一性與分布的問題\nEx : 性別就不太適合當作索引，因為性別欄位只有兩個值，男和女，不具唯一性，因此無法作為唯一鍵或主鍵欄位，建立索引也無法加速查詢。而性別在欄位中的值分布也相對均勻，並不會造成大量資料集中在某個特定值上，因此不建立索引對查詢效率的影響較小。\n組合查詢條件欄位：當多個欄位一起作為查詢條件使用時，可以建立複合索引。複合索引可以讓資料庫系統更快地定位符合多個條件的資料。\n用於排序的欄位：如果某個欄位經常被用來進行排序，那麼建立索引可以大幅提升排序操作的效率。\n用於分組的欄位：如果某個欄位經常被用來進行分組，那麼建立索引可以大幅提升分組操作的效率。\n● 注意事項 雖然看似很多情況都可以增加索引，但不是索引越多越好，過多的索引反而會增加查詢的複雜度進而導致效率降低，這裡也就只能藉由經驗去判斷實際該加上索引的情況了。\n索引雖然可以加快查詢速度，但實際上它是以空間換取時間。以上方欄位有A、B、C、D\u0026hellip;等資料的例子，如果對於此欄位添加索引，等於是額外又會有A、B、C、D\u0026hellip;等部分的資料表存放於資料庫以供加速查詢，所以本身的伺服器硬體環境是否能負荷也需要考量。\n3. 減少資料庫中的資料量 目前經查詢減少資料量，主要做法就是正規化、壓縮資料庫、刪除資料。\n正規化:是指在資料庫設計中的一個過程，通過將資料分割成更小的、相關性更強的部分，來減少資料重複性，提高資料庫的效率和靈活性。\n壓縮資料庫: 壓縮檔案也是一門學問，效能增加與否取決於壓縮方式和壓縮率。一般來說，如果壓縮率很高，則需要更長的時間來解壓縮數據，這可能會導致查詢變慢。如果壓縮率較低，則可以減少磁盤I/O操作，提高查詢性能。這部分得有請專業DBA協助~。\n刪除資料:視情況刪除多餘或重複資料。\n刪除資料這部分我則是覺得應該在初始就需要多注意的地方，一開始schema的設計與該存取怎樣的資料，都需先考慮清楚，而不是等資料量大起來後，才再考慮如何刪除資料。(當然若有系統合併的需求那就沒辦法)\n以上就是目前有實際操作過的技巧，其他的就等嘗試過了再補充。😎\n",
	  "pubDate": "2023-03-29T09:38:14+08:00",
	  "cover": "https://sunnote.xyz/img/thumbnail/025.webp"

	}, 
	{
	
		
	  "url": "http://sunnote.xyz/zh-tw/tutorials/dark-mode-tips-hugo/",
	  "title": "黑暗模式(dark mode)設計與Hugo實作",
	  "summary": "\u003cp\u003e紀錄一下網站增加黑暗模式功能踩到的一些坑、一些前端顯示的細節還有在Hugo上實作。\u003c/p\u003e",
	  "content": "紀錄一下網站增加黑暗模式功能踩到的一些坑、一些前端顯示的細節還有在Hugo上實作。\n前言 黑暗明亮模式轉換，應該是現在不管是網頁還是App都必備的功能，平常在使用一些手機App，若沒有能讓我選擇轉換的地方，心理不免納悶這團隊也太不人性化了吧。自從開始經營網站後，很不幸的，內建的主題沒有支援此功能，所以只好自己弄一個。原本的理解很簡單，就是多一份dark mode專屬的css，藉由轉換每個css的class進而轉換畫面使用的css達到修改成dark mode的目的。\n畫面能成功轉換成黑暗模式，但遇到的問題是在頁面跳轉時會出現短暫的白色閃爍。經歷各種的嘗試發現改為使用prefers-color-scheme: dark的方式就能解決此問題。\n原理 主要原理就是藉由CSS prefers-color-scheme 媒體查詢和 JavaScript 來監聽操作系統或瀏覽器的顏色模式設置，並在頁面上動態地添加或刪除 dark-mode 類。這意味著在頁面跳轉時，頁面不會立即切換到預設的亮色模式或黑暗模式，而是保持當前的顏色模式狀態，從而避免了短暫的白色閃爍。\n轉換模式按鈕 首先要先設一個可以點選轉換模式的按鈕，樣式可以自己選擇，這裡我是選擇用Unicode對應的太陽與月亮的符號來充當按鈕的樣子。\n位置可以放在根目錄\\themes\\Mainroad\\layouts\\baseof.html\n1\u0026lt;span class=\u0026#34;sun-btn\u0026#34;\u0026gt;\u0026amp;#x2600;\u0026lt;/span\u0026gt; 2\u0026lt;span class=\u0026#34;moon-btn\u0026#34;\u0026gt;\u0026amp;#x263D;\u0026lt;/span\u0026gt; 然後在style.css增加按鈕的樣式與黑暗模式的樣式。\nCSS variable 應用 CSS的部分因為不同網站的配置都不相同還是需要自己去設置對應的黑暗模式配色，為了更好的控管CSS，可以使用CSS variable(CSS 自訂屬性)，是一種在 CSS 中定義和使用的值，可以在整個文件中重複使用。它們以雙減號（\u0026ndash;）為前綴加上變數名稱來命名。\n範例:\n1:root { 2 --main-color: #ff0000; 3} 4 5h1 { 6 color: var(--main-color); 7} 在 :root 偽類中定義了一個名為 --main-color 的CSS變數，並將其設置為紅色。然後，在h1元素中，使用var()函數來引用這個變數，將其值應用於 color 屬性。\nCSS 變數的優點之一是它們可以在不同的元素和選擇器之間共享，並且可以通過 JavaScript 動態更改它們的值。這使得 CSS 變數成為一種非常強大和靈活的工具，可以用於實現動態和可維護的樣式表。\n以下是我的主題使用的CSS，為了方便管理，與增加黑暗模式的樣式，先新增:root 偽類中定義各個CSS variable，然後把整個css.style裡有用到的都先替換成這些CSS變數，這樣就可以透過在dark mode類直接修改變數值達到統一轉換的效果。\n1:root { 2\t--bodyBG: #f7f7f7; 3\t--wrapperBG:#ffffff; 4\t--wrapperBG2:#f5f5f5; 5\t--text-color: #000000; 6\t--codeBG:#f6f8fa; 7 } 然後對明暗轉換的按鈕客製化一下樣式\n1/* Light Mode */ 2.sun-btn { 3\tdisplay: block; 4\tfont-size: 2rem; 5\tcolor: #ffc533; 6 } 7 8.moon-btn { 9\tdisplay: none; 10 } 11/* Dark Mode */ 12 .dark-mode .sun-btn{ 13\tdisplay: none; 14 } 15 16 .dark-mode .moon-btn { 17\tdisplay: block; 18\tfont-size: 2rem; 19\tcolor: #fff9be; 20 } 21 以下則是黑暗模式下的CSS，可以看到實際要改的其實不多，因為都用CSS variable取代了。\n1 /*dark-mode styles*/ 2.dark-mode { 3\t--bodyBG:#2b2b2b; 4\t--wrapperBG: #212121; 5\t--wrapperBG2: #212121; 6\t--text-color: #C5C5C5; 7\t--codeBG:#424242; 8\tbox-shadow: none; 9 } 10.dark-mode span.nav-indicator{ 11\tbackground-color: #ACD6FF !important; 12 } 13.dark-mode li{ 14\tcolor: var(--text-color); 15 } 降低白底亮度 如果網頁上會放一些影音或是圖片，若是白底的可能會在黑暗模式下異常刺眼，可以使用此屬性降低在黑暗模式下的亮度。\n1.dark-mode iframe, 2.dark-mode img, 3.dark-mode video { 4 filter: brightness(0.9); 5} 按鈕監聽、localStorage存放用戶偏好模式 接下來就是使用JS實現以下功能。\n位置放在根目錄\\themes\\Mainroad\\layouts\\baseof.html\n當頁面加載時，檢查 localStorage 中是否存在 \u0026ldquo;dark-mode\u0026rdquo; 設置。如果存在，則根據設置狀態啟用或禁用深色模式。 監聽系統設置是否切換到深色模式（通過 window.matchMedia 創建 MediaQueryList 對象來實現）。 當用戶點擊「太陽」或「月亮」按鈕時，切換深色模式的狀態，並同時更新 localStorage 的值。 1let darkModeState = false; 2 3const sun = document.querySelector(\u0026#39;.sun-btn\u0026#39;); 4const moon = document.querySelector(\u0026#39;.moon-btn\u0026#39;); 5 6// MediaQueryList object 7const useDark = window.matchMedia(\u0026#34;(prefers-color-scheme: dark)\u0026#34;); 8 9// Toggles the \u0026#34;dark-mode\u0026#34; class 10function toggleDarkMode(state) { 11 document.documentElement.classList.toggle(\u0026#34;dark-mode\u0026#34;, state); 12 darkModeState = state; 13} 14 15// Sets localStorage state 16function setDarkModeLocalStorage(state) { 17 localStorage.setItem(\u0026#34;dark-mode\u0026#34;, state); 18} 19 20// Initial setting 21toggleDarkMode(localStorage.getItem(\u0026#34;dark-mode\u0026#34;) == \u0026#34;true\u0026#34;); 22 23// Listen for changes in the OS settings. 24// useDark.addListener((evt) =\u0026gt; toggleDarkMode(evt.matches)); 25 useDark.addEventListener(\u0026#39;change\u0026#39;, (evt) =\u0026gt; { 26 toggleDarkMode(evt.matches); 27 }); 28 29 30// Toggles the \u0026#34;dark-mode\u0026#34; class on click and sets localStorage state 31sun.addEventListener(\u0026#34;click\u0026#34;, () =\u0026gt; { 32 darkModeState = !darkModeState; 33 34 toggleDarkMode(darkModeState); 35 setDarkModeLocalStorage(darkModeState); 36}); 37moon.addEventListener(\u0026#34;click\u0026#34;, () =\u0026gt; { 38 darkModeState = !darkModeState; 39 40 toggleDarkMode(darkModeState); 41 setDarkModeLocalStorage(darkModeState); 42}); 心得 其實我認為此方法，跟我原本也是使用JS在頁面上動態地添加或刪除 dark-mode 類的方法大同小異，實在是不清楚為何就能解決頁面跳轉時會出現短暫的白色閃爍問題，希望有前端專業的人可以補充。\nReference\nDark Mode - The prefers-color-scheme Website Tutorial ",
	  "pubDate": "2023-03-22T11:34:07+08:00",
	  "cover": "https://sunnote.xyz/img/thumbnail/024.webp"

	}, 
	{
	
		
	  "url": "http://sunnote.xyz/zh-tw/tutorials/sql-scopeidentity-identity-diff/",
	  "title": "SQL SCOPE_IDENTITY() 與 @@IDENTITY 取得自動增量值差異",
	  "summary": "\u003cp\u003eSQL Server使用 SCOPE_IDENTITY() 取得最近新增一筆的資料，並比較 SCOPE_IDENTITY() 與 @@IDENTITY 取值差異。\u003c/p\u003e",
	  "content": "SQL Server使用 SCOPE_IDENTITY() 取得最近新增一筆的資料，並比較 SCOPE_IDENTITY() 與 @@IDENTITY 取值差異。\n需求 前端畫面在新增資料時，很常需要對此資料做後續的處理，需要此次新增資料的IDENTITY。或是後端資料庫若有資料變動時常會有觸發器進而更改或是新增資料，也需要當下新增的資料的IDENTITY做後續處理的需求。此篇記錄一下SQL Server使用 SCOPE_IDENTITY() 與 @@IDENTITY 的實際差異。 原理 SCOPE_IDENTITY() 函數是返回當前作用域中最近插入的自動增量值。也就是說，它只會返回當前執行 INSERT 陳述式時所產生的自動增量值，並不會受到任何觸發器所產生的自動增量值的影響。\n@@IDENTITY 函數是返回最後一個 INSERT 陳述式所產生的自動增量值，而不管是在哪個作用域內產生的。所以如果INSERT 陳述式中包含了觸發器，則 @@IDENTITY 函數可能會返回不是預期的自動增量值。\n講起來有點複雜，直接實作範例。\n範例 1.建立範例資料表\n1CREATE TABLE ExampleTable ( 2 ID INT PRIMARY KEY IDENTITY(1,1), 3 Name NVARCHAR(50) NOT NULL 4); 2.建立觸發器，若有資料新增，則再複製一筆相同資料\n1CREATE TRIGGER ExampleTrigger 2ON ExampleTable 3FOR INSERT 4AS 5BEGIN 6 INSERT INTO ExampleTable (Name) 7 SELECT Name FROM INSERTED 8END; 3.新增 Name 為 Alvin 的資料，同時會啟動觸發器，資料表會有兩筆Alvin。\n1INSERT INTO ExampleTable (Name) 2VALUES (\u0026#39;Alvin\u0026#39;); 3 4SELECT SCOPE_IDENTITY() 5SELECT @@IDENTITY 6 7DROP TABLE ExampleTable; 資料表內容如下\nID Name 1 Alvin 2 Alvin SELECT SCOPE_IDENTITY() 結果為 1\nSELECT @@IDENTITY 結果為 2\n可以很明顯看出，SCOPE_IDENTITY()就是取得當下 insert 的ID，而 @@IDENTITY 則是會取得觸發器新增資料的ID。 結論 在取得自動增量值時，如果是要對此次新增的資料做後續處理，請使用 SCOPE_IDENTITY()，使用 @@IDENTITY 有可能會取到因為此次新增而額外新增的值。\n",
	  "pubDate": "2023-03-20T10:44:19+08:00",
	  "cover": "https://sunnote.xyz/img/thumbnail/023.png"

	}, 
	{
	
		
	  "url": "http://sunnote.xyz/zh-tw/tutorials/jwt-authentication-mechanism/",
	  "title": "JWT 驗證機制原理與實作範例 (C#)",
	  "summary": "\u003cp\u003eJWT（JSON Web Token）是一種開放標準，用於在各方之間安全地傳遞資訊。JWT使用JSON物件表示要傳遞的訊息，並使用數字簽名或加密來保護這些訊息。\u003c/p\u003e",
	  "content": "JWT（JSON Web Token）是一種開放標準，用於在各方之間安全地傳遞資訊。JWT使用JSON物件表示要傳遞的訊息，並使用數字簽名或加密來保護這些訊息。\n平常用於快速建立輕型網站的登入驗證，紀錄一下以 C# 實作 JWT 用法。 介紹 JWT\nEncoded\neyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c\n由三部分組成，分別是 Header、Payload 和 Signature。\n直接使用官網的範例:\nHeader 部分包含了JWT使用的加密算法、類型等數據。\n{ \u0026#34;alg\u0026#34;: \u0026#34;HS256\u0026#34;, \u0026#34;typ\u0026#34;: \u0026#34;JWT\u0026#34; } Header是一個JSON物件，包含了以下兩個屬性：\nalg：表示使用的加密算法，例如HS256、RS256等。 typ：表示類型，通常設置為JWT。 Payload 部分包含了要傳輸的信息。\nPayload也是一個JSON物件，可以包含自定義的屬性。為了方便查詢而夾帶的一些客戶基本資料等\u0026hellip;就是放在Payload的部分。\n{ \u0026#34;sub\u0026#34;: \u0026#34;1234567890\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;John Doe\u0026#34;, \u0026#34;iat\u0026#34;: 1516239022 } Payload 中可以包含的標準屬性包括：\niss：JWT的發行者，表示 JWT 是由誰發行的。 sub：JWT的主題，表示 JWT 所代表的實體（通常是使用者）。 aud：JWT的接收者，表示 JWT 可以被誰使用。 exp：JWT的過期時間，表示 JWT 何時過期，過期的 JWT 不能再使用。 nbf：JWT的生效時間，表示 JWT 何時生效。 iat：JWT的發行時間，表示 JWT 何時被發行。 jti：JWT的唯一標識符，用於防止 JWT 被重複使用。 以上列出的屬性是 JWT 規格中定義的一些標準，當然也可以自定義一些名稱，用於表示應用中的特定資訊。\nSignature 部分則是對Header和Payload進行數字簽名的結果。\nHMACSHA256(\rbase64UrlEncode(header) + \u0026#34;.\u0026#34; +\rbase64UrlEncode(payload),\r\u0026#39;your-256-bit-secret\u0026#39;\r) header 跟 payload 中間用.來串接，your-256-bit-secret是存放在伺服器端的自定義字串(私鑰)，最後將這三個部分串接在一起後的字串進行加密演算法進行加密簽名。\n簽名可以保證JWT沒有被篡改。簽名的計算方式根據不同的加密算法而不同，常見的算法包括HMAC和RSA。 原理 簡單來講就是用Header和Payload生成一個字串，字串之間以.連接，然後使用一個私密的金鑰對此字串進行簽名，最終生成一個包含Header、Payload和簽名的字符串(JWT)。 在驗證JWT時，接收方可以將Header和Payload解碼，然後使用相同的金鑰對簽名進行驗證，以確保JWT沒有被篡改。如果驗證成功，則可以信任JWT中包含的訊息。 建立JWT 範例 (.NET 6) 1using System.IdentityModel.Tokens.Jwt; 2using System.Security.Claims; 3using System.Text; 4using Microsoft.IdentityModel.Tokens; 5 6// 設定 JWT 的簽名金鑰 7var securityKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(\u0026#34;MySuperSecretKey\u0026#34;)); 8var signingCredentials = new SigningCredentials(securityKey, SecurityAlgorithms.HmacSha256); 9 10var claims = new[] 11{ 12 new Claim(JwtRegisteredClaimNames.Sub, \u0026#34;user123\u0026#34;), // 設定使用者名稱 13 new Claim(JwtRegisteredClaimNames.Jti, Guid.NewGuid().ToString()) // 設定 JWT ID 14 }; 15 16// 設定 JWT 的有效期限為 1 小時 17var expires = DateTime.UtcNow.AddHours(1); 18 19// 建立 JWT 物件 20var token = new JwtSecurityToken( 21 issuer: \u0026#34;MyApp\u0026#34;, 22 audience: \u0026#34;MyClient\u0026#34;, 23 claims: claims, 24 expires: expires, 25 signingCredentials: signingCredentials); 26 27// 把物件轉成 JWT 字串 28var tokenString = new JwtSecurityTokenHandler().WriteToken(token); 29 30//印出 JWT 字串 31Console.WriteLine(tokenString); 驗證JWT 範例 (.NET 6) 1// 取得從前端攜帶的 JWT 2string tokenString = \u0026#34;{insert JWT token string here}\u0026#34;; 3 4// 設定 JWT 的驗證參數 5var validationParameters = new TokenValidationParameters 6{ 7 // 設定 JWT 的發行者和接收者 8 ValidIssuer = \u0026#34;MyApp\u0026#34;, 9 ValidAudience = \u0026#34;MyClient\u0026#34;, 10 // 設定驗證 JWT 的簽名金鑰和加密算法 11 IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(\u0026#34;MySuperSecretKey\u0026#34;)), 12 ValidateIssuerSigningKey = true, 13 ValidateLifetime = true, 14 ClockSkew = TimeSpan.Zero 15}; 16 17try 18{ 19 // 驗證 JWT 20 var jwtHandler = new JwtSecurityTokenHandler(); 21 var principal = jwtHandler.ValidateToken(tokenString, validationParameters, out var validatedToken); 22 var jwtToken = validatedToken as JwtSecurityToken; 23 24 // 取得使用者名稱和 JWTID 25 var username = jwtToken.Claims.First(x =\u0026gt; x.Type == JwtRegisteredClaimNames.Sub).Value; 26 var jwtId = jwtToken.Claims.First(x =\u0026gt; x.Type == JwtRegisteredClaimNames.Jti).Value; 27 28 // 在這裡可以執行額外的驗證，例如檢查使用者是否存在於資料庫中，以及檢查使用者是否有權限存取資源等等 29 30 // 驗證成功 31 Console.WriteLine($\u0026#34;Token validated. Username: {username}, JWT ID: {jwtId}\u0026#34;); 32} 33catch (SecurityTokenException e) 34{ 35 // 驗證失敗 36 Console.WriteLine($\u0026#34;Token validation failed: {e.Message}\u0026#34;); 37} JWT 的發行者和接收者\n發行者（issuer）：用於表示 JWT 是由誰發行的，通常是一個識別 JWT 的組織或應用程式的名稱或網域。當我們驗證 JWT 的時候，可以檢查 JWT 的發行者是否符合預期的值，以確保 JWT 是由正確的組織或應用程式發行的。\n接收者（audience）：用於表示 JWT 可以被誰使用，通常是一個識別 JWT 使用者的應用程式或 API 的名稱或網域。當我們驗證 JWT 的時候，可以檢查 JWT 的接收者是否符合預期的值，以確保 JWT 可以被正確的應用程式或 API 使用。 自己動手寫一個 以上是直接使用.NET Core的庫來實作 JWT 相關功能，最近接到一個需求為，需要生成一次性的檔案下載網址來防止檔案網址外流，思考後打算用 JWT 來實作。\n思考邏輯為，若需要產生一次性網址，為了不產生資料庫負擔，那就產生一個有時效性的 JWT，而在提供檔案下載的 API 中再去額外加上 JWT 驗證，若時效已過則不提供下載，以達成一次性下載網址。\n此功能的流程即是: 使用檔案的ID(GUID)產生 JWT ➜ 生成包含 JWT 的一次性網址 ➜ 透過網址下載時需驗證 JWT 時效性 ➜ 判斷是否給予下載\n先建立 Header 與 Payload 的物件\npublic class oJWT_Header { public string alg { get; set; } public string typ { get; set; } } public class oJWT_Payload { public long exp { get; set; } public long iat { get; set; } public Guid id { get; set; } } Payload的部分，我主要需要 JWT 的過期時間(exp) 與檔案的唯一值ID(id)。\n生成 JWT 1public static string JWT_Encoder(Guid fileID) 2 { 3 oJWT_Header header = new oJWT_Header(); 4 header.alg = \u0026#34;HS256\u0026#34;; 5 header.typ = \u0026#34;JWT\u0026#34;; 6 7 oJWT_Payload payload = new oJWT_Payload(); 8 DateTimeOffset now = DateTimeOffset.UtcNow; 9 long unixTimestamp = now.ToUnixTimeSeconds(); 10 long unixTimestamp_exp = now.AddSeconds(20).ToUnixTimeSeconds(); 11 payload.iat = unixTimestamp; 12 payload.exp = unixTimestamp_exp; 13 payload.id = fileID; 14 15 string json_header = JsonConvert.SerializeObject(header); 16 byte[] b_header = System.Text.UTF8Encoding.UTF8.GetBytes(json_header); 17 string b64_header = Convert.ToBase64String(b_header); 18 19 string json_payload = JsonConvert.SerializeObject(payload); 20 byte[] b_pl = System.Text.UTF8Encoding.UTF8.GetBytes(json_payload); 21 string b64_payload = Convert.ToBase64String(b_pl); 22 23 string encryptSignature = ComputeHMACSHA256(b64_header + b64_payload, b64_payload + payload.id); 24 string token = b64_header + \u0026#34;.\u0026#34; + b64_payload + \u0026#34;.\u0026#34; + encryptSignature; 25 26 return token; 27 } Header 物件代入分別代表使用的演算法與token形式 (alg、typ)。\nPayload 物件需要代入 JWT 的發行時間(iat)、有效時間(exp)與檔案ID(id)，時間都是以UTC時間轉換為Unix time。而有效時間為當下的時間再加20秒。\n接下來就是對 Header 與 Payload 分別進行 Base64 的編碼。\n再把編碼後的 Header 與 Payload 進行 HMACSHA256 加密，而私鑰我選擇使用 編碼後的 Payload + fileID，這樣可以確保每組網址的私鑰都是不同的也不用寫死在server端。\nHMACSHA256 加密 1public static string ComputeHMACSHA256(string data, string key) 2 { 3 var keyBytes = Encoding.UTF8.GetBytes(key); 4 using (var hmacSHA = new HMACSHA256(keyBytes)) 5 { 6 var dataBytes = Encoding.UTF8.GetBytes(data); 7 var hash = hmacSHA.ComputeHash(dataBytes, 0, dataBytes.Length); 8 return BitConverter.ToString(hash).Replace(\u0026#34;-\u0026#34;, \u0026#34;\u0026#34;).ToUpper(); 9 } 10 } HMACSHA256 加密的部分此篇不多作說明，而取得加密簽章後，JWT 即等於 : 編碼後的header.編碼後的payload.加密簽章\n驗證 JWT 1public static bool JWT_Decoder(string JWT) 2 { 3 string[] ary = JWT.Split(\u0026#39;.\u0026#39;); 4 if (ary.Length != 3) return false; 5 else 6 { 7 string b64_header = ary[0]; 8 string b64_payload = ary[1]; 9 string Signature = ary[2]; 10 11 Byte[] ary_header = Convert.FromBase64String(b64_header); 12 string json_header = System.Text.UTF8Encoding.UTF8.GetString(ary_header); 13 oJWT_Header header = JsonConvert.DeserializeObject\u0026lt;oJWT_Header\u0026gt;(json_header); 14 15 Byte[] ary_payload = Convert.FromBase64String(b64_payload); 16 string json_pl = System.Text.UTF8Encoding.UTF8.GetString(ary_payload); 17 oJWT_Payload payload = JsonConvert.DeserializeObject\u0026lt;oJWT_Payload\u0026gt;(json_pl); 18 19 string encryptSignature = ComputeHMACSHA256(b64_header + b64_payload, b64_payload + payload.id); 20 21 if (!Signature.Equals(encryptSignature)) return false; 22 23 long exp = payload.exp; 24 long now = DateTimeOffset.UtcNow.ToUnixTimeSeconds(); 25 if (now \u0026gt; exp) return false; 26 } 27 return true; 28 } 驗證的部分很簡單，一開始因為 JWT 格式就是以.分割，所以我先以.劃分，若字符串數組長度不等於3，那不符合格式回傳 false。\n接下來數組可以分為 b64_header、 b64_payload 與 Signature，分別對經過 Base64 編碼後的 Header 與 Payload 解碼，取得相關資訊後，就可以驗證 Signature 是否符合。若不符合代表JWT有被串改過即回傳 false。\n最後一步，就是驗證時效性，因為當初設定時效為產生 JWT 之後20秒內，所以只要取 Payload 的 exp 來比較當下的時戳，若已超出即返回 false。\n以上完成了使用 JWT 產生一次性網址的功能，實際使用 Payload 還能代入其他參數方便 下載檔案的 API 查詢檔案路徑。\n總結 目前開發上只用在輕型網站的登入系統驗證機制，但其實JWT還有其他的用途像是資源權限授權、單點登錄(SSO)、時效性服務、應用程序間通訊等。藉由派發有時效性的 JWT 並在每次存取資源時驗證可以使其應用更廣泛。\n",
	  "pubDate": "2023-03-06T16:05:44+08:00",
	  "cover": "https://sunnote.xyz/img/thumbnail/022.png"

	}, 
	{
	
		
	  "url": "http://sunnote.xyz/zh-tw/tutorials/hugo-related-posts-supports-carousel-display/",
	  "title": "Hugo 實現推薦文章功能與輪播顯示",
	  "summary": "\u003cp\u003e簡單實現以輪播方式顯示推薦文章列表。\u003c/p\u003e",
	  "content": "簡單實現以輪播方式顯示推薦文章列表。\n前言 其實好奇推薦文章的實作方式很久了，也看過一些論點對於網站是否有推薦文章功能並不是哪麼的必需!!?但對於自己本身，如果在瀏覽網站時，對於查閱推薦文章若發現有興趣的文章再點進去的機率實在是非常高。所以來記錄一下實做的細節，並且用輪播的方式呈現。\n輪播也是一個大坑，畢竟弄不好，若在手機平板閱讀時，反而會導致操作不順，此篇使用的輪播外掛完全沒有這個問題👍。\n文章關聯性判斷 推薦文章的內容可以直接藉由Hugo本身文章的tags參數去取得關聯性，邏輯是會先在所有文章中搜尋是否有跟當下文章有相同tags的文章，若有的話就顯示推薦文章列表。\n為了避免修改到Hugo原本的主題，可以對根目錄\\layouts\\_default\\single.html修改。\n(若沒有此檔案可以從根目錄\\themes\\主題\\layouts\\_default\\single.html複製過去)\n推薦文章列表通常會放在文章底部，可以依自己喜好選擇放在哪裡。我是選擇放在留言版的上方，所以程式碼加在single.html裡{{ partial \u0026quot;comments.html\u0026quot; . }}的上方。\n1{{- range first 1 (where (where .Site.Pages \u0026#34;.Params.tags\u0026#34; \u0026#34;intersect\u0026#34; .Params.tags) \u0026#34;Permalink\u0026#34; \u0026#34;!=\u0026#34; .Permalink) -}} 2 {{- $.Scratch.Set \u0026#34;has_related\u0026#34; true -}} 3{{- end -}} 4 5{{ if $.Scratch.Get \u0026#34;has_related\u0026#34; }} 6 \u0026lt;div class=\u0026#34;related-content\u0026#34;\u0026gt; 7 \u0026lt;h3\u0026gt;See Also\u0026lt;/h3\u0026gt; 8 \u0026lt;ul\u0026gt; 9 {{- $num_to_show := .Site.Params.related_content_limit | default 3 -}} 10 {{ range first $num_to_show (where (where .Site.Pages \u0026#34;.Params.tags\u0026#34; \u0026#34;intersect\u0026#34; .Params.tags) \u0026#34;Permalink\u0026#34; \u0026#34;!=\u0026#34; .Permalink) }} 11 \u0026lt;li\u0026gt; 12 \u0026lt;a href=\u0026#34;{{ .RelPermalink }}\u0026#34;\u0026gt;{{ .Title }}\u0026lt;/a\u0026gt; 13 \u0026amp;ndash; 14 \u0026lt;time datetime=\u0026#34;{{ .Date.UTC.Format \u0026#34;2006-01-02T15:04:05-0700\u0026#34; }}\u0026#34;\u0026gt; 15 {{ .Date.Format \u0026#34;Jan 2, 2006\u0026#34; }} 16 \u0026lt;/time\u0026gt; 17 \u0026lt;br\u0026gt; 18 \u0026lt;small\u0026gt;{{ .Summary | plainify | htmlUnescape }}\u0026lt;/small\u0026gt; 19 \u0026lt;/li\u0026gt; 20 {{ end }} 21 \u0026lt;/ul\u0026gt; 22 \u0026lt;/div\u0026gt; 23{{ end }} {{ .Title }}為相關文章標題\n{{ .RelPermalink }}為相關文章連結\n{{ .Summary | plainify | htmlUnescape }}為相關文章的摘要\n相關文章列表，預設顯示三篇\r輪播顯示 只顯示文章標題、日期與摘要感覺有點單調，所以網路上找了一下輪播的實作。最後選擇了使用Owl Carousel，覺得功能十分強大包含了RWD、參數設定靈活，還可以藉由滑鼠拖拉來使圖片輪播。\n引入JS與CSS\n1\u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdnjs.cloudflare.com/ajax/libs/OwlCarousel2/2.3.4/assets/owl.carousel.min.css\u0026#34;\u0026gt;\u0026lt;/link\u0026gt; 2\u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdnjs.cloudflare.com/ajax/libs/OwlCarousel2/2.3.4/assets/owl.theme.default.min.css\u0026#34;\u0026gt;\u0026lt;/link\u0026gt; 3\u0026lt;script src=\u0026#34;https://code.jquery.com/jquery-3.5.1.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 4\u0026lt;script src=\u0026#34;https://cdnjs.cloudflare.com/ajax/libs/OwlCarousel2/2.3.4/owl.carousel.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 可以自行選擇畫面要呈現多少個輪播區塊\n1$(\u0026#34;.owl-carousel\u0026#34;).owlCarousel({ 2 loop: true, // Enable loop playback 3 margin: 10, // Set margin between items to 10px 4 nav: true, // Enable navigation dots 5 responsive: { 6 0: { 7 items: 2 // Display 2 items on screens from 0 to 600 8 }, 9 600: { 10 items: 4 // Display 4 items on screens from 600 to 1000 11 }, 12 1000: { 13 items: 4 // Display 4 items on screens larger than 1000 14 } 15 } 16}); 想要在輪播區塊顯示文章封面，在滑鼠經過時有浮出的效果，針對自己想要的樣子客製化一下。\n1.owl-theme .item { 2\theight: 15rem; 3\tbackground-color: rgba(245, 245, 245, 0.3); 4\tpadding: 0.5rem; 5\tbox-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.1); 6\ttransform: scale(0.9, 0.9); 7\ttransition: all 0.3s ease-out; 8} 9.owl-theme .item:hover { 10\ttransform: scale(1.0, 1.0); 11} 12.owl-carousel .item h4 { 13\tcolor: #000000; 14\tfont-weight: 400; 15\tfont-size: 1rem; 16\tmargin-top: 0rem; 17} 18.owl-carousel .item img { 19\twidth: 100%; 20\theight: 7rem; 21\tborder-radius: 4px; 22} 因為我的文章有些有封面，有些沒有，所以再調整一下Html，若沒封面則顯示文章標題與摘要，若有封面則顯示文章封面與標題。\n1{{- range first 1 (where (where .Site.Pages \u0026#34;.Params.tags\u0026#34; \u0026#34;intersect\u0026#34; .Params.tags) \u0026#34;Permalink\u0026#34; \u0026#34;!=\u0026#34; .Permalink) -}} 2\t{{- $.Scratch.Set \u0026#34;has_related\u0026#34; true -}} 3{{- end -}} 4 5{{ if $.Scratch.Get \u0026#34;has_related\u0026#34; }} 6\u0026lt;div class=\u0026#34;related-content\u0026#34;\u0026gt; 7\u0026lt;h3\u0026gt;See Also\u0026lt;/h3\u0026gt; 8{{ end }} 9\u0026lt;div class=\u0026#34;owl-carousel owl-theme\u0026#34;\u0026gt; 10\t{{- $num_to_show := .Site.Params.related_content_limit | default 5 -}} 11\t{{ range first $num_to_show (where (where .Site.Pages \u0026#34;.Params.tags\u0026#34; \u0026#34;intersect\u0026#34; .Params.tags) \u0026#34;Permalink\u0026#34; \u0026#34;!=\u0026#34; .Permalink) }} 12\t\u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt; 13\t{{ if .Params.Thumbnail }} 14\t\u0026lt;div class=\u0026#34;related-post__image\u0026#34;\u0026gt; 15\t\u0026lt;a href=\u0026#34;{{ .RelPermalink }}\u0026#34;\u0026gt; 16\t\u0026lt;img src=\u0026#34;{{ absURL .Params.Thumbnail }}\u0026#34; alt=\u0026#34;{{ .Title }}\u0026#34;/\u0026gt; 17\t\u0026lt;/a\u0026gt; 18\t\u0026lt;h4\u0026gt;\u0026lt;a href=\u0026#34;{{ .RelPermalink }}\u0026#34;\u0026gt;{{ .Title }} 19\t\u0026amp;ndash; 20\t\u0026lt;time datetime=\u0026#34;{{ .Date.UTC.Format \u0026#34;2006-01-02T15:04:05-0700\u0026#34; }}\u0026#34;\u0026gt; 21\t{{ .Date.Format \u0026#34;Jan 2, 2006\u0026#34; }} 22\t\u0026lt;/time\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/h4\u0026gt;\u0026lt;/div\u0026gt; 23 24\t{{ else }} 25\t\u0026lt;h4\u0026gt;\u0026lt;a href=\u0026#34;{{ .RelPermalink }}\u0026#34;\u0026gt;{{ .Title }} 26\t\u0026amp;ndash; 27\t\u0026lt;time datetime=\u0026#34;{{ .Date.UTC.Format \u0026#34;2006-01-02T15:04:05-0700\u0026#34; }}\u0026#34;\u0026gt; 28\t{{ .Date.Format \u0026#34;Jan 2, 2006\u0026#34; }} 29\t\u0026lt;/time\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/h4\u0026gt; 30\t\u0026lt;hr\u0026gt; 31\t\u0026lt;small\u0026gt;{{ .Summary | plainify | htmlUnescape }}\u0026lt;/small\u0026gt; 32 33\t{{ end }}\t34\t\u0026lt;/div\u0026gt; 35 {{ end }} 成品展示 推薦文章輪播\r參考\nShow Related Posts in Hugo\n簡單好上手的圖片輪播 jQuery - Owl Carousel\n",
	  "pubDate": "2023-02-22T11:02:15+08:00",
	  "cover": "https://sunnote.xyz/img/thumbnail/021.png"

	}, 
	{
	
		
	  "url": "http://sunnote.xyz/zh-tw/tutorials/hugo-multiple-comments/",
	  "title": "Hugo 實現提供多種留言版選擇",
	  "summary": "\u003cp\u003e簡單實現增加多種留言板功能，並提供選單讓使用者可以自己選擇喜愛的留言方式。\u003c/p\u003e",
	  "content": "簡單實現增加多種留言板功能，並提供選單讓使用者可以自己選擇喜愛的留言方式。\n前言 如果有經營個人網站的習慣，相信大家都會想要與參訪的人有互動，網路上也很多教學提供第三方快速建置留言板的功能。像是Disqus、Gitalk、Utterances、Commento、FB\u0026hellip;等。\n但我自己在閱讀文章的習慣與體驗上，有時候想留言，卻因為對方使用的是Facebook Comments Plugin，並不想透漏太多個人訊息，或是非工程師的人想詢問，網站卻只提供需要Github帳號的Utterances、Gitalk留言功能，或是還要在額外註冊帳號的Disqus，導致想留言的興致瞬間降低，所以我想說乾脆把能想到的留言功能都開放，這樣子如果再沒人留言，應該就是自己文章寫的太爛了吧。😂\n想法 我的作法是直接提供各個留言板，但是在CSS的部分得先對整個留言板隱藏。留言板上方給予使用者一個選單，點選特定留言板按鈕同時修改CSS，讓該留言板顯示，其餘的則是改為隱藏。\n程式碼 HTML的部分，有幾種留言板就增加幾個button，範例總共會使用Facebook、Github跟Disqus的套件，所以就會有三個按鈕。 為了避免修改到Hugo原本的主題，可以對根目錄\\layouts\\_default\\single.html修改。\n(若沒有此檔案可以從根目錄\\themes\\主題\\layouts\\_default\\single.html複製過去)\nHTML加在single.html裡{{ partial \u0026quot;comments.html\u0026quot; . }}的下方。\n1\u0026lt;nav class=\u0026#34;nav\u0026#34;\u0026gt; 2\t\u0026lt;button id=\u0026#34;fb-btn\u0026#34; class=\u0026#34;nav-item is-active\u0026#34; active-color=\u0026#34;#ACD6FF\u0026#34;\u0026gt;Facebook\u0026lt;/button\u0026gt; 3\t\u0026lt;button id=\u0026#34;github-btn\u0026#34; class=\u0026#34;nav-item\u0026#34; active-color=\u0026#34;#ACD6FF\u0026#34;\u0026gt;Github\u0026lt;/button\u0026gt; 4\t\u0026lt;button id=\u0026#34;disqus-btn\u0026#34; class=\u0026#34;nav-item\u0026#34; active-color=\u0026#34;#ACD6FF\u0026#34;\u0026gt;Disqus\u0026lt;/button\u0026gt; 5\t\u0026lt;span class=\u0026#34;nav-indicator\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; 6\u0026lt;/nav\u0026gt; 在HTML中為每個按鈕添加一個ID，以便JavaScript可以使用它來確定應該顯示哪個留言板。\n以下的CSS與JS則是網路上的一些素材，對按鈕做一些修飾與增加點選的動態效果，畫面部分可以依據自己喜好做修改。\n.nav { display: inline-flex; position: relative; overflow: hidden; max-width: 100%; background-color: #fff; padding: 0 20px; border-radius: 40px; box-shadow: 0 10px 40px rgba(255, 255, 255, 0.8); display: flex; justify-content: center; } .nav-item { color: #83818c; padding: 20px; text-decoration: none; transition: .3s; margin: 0 6px; z-index: 1; font-family: \u0026#39;DM Sans\u0026#39;, sans-serif; font-weight: 500; position: relative; \u0026amp;:before { content: \u0026#34;\u0026#34;; position: absolute; bottom: -6px; left: 0; width: 100%; height: 5px; background-color: #dfe2ea; border-radius: 8px 8px 0 0; opacity: 0; transition: .3s; } } .nav-item:not(.is-active):hover:before { opacity: 1; bottom: 0; } .nav-item:not(.is-active):hover { color: #333; } .nav-indicator { position: absolute; left: 0; bottom: 0; height: 4px; transition: .5s; height: 5px; z-index: 1; border-radius: 8px 8px 0 0; } .nav-item { border: none; outline: none; background-color: #fff; } @media (max-width: 580px) { .nav { overflow: auto; } } 1const indicator = document.querySelector(\u0026#39;.nav-indicator\u0026#39;); 2\tconst items = document.querySelectorAll(\u0026#39;.nav-item\u0026#39;); 3 4\tfunction handleIndicator(el) { 5\titems.forEach(item =\u0026gt; { 6\titem.classList.remove(\u0026#39;is-active\u0026#39;); 7\titem.removeAttribute(\u0026#39;style\u0026#39;); 8\t}); 9 10\tindicator.style.width = `${el.offsetWidth}px`; 11\tindicator.style.left = `${el.offsetLeft}px`; 12\tindicator.style.backgroundColor = el.getAttribute(\u0026#39;active-color\u0026#39;); 13 14\tel.classList.add(\u0026#39;is-active\u0026#39;); 15\tel.style.color = el.getAttribute(\u0026#39;active-color\u0026#39;); 16\t} 17 18 19\titems.forEach((item, index) =\u0026gt; { 20\titem.addEventListener(\u0026#39;click\u0026#39;, (e) =\u0026gt; { handleIndicator(e.target) }); 21\titem.classList.contains(\u0026#39;is-active\u0026#39;) \u0026amp;\u0026amp; handleIndicator(item); 22\t}); 這時可以看到還沒有任何功能的選單。 選單下方就是接著顯示留言板的區塊，因為我想要畫面的預設是facebook的留言功能，在fb的區塊加上style=\u0026quot;display: block;\u0026quot;;其他的留言板則是加上 style=\u0026quot;display: none;\u0026quot; 。\n(此篇不提供加入各種留言板的教學)\n1 2\u0026lt;div id=\u0026#34;disqus-comments\u0026#34; class=\u0026#34;comments markdown\u0026#34; style=\u0026#34;display: none;\u0026#34;\u0026gt; 3\t{{ partial \u0026#34;disqus.html\u0026#34; . }} 4\u0026lt;/div\u0026gt; 5 6\u0026lt;div id=\u0026#34;utterances-comments\u0026#34; class=\u0026#34;comments markdown\u0026#34; style=\u0026#34;display: none;\u0026#34;\u0026gt; 7\t\u0026lt;script src=\u0026#34;https://utteranc.es/client.js\u0026#34; repo=\u0026#34;your repo\u0026#34; issue-term=\u0026#34;pathname\u0026#34; 8\ttheme=\u0026#34;github-light\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34; async\u0026gt; 9\t\u0026lt;/script\u0026gt; 10\u0026lt;/div\u0026gt; 11 12\u0026lt;div id=\u0026#34;facebook-comments\u0026#34; class=\u0026#34;fb-comments\u0026#34; data-href=\u0026#34;your url\u0026#34; data-width=\u0026#34;100%\u0026#34; data-numposts=\u0026#34;5\u0026#34; style=\u0026#34;display: block;\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; 接下來就是使用JS讓點選按鈕時，可以同時修改CSS，做到隱藏或顯示留言版的效果。\n1 // get button element 2\tconst githubBtn = document.getElementById(\u0026#34;github-btn\u0026#34;); 3\tconst disqusBtn = document.getElementById(\u0026#34;disqus-btn\u0026#34;); 4\tconst fbBtn = document.getElementById(\u0026#34;fb-btn\u0026#34;); 5 6\t// get message board element 7\tconst githubBoard = document.getElementById(\u0026#34;utterances-comments\u0026#34;); 8\tconst disqusBoard = document.getElementById(\u0026#34;disqus-comments\u0026#34;); 9\tconst fbBoard = document.getElementById(\u0026#34;facebook-comments\u0026#34;); 10\t// Add click event listeners to each button 11\tgithubBtn.addEventListener(\u0026#34;click\u0026#34;, function () { 12\tgithubBoard.style.display = \u0026#34;block\u0026#34;; 13\tdisqusBoard.style.display = \u0026#34;none\u0026#34;; 14\tfbBoard.style.display = \u0026#34;none\u0026#34;; 15\t}); 16\tdisqusBtn.addEventListener(\u0026#34;click\u0026#34;, function () { 17\tgithubBoard.style.display = \u0026#34;none\u0026#34;; 18\tdisqusBoard.style.display = \u0026#34;block\u0026#34;; 19\tfbBoard.style.display = \u0026#34;none\u0026#34;; 20\t}); 21\tfbBtn.addEventListener(\u0026#34;click\u0026#34;, function () { 22\tgithubBoard.style.display = \u0026#34;none\u0026#34;; 23\tdisqusBoard.style.display = \u0026#34;none\u0026#34;; 24\tfbBoard.style.display = \u0026#34;block\u0026#34;; 25\t}); 使用document.getElementById方法選取每個按鈕元素，然後為其添加一個點擊事件監聽器。當按鈕被點擊時，修改CSS來顯示或隱藏對應的留言板。\n結語 成品!! 會有這樣子的想法有一部分也是因為自己選擇困難，第三方留言功能套件實在太多了，只好全都要。😎\n",
	  "pubDate": "2023-02-16T10:11:38+08:00",
	  "cover": "https://sunnote.xyz/img/thumbnail/020.png"

	}, 
	{
	
		
	  "url": "http://sunnote.xyz/zh-tw/life/valentine-gift-marimo/",
	  "title": "情人節就送這個當禮物:綠藻球Marimo (基本介紹、飼養方式、象徵意義)",
	  "summary": "\u003cp\u003e綠藻球真的是懶人專屬，好飼養超級療癒又有象徵性。\u003c/p\u003e",
	  "content": "綠藻球真的是懶人專屬，好飼養超級療癒又有象徵性。\n是否曾覺得無聊想養些動植物，但又很怕沒時間照料？如果你真的超級懶，或者太忙碌而無法花時間出門，那麼綠藻球可能非常適合你。\n綠藻球是一種非常特別和珍貴的植物，最近我買了幾個。😎\n為大家介紹一下綠藻球的一些基本知識。\n🔎基本介紹 綠藻球是一種非常特別的植物，是一種在湖泊中生長的綠色藻類。這種植物的名字來自於日語中的「まりも」，意思是「毛球」，因為它的形狀非常像一個毛球。綠藻球是北歐和日本的傳統植物，並且被認為是一種帶有特殊象徵意義的植物。\n它不僅是一種美麗的裝飾品，還有許多其他的優點。綠藻球非常容易照顧，只需要定期更換水，保持水質清潔，並確保它有充足的陽光(切記勿太陽直射，室內人造光源已經足夠)。此外，綠藻球還有良好的空氣清新效果，因為它能吸收一些有害的物質，維持室內空氣的新鮮(但小小一顆應該作用不大😂)。\n💡綠藻球的種類 市面上能看到的大部分都是綠色的圓球狀，但實際上，綠藻不僅僅生長成球形。綠藻球的主體是由從中心分支出來的小型絲狀藻類所構成，依照其生長環境可分為附生型、漂浮型和群生型。儘管形狀有所改變，但內容物都是相同的。\n不同形狀的綠藻球\r🗾原生地 綠藻球目前只有在日本、冰島和愛沙尼亞被發現，而離我們最近的發源地是位於北海道的阿寒湖，阿寒湖是一個美麗的湖泊，位於日本北海道東部的釧路市，是當地的主要旅遊勝地之一。這個湖泊的水質清澈，生態環境豐富，吸引了大量的遊客前來觀光。\n綠藻球在阿寒湖中的發現可以追溯到20世紀70年代初。當時，一位研究人員在進行湖泊調查時，發現了這種微生物的存在。隨著進一步的調查研究，發現綠藻球在阿寒湖中的數量非常龐大，甚至成為當地一大特色景觀。綠藻球的大量繁殖與阿寒湖獨特的生態環境密切相關。阿寒湖周圍有著大片的原始森林，這些森林提供了豐富的有機物質，使得湖泊中的生物生長豐富。同時，阿寒湖的水質清澈，沒有污染源，這也為綠藻球的生長提供了良好的環境。\n但也因為受到環境變與遷資源枯竭的威脅，野生的綠藻球已受到保護，禁止采集和販賣。所以被作為北海道旅遊紀念品販賣的綠藻球實際上是人工養殖的綠藻球。除阿寒湖外，在北海道以外的琵琶湖、富士五湖中均有發現綠藻球的蹤跡，但除阿寒湖外，沒有其他的湖泊可以將球藻培養成大球狀成群生長的型態。\n阿寒湖底部的原生綠藻球\r🫶象徵意義 綠藻球非常適合作為情人節的禮物，因為它有象徵意義。在北歐和日本，綠藻球被認為是愛情和忠誠的象徵，因此送給摯愛的人是一個非常適合的選擇。此外，綠藻球還能代表長期的關係，因為它可以生長很長一段時間，並保持它美麗的外觀。\n總結來說，綠藻球是一種非常特別且有象徵意義的植物，如果你正在尋找一件特別的禮物，那麼綠藻球是一個值得考慮的選擇。送給摯愛的人，不僅能夠表示你的心意，還能給他們一個持久的紀念品，讓你們的愛情更加深厚。除此之外，綠藻球還有著其他的意義。它們代表著生命和希望，綠色象徵著成長和繁榮。在忙碌和疲憊的生活中，綠藻球可以成為一個美麗的提醒，讓你回想起生命中重要的價值和美好的事物，真的是非常適合當禮物對吧?\n剛開始養不知道何時才可以炸毛🫥\r雖然一開始只是我自己想養，但自己養又感覺好像很無聊只好邀另一半一起養了，一人一顆，屬於工程師的浪漫。😎\n🌱飼養方法 1.水 水質的選擇，我是建議中性的礦泉水，富含礦物質非常的營養。切記不要用RO逆滲透的水，對人來說可能很乾淨，對綠藻球來說很沒營養會死XD。如果要用自來水，因為通常含有氯，對水生動植物會造成很大的危害。因此，在使用自來水之前最好能放置一至兩天，以便有害成分揮發。一般來說，每1-2週換一次水，但在夏季氣溫較高時，水質容易惡化，可以增加換水的頻率。\n2.光\n既然是植物，就必須透過光照進行光合作用，才能正常生長。但綠藻球是生活在湖底部的藻類，強烈的陽光會對它們造成極大的傷害。因此，飼養綠藻球時千萬要避免陽光直射，室內光線和燈光已經足夠讓綠藻球健康成長。\n3.温度\n綠藻球的故鄉位於北海道寒冷的湖底，對低溫有很強的適應性，但完全無法忍受高溫。在10-25度的水溫下，綠藻球可以健康成長。但當水溫高於30度時，綠藻球就可能因為高溫而死掉。所以在夏天，可以把綠藻球裝進帶蓋的容器裡，放入冰箱的冷藏室避暑。當然，如果在夏天涼爽的日子裡能夠給綠藻球換換水，讓它們在燈光下進行一下光合作用，綠藻球就會更加健康！\n🟢結論 起初只是因為聽到老哥需要幫他正在請長假的同事換水，才知道原來還有這種有趣的生物。自己好好研究了一下，發現真的是非常適合我這種超懶但又有點喜愛水生植物的人飼養。雖然看似簡單，但還是有蠻多的細節需要去注意的，希望它能順利長大。\n後來想說乾脆也揪爸媽一起養，多買了一顆更大的先借放在我這，2cm的綠藻球已經有炸毛的感覺了。😀\n參考資料\n我愛marimo中文推廣站 圖片提供\n阿寒湖のマリモ保全推進委員会 ",
	  "pubDate": "2023-02-14T10:11:38+08:00",
	  "cover": "https://sunnote.xyz/img/thumbnail/019mario.jpg"

	}, 
	{
	
		
	  "url": "http://sunnote.xyz/zh-tw/tutorials/sql-partition-by/",
	  "title": "SQL-partition by 實現資料分組",
	  "summary": "\u003cp\u003e使用SQL partition by 實現資料分割，比較LINQ與partition by效能。\u003c/p\u003e",
	  "content": "使用SQL partition by 實現資料分割，比較LINQ與partition by效能。\n前言 這次拿到的是貨車GPS定位的資料，包含貨車相關資訊、經緯度、行進方向、當下車速之類的。因為資料更新頻率每15分鐘一次，所以資料量算是非常龐大，而我只需要給出所有貨車當下的最新資訊，讓前端能顯示在地圖上。\n使用LINQ 直覺就是直接撈取所有資料，使用GroupBy對車號分組，再對更新時間做降序排列然後選擇每一組中的第一項 解決。\nLINQ好好用!!😂\n1var vehicles = dbContext.VehicleData.ToList(); 2 3var latestVehicleData = vehicles 4 .GroupBy(v =\u0026gt; v.LicensePlate) 5 .Select(g =\u0026gt; g.OrderByDescending(v =\u0026gt; v.Timestamp).First()); 但因為數據量龐大，直接撈取所有資料效能當然不會好\n只好使用SQL查詢來提高效率了，分割資料表的話就是使用partition by來做分組並使用row_number()來取得排序後的number，取第一組就能得到跟LINQ一樣的結果。\n使用Partition by 1SELECT * 2-- Create a subquery to get the latest direction for each vehicle 3FROM ( 4 SELECT license_plate, direction, 5 -- Use the row_number() function to assign a unique row number to each row, 6 -- partitioned by license plate and ordered by timestamp in descending order 7 row_number() over (partition by license_plate order by timestamp desc) as row_num 8 FROM VehicleData 9) subquery 10-- Only return the rows where the row number is equal to 1, which corresponds to the latest data 11WHERE row_num = 1; 結語 LINQ雖然好用，但在一開始取資料時需要考慮到整體的資料量，跟最終要使用那些資料。若需要進行其他複雜的數據運算再考慮LINQ才能增加效率。\n小知識\n看到數據才知道聯結車，前面的車體跟後面的拖車都分別有自己的licence。 😎\n",
	  "pubDate": "2023-02-07T00:00:00Z",
	  "cover": "https://sunnote.xyz"

	}, 
	{
	
		
	  "url": "http://sunnote.xyz/zh-tw/tutorials/csharp-multithreading/",
	  "title": "C# 多執行緒原理、非同步用法與帶入自定義物件",
	  "summary": "\u003cp\u003eC# 多執行緒原理、非同步用法與帶入自定義物件學習過程紀錄。\u003cbr\u003e\n目前遇到的專案都沒有硬性需求使用到多執行緒，此篇為紀錄自己的理解與學習的過程。\u003c/p\u003e",
	  "content": "C# 多執行緒原理、非同步用法與帶入自定義物件學習過程紀錄。\n目前遇到的專案都沒有硬性需求使用到多執行緒，此篇為紀錄自己的理解與學習的過程。\n前言 公司專案有個檔案預先儲存的功能，因為每天都有新檔案，需要每天跑排程執行。原本的寫法，是A的部分下載完，再下載B的部分。會想試試看改用多執行緒的方式寫的原因，主要只是覺得在測試時資料量太大，需要先等A跑完才能測試B的部分很煩而已。😎\n原理 得先了解Program(程式)/Process(程序)/Thread(執行緒)的差異。\nProgram(程式) : 還尚未載入記憶體的程式代碼。 Process(程序) : 已經執行並且載入到記憶體中的 Program ，程序中的每一行程式碼隨時都有可能被CPU執行。 Thread(執行緒) : 同一個 Process 中會有很多個 Thread ，每一個 Thread 負責某一項功能。 以工廠來舉例:\nProgram(程式) = 工廠的詳細製造圖與人員配置\nProcess(程序) = 已經在運行的工廠\nThread(執行緒) = 工廠裡的每位工作人員\n普遍程式執行時都是照著順序一行一行執行，相似於工廠裡的工人照著順序完成自己的任務。這就會產生程式執行過久，工人運用效率不高的問題，如果工人們可以同時執行各自的任務(多執行緒)，這樣效率就會變快很多，但缺點就是硬體不足時(工廠空間太小)，太多工人一起執行任務就會互搶資源導致程式死結(Deadlock)。\n用途 使用多執行緒的情況通常包括：\n需要同時執行多個任務，而這些任務之間沒有關聯。例如，同時下載多個文件或計算多個值。 需要等待一個長時間運行的任務，但不想讓界面變得不可互動。例如，在同時運行的另一個執行線中執行資料庫查詢。 需要執行一個任務，但不想因為它阻塞其他任務。例如，在同時運行的另一個執行線中執行網路連接。 需要在多個核心上執行任務，以利用多核 CPU 的性能。 範例 1using System.Threading; 2 3Thread thread1 = new Thread(Task1); 4thread1.Start(); 5 6Thread thread2 = new Thread(Task2); 7thread2.Start(); 8 9Console.WriteLine(\u0026#34;Completed\u0026#34;); 10Console.ReadKey(); 11 12static void Task1() 13{ 14 for (int i = 0; i \u0026lt; 5; i++) 15 { 16 Console.WriteLine(\u0026#34;Task 1\u0026#34;); 17 Thread.Sleep(1000); 18 } 19} 20 21static void Task2() 22{ 23 for (int i = 0; i \u0026lt; 5; i++) 24 { 25 Console.WriteLine(\u0026#34;Task 2\u0026#34;); 26 Thread.Sleep(1000); 27 } 28} 結果:\nCompleted\rTask 1\rTask 2\rTask 1\rTask 2\rTask 1\rTask 2\rTask 1\rTask 2\rTask 2\rTask 1 為什麼會先出現 \u0026ldquo;Completed\u0026rdquo; ?\n這是因為在上面的程式碼中，兩個執行緒被同時啟動，並且主執行緒不等待其中任何一個執行緒完成，而是立即寫出 \u0026ldquo;Completed\u0026rdquo; 並結束程式。因此，無論哪個執行緒先完成，程式都會先寫出 \u0026ldquo;Completed\u0026rdquo;。\n如果想要等待 thread2 完成，可以加上 thread2.Join() 使主執行緒等待 thread2 執行完畢，再接著執行Console.WriteLine(\u0026quot;Completed\u0026quot;);。\n帶入自定義參數 實際使用時執行緒常會有帶入參數的需求，可以使用ParameterizedThreadStart，ParameterizedThreadStart是一個委派，它指向一個object參數並沒有返回值的方法。所以在使用ParameterizedThreadStart 委派時，需要傳入一個object類型參數。\n但通常資料類型都不會是object，大部分是JObject或是自定義的類型，以下是實作方式。\n針對不同執行緒建立對應的物件\n1// Create an object to hold the list 2class ListContainer1 3 { 4 public List\u0026lt;dynamic\u0026gt; TheList { get; set; } 5 } 6class ListContainer2 7 { 8 public List\u0026lt;customize\u0026gt; TheList { get; set; } 9 } 傳遞 List\u0026lt;dynamic\u0026gt; customize_obj 至 Task1，在 Task1 函式中取得 customize_obj 並執行\n1List\u0026lt;dynamic\u0026gt; customize_obj = new List\u0026lt;dynamic\u0026gt;(); 2var listContainer1 = new ListContainer1 { TheList = customize_obj }; 3// create new thread 4Thread t1 = new Thread(new ParameterizedThreadStart(Task1)); 5// pass parameters and start thread 6t1.Start(listContainer1); 7 8 9void Task1(Object listContainer) 10{ 11 // get customize_obj 12 ListContainer1 container = (ListContainer1)listContainer; 13 List\u0026lt;dynamic\u0026gt; customize_obj = container.TheList; 14 //... 15 //code 16 //... 17} 非同步方法(待續)",
	  "pubDate": "2023-01-19T11:49:15+08:00",
	  "cover": "https://sunnote.xyz"

	}, 
	{
	
		
	  "url": "http://sunnote.xyz/zh-tw/tutorials/csharp-enum/",
	  "title": "C# Enum(枚舉) 用法紀錄",
	  "summary": "\u003cp\u003eC#-Enum(枚舉)用途與使用擴充方法取得description詳細紀錄。\u003c/p\u003e",
	  "content": "C#-Enum(枚舉)用途與使用擴充方法取得description詳細紀錄。\n枚舉就是把一些常數的集合命名分類，以生活上的例子星期就是一種枚舉。\n星期 int 星期一 1 星期二 2 星期三 3 星期四 4 星期五 5 星期六 6 星期日 7 如果有這種固定好的集合需頻繁使用，在程式上就可以以枚舉來實現。除了可方便管理，想在程式中用字串形式當key時，可以很明確知道用途，也不會有大小寫或是拼字錯誤的困擾。\n使用範例 如果沒有預設對應的數字，就是照順序給值\nVeiw = 0\nAdd = 1\nEdit = 2\u0026hellip;\n1public enum LogBehavior 2 { 3 Veiw, Add, Edit, Delete, Search, Login, Send 4 } or\n1public enum Month 2 { 3 Jan = 1, Feb = 2, Mar = 3, Apr = 4, May = 5, Jun = 6, 4 Jul = 7, Aug = 8, Sep = 9, Oct = 10, Nov = 11, Dec = 12 5 } 取用enum參數的方式\n1Console.WriteLine(LogBehavior.Veiw); 2\u0026gt;\u0026gt; Veiw 3 4Console.WriteLine(LogBehavior.Veiw.GetHashCode()); 5\u0026gt;\u0026gt; 0 6 7string month = Month.Jan.ToString(); 8Console.WriteLine(month); 9\u0026gt;\u0026gt; Jan 10 11int monthValue = (int)Month.Jan; 12Console.WriteLine(monthValue); 13\u0026gt;\u0026gt; 1 實際運用例子 後端需要在每個回傳的API裡增加一個可擴充性的物件(List\u0026lt;dynamic\u0026gt;)，裡面可以依據情況增加物件，但需加上特定參數告訴前端物件的資料性質。\n利用枚舉就能輕鬆管理，要回傳物件的特定參數名稱，其他人也能直接照用，不會有人為字串拼錯或大小寫的錯誤，在之後需要其他特定參數也能直接往下增加擴充。\n1public enum prop 2{ 3 [Description(\u0026#34;同步紀錄資訊\u0026#34;)] 4 SyncInfo, 5 [Description(\u0026#34;版本資訊\u0026#34;)] 6 VersionInfo 7} 若要取得Description的內容，可使用此方法擴充，若無Description內容則回傳原始名稱。\n1public static string GetDescription(this Enum value) 2 { 3 var field = value.GetType().GetField(value.ToString()); 4 var attribute = field?.GetCustomAttributes(typeof(DescriptionAttribute), false).FirstOrDefault() as DescriptionAttribute; 5 return attribute == null ? value.ToString() : attribute.Description; 6 } 1Console.WriteLine(prop.SyncInfo.GetDescription()); 2\u0026gt;\u0026gt; 同步紀錄資訊 參考資料\nExtension Methods\nC# enum 列舉 同時儲存內容值和中文說明 教學\n",
	  "pubDate": "2023-01-15T08:49:07+08:00",
	  "cover": "https://sunnote.xyz"

	}, 
	{
	
		
	  "url": "http://sunnote.xyz/zh-tw/tutorials/sql-merge-into-statement/",
	  "title": "SQL-merge into 語法紀錄",
	  "summary": "\u003cp\u003e這次被指派實作不同資料庫同步的功能，公司現有一個ERP系統，\u003c/p\u003e\n\u003cp\u003e資料來源一律以此為標準，讓客戶可在自家系統新增、編輯、寫入ERP、與ERP同步\u0026hellip;\u003c/p\u003e",
	  "content": "這次被指派實作不同資料庫同步的功能，公司現有一個ERP系統，\n資料來源一律以此為標準，讓客戶可在自家系統新增、編輯、寫入ERP、與ERP同步\u0026hellip;\nwhatever~ 總之就是資料寫入EPR後，就是以ERP為準，也因為ERP會定期更動資料，\n在客戶自家系統已寫入ERP的資料需要頻繁同步。\n解決方法 原本想法是直接撈取兩個資料庫資料，逐一做比對，比對有差異的就直接在專案裡生成update的sql語法，\n最後一起更新。(我是覺得蠻直觀的，反正就是硬幹)\n不過主管建議可以用 merge into 的做法，直接在資料庫裡實作就好，於是就要我去查一查使用方式。\n程式碼 Merge into語法如下：\n1--sql 2MERGE INTO table_a target -- 需同步的資料(自家系統) 3USING (select * from table_b ) source -- 基準資料(ERP) 4ON (target.A=source.A and target.B=source.B) -- 兩張表對應的key 5WHEN MATCHED THEN -- 若有找到對應key的資料，則執行以下動作 6 UPDATE -- 這裡我是對表做編輯 7 SET target.E = source.E, 8 target.D = source.D 9WHEN NOT MATCHED THEN -- 若沒有找到對應key的資料，則執行以下動作(可以省略) 10 INSERT (target.E,target.D) VALUES (source.E,source.D); 結論 語法簡潔是蠻方便的，也不用同時執行多筆update語法。\n最後是沒比較兩種方法實際運行上的速度差異，但因為Merge into的做法不用逐一比對欄位是否有差異，\n而是只要有比對到對應的key就直接執行編輯的動作，又是直接在資料庫執行，應該是會快上不少。\n但缺點也是很明顯，因為不管如何有資料就是直接執行編輯的動作，對於有log紀錄的資料表，應該會增加蠻大的負荷跟資料量。\n",
	  "pubDate": "2022-12-22T10:44:38+08:00",
	  "cover": "https://sunnote.xyz"

	}, 
	{
	
		
	  "url": "http://sunnote.xyz/zh-tw/tutorials/leetcode-lru-cache-medium-python/",
	  "title": "Leetcode(Medium) 146. LRU Cache (Python)",
	  "summary": "\u003cp\u003eLRU Cache算是我遇過覺得蠻有趣生活化的題目，感覺也是在很多底層系統會需要用到的觀念。\u003cbr\u003e\n可惜的是目前工作還沒使用到\u0026hellip;\u003c/p\u003e",
	  "content": "LRU Cache算是我遇過覺得蠻有趣生活化的題目，感覺也是在很多底層系統會需要用到的觀念。\n可惜的是目前工作還沒使用到\u0026hellip;\n純粹紀錄解題方法\n題目 設計一個資料結構符合 Least Recently Used (LRU) cache 機制。\n觀念 快取機制主要就是會保留較常使用的資料，淘汰不常使用的資料，以讓使用者在執行程式時，可以更加快速取得自己想要的資訊。\n利用HashMap與DoubleLinkedList搭配實作，\n每個事件代表HashMap的key與value，value則是以DoubleLinkedList產生的node，\n這樣就能知道node實際的順序。\n為了在呼叫 get 與 put 同時更新node的狀態，需要額外有兩個functions輔助\ndef insertInToHead(self, node):\n插入此節點至LinkedList的第一個位置(head的後方、原本第一個節點的前方)\ndef removeNode(self, node):\n移除此節點(前後節點相連)\n後續不管是get 與 put，在更改node的狀態時都是使用這兩個functions。\n細節 LRUCache 初始資料結構需包含dummyHead與dummyTail，這樣才能知道最常使用的位置(dummyHead的後一個)與最不常使用的位置(dummyTail的前一個) 呼叫functions put 時，若最終HashMap長度大於capacity，需先刪除HashMap中的值(key:value)，key的value為LinkedList的最後一個節點(dummyTail的前方節點)，再刪除此節點。 程式碼 1class LinkListed: 2 def __init__(self, key, val): 3 self.key = key 4 self.val = val 5 self.prev = None 6 self.next = None 7 8class LRUCache: 9 def __init__(self, capacity: int): 10 self.size = capacity 11 self.dic = {} 12 self.dummyHead = LinkListed(0, 0) 13 self.dummyTail = LinkListed(0, 0) 14 self.dummyHead.next = self.dummyTail 15 self.dummyTail.prev = self.dummyHead.next 16 17 def get(self, key: int) -\u0026gt; int: 18 if key not in self.dic: return -1 19 node = self.dic[key] 20 self.removeNode(node) 21 self.insertInToHead(node) 22 return node.val 23 24 def put(self, key: int, value: int) -\u0026gt; None: 25 if key in self.dic: 26 node = self.dic[key] 27 node.val = value 28 self.removeNode(node) 29 self.insertInToHead(node) 30 else: 31 node = LinkListed(key, value) 32 self.dic[key] = node 33 self.insertInToHead(node) 34 35 if len(self.dic) \u0026gt; self.size: 36 del self.dic[self.dummyTail.prev.key] 37 self.removeNode(self.dummyTail.prev) 38 39 def insertInToHead(self, node): 40 node.next = self.dummyHead.next 41 self.dummyHead.next.prev = node 42 self.dummyHead.next = node 43 node.prev = self.dummyHead 44 return 45 46 def removeNode(self, node): 47 node.next.prev = node.prev 48 node.prev.next = node.next 49 return ",
	  "pubDate": "2022-12-04T19:44:38+08:00",
	  "cover": "https://sunnote.xyz"

	}, 
	{
	
		
	  "url": "http://sunnote.xyz/zh-tw/cebu/residential_area/",
	  "title": "深入宿霧住宅區",
	  "summary": "\u003cp\u003e紀錄偶然的進入了平常不太敢進入的當地住宅區(Cabantan Street)。\u003c/p\u003e",
	  "content": "紀錄偶然的進入了平常不太敢進入的當地住宅區(Cabantan Street)。\n日期 : 2020.01.24\n前言 宿霧市區在週五的交通通常都是最塞的，因為當地人都想在辛苦工作一周後出門吃飯與喝點酒，而我當日為了趕著晚上的聚餐，選擇搭乘Angkas。因為司機為了減少塞車的機率，不走主要道路而選擇走小路，讓我偶然的進入了平常不太敢進入的當地住宅區(Cabantan Street)。😆\nCabantan Street 位置 Cabantan Street 位於Luz區，可以看到Luz區位於Ayala Malls的旁邊，所以我平常從學校所屬的Mabolo區到Ayala Malls都是走Cardinal Rosales Ave這條主要道路，平常路過時都會注意到Cabantan Street的街口，覺得算是非常有風格的一條街，但是因為安全上的考量，從來沒進去過。😎\n前往吃到飽海鮮餐廳Isla Sugbo Seafood City 當晚與朋友在Isla Sugbo Seafood City聚餐，主要是還沒在台灣以外的地區嘗試吃到飽性質的餐廳加上又是以海鮮為主，覺得很有興趣，特地想來看看餐廳的品質。整體來說用餐環境非常不錯，各式海鮮都是直接現場挑選然後再選擇烹飪方式，當下其實我才開始惡補所有有關烹調的英文字彙。😆唯一缺點就是，上菜有點久，可能是因為用餐人數太多了。目前好像是因為疫情的關係永久歇業，所以就不再繼續詳細介紹。 因為這家店的位置剛好在Cabantan Street上方出口處，如果是叫Grab的話，大概路線就是繞著兩側的Mindanao Ave或是Pope John Paul II Ave主要道路前往，但因為剛好當天趕時間而選擇搭乘Angkas，司機就帶著我直接抄Cabantan Street小路直達。\n住宅區Cabantan Street 常常路過但都沒進去過~ 在宿霧如果地點距離不遠的話，我常常選擇用走的，但因為安全考量基本上都是走Avenue等級的道路，比較不敢直接往小巷走，畢竟華人走在宿霧的街上真的是蠻顯眼的。\n這次卻因為趕時間偶然的進入這個我覺得非常有東南亞氣氛的小街還是在晚上。😎\n可惜沒有機會實際走走逛逛，裡面真的是充滿著人群。 結語 雖然只是匆匆忙忙的路過而已，但是當地住宅區的人文建築真的是蠻特殊的，之後有機會一定得實際去走走。😆\n附上一個白天的街景影片 ",
	  "pubDate": "2022-12-04T16:28:53+08:00",
	  "cover": "https://sunnote.xyz/img/thumbnail/015Cabantan_Street.jpg"

	}, 
	{
	
		
	  "url": "http://sunnote.xyz/zh-tw/cebu/bohol-island-day-tour-tarsier-chocolate-hills/",
	  "title": "宿霧-薄荷島一日遊(眼鏡猴 + 巧克力山)",
	  "summary": "\u003cp\u003e來宿霧唸英文起初並沒有要到其他島嶼旅行的計畫，但中途為了準備考試而想購買一些考試用書，在當地很難購買到考試用書的情況下，選擇直接在網路平台訂書再由家人從台灣帶來順便體驗一下宿霧旅遊。\u003c/p\u003e",
	  "content": "來宿霧唸英文起初並沒有要到其他島嶼旅行的計畫，但中途為了準備考試而想購買一些考試用書，在當地很難購買到考試用書的情況下，選擇直接在網路平台訂書再由家人從台灣帶來順便體驗一下宿霧旅遊。\n日期 : 2020.01.26\n前言 這時我大概已經在宿霧待了三個月，本來想說只是來個快樂學英文，但在被整個海外氛圍影響後，導致想繼續提升自己的英文水平，所以選擇報考雅思。而在宿霧語言學校的教學其實就是讓你有個環境更好適應考試或是基本口說，但在考試策略上我還是相信直接參考有經驗的人最能提升考試級分，所以選擇了線上購買雅思用書。本來家人是要我回台灣拿或是用寄送的，但待在宿霧的我，認為這是個好機會可以讓爸媽知道這裡是多麼好的一個環境，就要求他們來旅遊順便幫我把書帶過來。😆\n行程規劃 來宿霧旅遊其實很方便，不管是當地的旅行社或是直接藉由旅遊平台都能直接購買行程，通常都是會有一個司機開車導引整個旅遊行程，可以說是完全不用規劃，只要準備錢就好。這一次因為是跟家人一起旅行，只要安全與方便就好，所以我就是直接選擇了薄荷島一日遊的行程，從宿霧市區到港口搭船再到薄荷島之後，由專人司機帶領的一日遊行程體驗。😎\n宿霧➝薄荷島 因為是一日遊，行程蠻緊迫的，必須一早就到達搭船的地點，宿霧市區來往搭船的點會有專門司機接送(去程時司機會先跟我們約好回程時的等待地點)。接下來就是買船票並搭上 Ocean Fast Ferries 的船前往 tagbilaran port。\n六點的班次，可見需要多早就起來準備 抵達Tagbilaran port 乘船時間大概快兩個小時，下船後就得去尋找已約定好在港邊等待的專屬司機，之後的行程就是放空給他帶領了。\n眼鏡猴保育區(Tarsier Conservation) 那時對這種猴子不怎麼了解，只是聽說薄荷島獨有一種非常小的眼鏡猴，就非常期待能看看牠。來到薄荷島其中一個行程就是來到眼鏡猴保育區，在去的路途中跟司機聊天，司機說以前能讓人觸摸，但因為這種行為會讓眼鏡猴非常害怕，害怕到精神錯亂導致自殺!，所以現在已經禁止了，只能在遠處觀看。\n實際到達保育區，會由當地的導遊帶領進園區，主要是幫忙尋找在樹上的眼鏡猴，因為真的太小了，數量又很少，所以真的很難找。😂當實際看到時，身體比例真的是顛覆我一般對猴子的想像，而且眼鏡猴是夜行動物，所以白天參觀時，基本上都只會看到他們在睡覺的身影。但是我拍到的是張開眼睛卻一動也不動的，真的不知道是醒著還是真的在睡覺。😂 巧克力山(Chocolate Hill) 拜訪完眼鏡猴後，接著就是前往巧克力山，這個景點算是薄荷島旅遊的熱門景點之一。雨季時，巧克力山呈現青草綠色，當夏季來臨，山丘會轉成茶色（巧克力色），因此以巧克力山聞名。可惜的是我們去的時間點剛好是雨季與夏季的轉換期，氣溫並沒有到很熱，所以山丘上的植披還沒有轉換成茶色。不過實際看到的景色，還是很壯闊。\n必須先爬上某座山丘，才能看到多個巧克力山。😎 遊河(Loboc River) 我覺得這應該是旅行社硬加的行程XD，行程大致上就是搭著船吃著午餐欣賞熱帶叢林風光，中途會下船體驗當地人的文化，有點類似台灣的原住民文化。我覺得不錯的點是整個環境真的很有東南亞風味，有回到了原始森林的感覺。\n當地的小朋友的娛樂是爬到樹頂再往河裡跳，好想嘗試😆 結語 剩餘的行程有參觀當地野生植物、動物園還有一些教堂與古蹟，其實整個行程還蠻豐富的，但因為沒事先做功課，又是不同的文化，對於一些古蹟並沒有特別的想法，基本上算是走馬看花。不過光是能看到Tarsier，我就覺得此趟很值得了。整趟路，司機也非常熱情跟我們解說相關景點不過口音有點小重就是了，好險我待在宿霧已經一段時間了，還能稍微跟他閒聊一下。\n結束後，司機就會送我們回搭船的地方，順利到達宿霧本島後，太陽也剛下山，接著回到跟接駁司機約定好的地點，司機也已經在等我們了，結束了這個蠻充實的一日遊。 ",
	  "pubDate": "2022-12-03T16:28:53+08:00",
	  "cover": "https://sunnote.xyz/img/thumbnail/014IMG_1491.jpeg"

	}, 
	{
	
		
	  "url": "http://sunnote.xyz/zh-tw/cebu/jeepney-anjo-world-theme-park-day-trip/",
	  "title": "菲律賓吉普尼體驗+宿霧主題樂園一日遊",
	  "summary": "\u003cp\u003e體驗了期待已久的宿霧平民交通工具吉普尼還有宿霧最大最新的主題樂園 Anjo World Theme Park。\u003c/p\u003e",
	  "content": "體驗了期待已久的宿霧平民交通工具吉普尼還有宿霧最大最新的主題樂園 Anjo World Theme Park。\n日期 : 2020.01.11\n前言 在宿霧對於外國人可搭乘的交通工具，基本上有計程車(Grab)或是摩托車(Angkas)兩種選擇，或是像我能用走的就用走的。但在路上能看到最多的就是吉普尼(公車)，也是當地人最常搭的交通工具。一直很想嘗試，但看到車上總是坐滿菲律賓人，隨招手隨停的方式，在沒有公車站牌的情況下，我甚至不知道整個行車路線，很怕搭了被載到荒郊野外回不去，始終不敢獨自搭乘。😂 最後只好懇求當地的朋友帶我搭乘，所以就以宿霧最大最新的主題樂園 Anjo World Theme Park 為目的地，全程搭乘吉普尼包含轉車。 (寫這篇文章時順便查詢資料，發現現在路線可以透過googlemap查詢了!!) 到吉普尼發車地點搭乘 我住在Mabolo區，離Anjo World Theme Park是有一段距離的可以看到路線是需要轉車的 我的個性是到一個地方，如果有人知道路，我就不會刻意去認路。所以整個行程，我都是處在一個恍惚的情況，反正就是相信朋友。😎起始位置為tejero(villa gonzalo)，來時我才發現要在這裡等司機發車，因為發車前都沒什麼人，所以我們就直接坐在副駕駛座。本來還疑惑為何特地要來這裡等車，路上不是隨邊招手都會有，可能是因為路途較久，在發車點上車比較會有座位的概念?\n每個吉普尼外觀跟內部環境其實都很不一樣，完全依據駕駛喜好，這台就有點偏老久，但還是有很多看起來很炫的吉普尼。有點類似台灣改車的概念? 只是覺得第一次坐吉普尼就坐副駕駛座很酷所以來拍張照。 然後我們就上路了，前面招牌應該是寫著行車路線，但對於外國人完全不熟悉當地區域可以說是完全看不懂要去哪。 中途轉搭其他吉普尼 因為路線關係，需要下車再搭乘另一個路線的吉普尼，這次副駕駛座就沒位置了 其實後座車廂是真的蠻壅擠的，加上菲律賓人普遍不高，所以車廂高度也頗低。我真的是全程低著頭搭乘😆，而且很酷可以邊坐邊看後方的車流，如果再多點人，甚至會有些人直接手拉的上方桿子吊在後方搭乘，其實還蠻危險的。途中也遇到一些高中生年紀菲律賓人偷搭車不付錢，各國的小孩真的都蠻像的。😎 Anjo World Theme Park 費盡千辛萬苦終於抵達Anjo World Theme Park了(其實只是跟著朋友走😎) 我們購買的票種為Super Tres(Limited to Three Rides)，比較便宜但只能選擇三種遊樂設施，票價為Php 250。會有這種票價可能是為了吸引薪資較低的族群或學生，不然通常都來玩了，應該是想要盡可能的玩多次點才對。入場後可以很清楚看到遊樂設施的指引，不像台灣的遊樂園，真的是大到會迷路。 因為我們只有三項設施可以玩，所以也不急，反正就是走走晃晃，吃點園內的東西。跟其他遊樂園一樣，很多建築都很適合拍照。 最後我們選擇搭自由落體、旋轉木馬跟摩天輪，晚上遊樂園的氣氛比早上更好，人潮更多了。 摩天輪上的景色 整個遊樂園的夜景 結語 單純來旅遊其實很難體驗到這種行程，畢竟會擔心路上交通安全，或是省時直接走包駕駛路線，非常感謝能有人帶領才有這趟旅程，更深入當地人的交通方式與生活，經歷了很難體驗到的回憶。 回家時才發現這個可愛的招牌。😎 ",
	  "pubDate": "2022-12-02T16:28:53+08:00",
	  "cover": "https://sunnote.xyz/img/thumbnail/012IMG_1129.jpeg"

	}, 
	{
	
		
	  "url": "http://sunnote.xyz/zh-tw/cebu/simala-church-day-trip/",
	  "title": "宿霧-希瑪拉教堂(Simala Church)一日遊",
	  "summary": "\u003cp\u003e有幸造訪宿霧最大的教堂希瑪拉教堂，此文主要紀錄當時的行程規劃、偶然的參與彌撒與雄偉的建築。\u003c/p\u003e",
	  "content": "有幸造訪宿霧最大的教堂希瑪拉教堂，此文主要紀錄當時的行程規劃、偶然的參與彌撒與雄偉的建築。\n日期 : 2019.12.15\n前言 來到宿霧一定會聽過這有名的希瑪拉教堂，其實是一座修道院因為其相似城堡的教堂而聞名。位於Sibonga的Lindogon村的一個小山上。但因為此區離宿霧市區有段距離，通常對於外國人的口袋景點並不是非常熱門，畢竟宿霧的景點選擇非常多，所以大部分來此地的都是當地持有天主教信仰的菲律賓人。而我因為宗教的不同，當地友人就邀請我一起體驗這雄偉的教堂跟天主教文化。\n宿霧市區➝希瑪拉教堂交通選擇 如果旅伴經費充裕，建議直接以包車的方式(私車)，不僅便利快速且可以直達目的地。但因為同行友人為當地人，剛好我想要來個深度旅遊，最後是採用搭巴士的方式。(啟程是還好有座位，但回程時沒座位就真的得直直站到市區😅)\n搭計程車(Grab): 使用Grab叫車，直接從宿霧市區到希瑪拉教堂大概要花費 PHP 2,000(依據時間不同，也有可能會在回程時叫不到車)。\n搭私車: 其實我最推薦的就是這種，方法就是直接上各大旅遊平台購買行程，包司機直接從指定點到希瑪拉教堂，遇到好司機路上也能聊個天，體驗一下不同文化民情。結束後也不用趕時間或是擔心太晚叫不到車。\n巴士: 最省錢的行程，可以體驗跟當地人一起搭巴士(非常擁擠的那種)，因為巴士到達的地點還是離教堂有段距離，最後還需乘坐habal habal摩托車才能到達。\n巴士 + habal habal(摩托車) 詳細攻略 我就是選擇這個路線，以下為當時的細節紀錄。\n需先至Cebu South Bus Terminal等待前往教堂的班次，目的地可以選Oslob或是Liloan方向，需在中途Simala下車。 車費為 PHP 100，交通時間大概需要兩個小時。\n(建議不管是在車站還是車上都可以直接跟車站管理員或是司機告知自己要去Simala Church，詢問該在哪裡等車與請司機提醒何時下車。) 巴士票根，中途會有剪票員負責在票上打孔，其實我看不太懂打孔的規則😆 到達後，因為還離教堂有段距離，建議可以直接搭habal-habal(摩托車)直達教堂，我到時路上蠻多在等待的摩拖車司機，價格就是因人而異，大約每人PHP 20，一台車可以載兩人，在台灣大概就是危險駕駛。\n同行友人是直接跟司機談好往返價，好處是價格可能可以壓更低還有回程不怕找不到司機，彼此用WhatsApp聯絡，不過要這樣做就要考慮自己的英語程度了，因為宿霧鄉下地區的人英文不太好口音又超重，有可能會無法溝通。 搭乘habal-habal的路途可以近距離體驗到原始鄉村，中途看到很多羊，但因為當時沒戴安全帽又三貼真的是害怕極了，忘了拿起相機紀錄這一切。😂\n希瑪拉教堂 經過了兩個小時的車程，終於到了，可以看到遠處山丘上的教堂。 走近後，第一印象是好長的教堂😂，不像歐洲教堂都蠻高聳的，菲律賓的教堂反而是很長。會不會是因為這邊也處於地震板塊附近，所以想蓋雄偉的建築物不能往上只好往兩側? 經歷了兩個多小時的車程，剛到教堂第一件事就是先上廁所。廁所旁熟睡的貓🥴 天花板上的壁畫 然後就是參加正在舉行的彌撒，這是我第一次參加這種宗教活動，覺得來參與的每個人都好虔誠。教堂內的氣氛很莊嚴榮種。而因為過程中大家都是使用宿霧語，我可以說是完全聽不懂，看大家做什麼就跟著做啦。😎 彌撒時間 禮拜一➝禮拜五: 12:00\n禮拜六➝禮拜日: 12:00、15:00\n彌撒結束之後可以參觀教堂的二樓，需要拖鞋才可進入，免入場費，除了展示各種不同種類的聖母瑪麗亞還有一些歷史古物遺跡。也提供信徒膜拜與還願，也蠻多人來這請願的，很多人使用小紙條寫著自己的願望，丟入請願箱並祈禱。無宗教信仰的我處在這其實有點尷尬，但還是盡我所能的融入其中。 結束後就繼續繞著外圍參觀這華麗的教堂 當天看到的遊客，都是菲律賓人居多，沒什麼外國遊客，可能就我一個華人吧 來這我才知道原來聖母瑪利亞英文叫MaMaMary，台灣的翻譯害我有點轉不過來😂 返回宿霧市區 因為真的是一個蠻豐富的行程，導致我們在教堂附近待到很晚，回到等待巴士的地區已經很晚了，加上又有一堆人在等車，車次間距久又沒有明顯的班表。當時真的很害怕，會不會搭不上末班車。😂\n等待巴士的地方真的非常的原始。好險最終有上車，不過是以全載滿的情況下，站在走道上回程。沒認識的人帶領還真的連哪裡該下車都不知道。 結語 很開心有機會可以來到此地，以我當時的語言程度與膽量根本不敢嘗試獨自旅行。華麗莊嚴的建築，路途上的鄉村景色，這次旅遊真的是非常愉悅，且讓我體驗到不一樣的宗教與文化，雖然從小讀的是天主教的高中，但因為家庭沒有相關的信仰，並沒有深入了解，更沒有參與過天主教的各種活動。第一次參與彌撒就是在宿霧，備感榮幸。\n",
	  "pubDate": "2022-12-01T16:28:53+08:00",
	  "cover": "https://sunnote.xyz/img/thumbnail/013IMG_0563.jpeg"

	}, 
	{
	
		
	  "url": "http://sunnote.xyz/zh-tw/cebu/christmas-in-cebu/",
	  "title": "在宿霧的聖誕氣氛",
	  "summary": "\u003cp\u003e12月之後語言學校的新學生普遍減少，因為大部分學生都會想回家鄉跨年，或是等到農曆新年結束後才來，很開心能在這段時間體驗當地的過節氣氛，雖然在海外過節還是會覺得有點感傷啦。😂\u003c/p\u003e",
	  "content": "12月之後語言學校的新學生普遍減少，因為大部分學生都會想回家鄉跨年，或是等到農曆新年結束後才來，很開心能在這段時間體驗當地的過節氣氛，雖然在海外過節還是會覺得有點感傷啦。😂\n日期 : 2019.12.25\n前言 11月中才來到宿霧，預計停留半年，所以勢必得在宿霧過聖誕與新年，其實生活也沒什麼改變，平常日就是待在校園持續精進英文，假日才出校園，主要紀錄待在宿霧感受到的氣氛。\n聖誕節 在宿霧，聖誕節的氣氛與台灣有很大的不同，不像台灣聖誕節這個日子主要是被商人炒作一定得準備禮物與朋友交換的制式性質。菲律賓人注重的是在這個日子與家人團聚。基本上與我們的農曆新年相似，所以這時獨自身在海外的人，就會莫名寂寞，因為朋友都回去跟家人團聚了。\n不過雖然性質不同，各大購物中心該有的裝飾也是少不了。 Ayala malls 的內圍裝飾也頗有氣氛，很適合散步幽會。 連叫外送也感受得到，這位司機是那一年第一位跟我說聖誕快樂的人😎 在換匯的時候，更是有人直接戴起聖誕帽😆\n跨年 過完聖誕節，接下來就是跨年與農曆新年。在宿霧跨年跟其他地區一樣都有放煙火的活動。而今年放煙火的位置位於Ayala malls，當天晚上就跟朋友相約去吃飯，想吃高級一點的店沒事先預約，也是會沒位子的。\n之後就是臨時找間店，有位子就進去吃了，聚餐後朋友提議去喝點小酒。\n於是選了一間法式餐廳:La Vie Parisienne, 這間店其實裝潢很美，適合拍照或是情侶約會，但當下其實沒拍什麼照片😆 店家資訊\nLa Vie Parisienne\n地址：371 Gorordo Avenue, Lahug, Cebu City, 6000 Cebu\n聚餐完後，因為園區還是有宵禁，我又不想在外過夜，只好回宿舍。那時園區裡其實也有些活動，學生們也大多聚在交誼區聊天，但因為我還是想專注在學習，想盡量保持作息正常，打算就只待在宿舍念書到12點，然後就寢。\n自己獨自在宿舍看著跨年煙火還真的有點感傷XD。\n結語 第一次在國外經歷聖誕、跨年與農曆新年，因為當地的治安與學校的宵禁，老實說並沒有深入體驗到當地人的過節方式。不過還是體驗到了跟不同國籍朋友們一起慶祝的歡樂，雖然最後還是得準時會宿舍，但也算是過了一個很不一樣的聖誕與除夕夜了。\n",
	  "pubDate": "2022-11-30T19:28:53+08:00",
	  "cover": "https://sunnote.xyz/img/thumbnail/011IMG_0714.jpeg"

	}, 
	{
	
		
	  "url": "http://sunnote.xyz/zh-tw/cebu/daily-life-part2/",
	  "title": "宿霧遊學-日常生活(二)",
	  "summary": "\u003cp\u003e主要想紀錄待在宿霧時，語言學校與宿霧市區各種生活日常，因為當時目標為考試取向，\u003cbr\u003e\n所以並沒有跳島或是夜生活等行程。\u003c/p\u003e",
	  "content": "主要想紀錄待在宿霧時，語言學校與宿霧市區各種生活日常，因為當時目標為考試取向，\n所以並沒有跳島或是夜生活等行程。\n日期 : 2019.11.17➝2020.03.21\n前言 現在想一想當時去宿霧時，因為經濟、自我期許等各種因素，還真的沒有好好體驗一下各種旅遊行程。\n不過其實也不後悔，因為不管選擇什麼都也是種體驗。 😎\n娛樂 宿霧算是菲律賓第二大城，所以能玩的活動其實是蠻多樣的能想到的我覺得應該都有，\n甚至很多我還是第一次聽到😂\n同學間也會糾團參加學校提供的行程，或是直接找當地的旅行社。這其實還蠻方便的，\n在宿霧蠻多一日行程旅遊團，包個導遊直接帶玩一整天。\n但我因為資金有限，所以都是走簡單路線，加上一個禮拜的從早讀到晚的課程，\n其實有時候六日只會想好好休息頂多出去吃個飯喝個小酒。\n整天滿滿的課程真的會累到趁空檔時跑回寢室睡覺 電影院初體驗 這是個我本來就蠻喜歡的娛樂，在台灣也很常自己一個人就跑去看電影，\n在國外當然要來試試，不過宿霧的影音設備沒有台灣那麼好，\n還有就是菲律賓電影上很少會有字幕，所以聽力要先訓練一下~~\n不同mall的電影院也會有新舊差別。\n對於菲律賓人還算是蠻熱門的娛樂選項!\n人都非常多 目前宿霧比較新的我認為是Robinsons Galleria Cebu的電影院 跟當地的菲籍朋友一起來看電影，第一次看到有人可以非常流利的用刀叉吃炸雞🤣 紀念一下菲律賓第一張 Jumanji 電影票，可以說是超級便宜\n聽力再好一點，我真的會看爆XD 很文化衝擊的是，在台灣看電影基本上除了小孩並不會出現比較大的聲音，\n但在菲律賓看電影，不管大的小的真的是會出現各種讚嘆聲。 在旁的菲籍朋友也是每個搞笑環節都是哈哈大笑，\n可以看出菲律賓人他們發自內心奔放的靈魂，\n整個電影院變得生氣勃勃，很想知道在看鬼片時會發生什麼事。😂\n各國餐廳 來宿霧真的要嚐嚐菲律賓菜，像是Choobi choobi這類的餐廳我都覺得好好吃。\n至於各國的料理呢，因為韓國的族群算是在宿霧占比蠻多的，所以到哪都可以看到燒肉餐廳。\n在台灣我就還蠻愛韓國料理的，來這之後，才發現台灣的韓式餐廳都有點入境隨俗偏台式了。 但菲律賓的韓式燒肉就真的非常道地，原因可能是基本上大部分店家老闆就是韓國人吧!!\n我最推的韓國燒肉餐廳👍，當時店名為 Su lat gan 不知為何現在只有韓文了。 如果真的不知道哪間道地，最好的方法就是直接問韓國同學。 不知為何韓國人都蠻嗨的 也學到好多有趣的玩法(喝酒)😎\n總之出國想吃哪類的料理，真的問那國的同學最快。\n至於台灣的部分也是蠻多的，但因為我只比較偏好火鍋。\n之後也因為想專心在念書上，其實能避的局都盡量避。\n但還是會跑來懷念點家鄉的感覺。\n味道沒什麼好說的了，根本跟我家附近的小火鍋店一模一樣😱\n店名:Red House Taiwan Sha-bu Sha-bu 還可以點這種好像不會出現在火鍋店的東西😂\nIT Park 這邊好像算是宿霧的商業中心，很多工作機會在這，\n但聽當地人說大部分都是customer service這類型的工作。\n對其他國家的客戶，所以工作時間通常都是在晚上或是需要輪班。\n很多酒吧、KTV也在這邊，越晚越美麗的地方!?\n不過因為我有門禁也不太想在外過夜，都是早早就回學校了。😂\nSugbo Mercado 夜市 可以來體驗IT Park附近的Sugbo Mercado 夜市 跟台灣的夜市差不多，但賣的食物就是不一樣，整體環境我覺得很乾淨。 吃東西的同時，前方舞台也有人在唱歌跟節目不過都是說宿霧語聽不太懂， 很不一樣的是菲律賓人很嗨被Q到還真的會上去跟著唱做效果😎\n",
	  "pubDate": "2022-11-30T17:28:53+08:00",
	  "cover": "https://sunnote.xyz/img/thumbnail/010.IMG_1727.jpeg"

	}, 
	{
	
		
	  "url": "http://sunnote.xyz/zh-tw/cebu/daily-life-part1/",
	  "title": "宿霧遊學-日常生活(一)",
	  "summary": "\u003cp\u003e主要想紀錄待在宿霧時，語言學校與宿霧市區各種生活日常，因為當時目標為考試取向，\u003cbr\u003e\n所以並沒有跳島或是夜生活等行程。\u003c/p\u003e",
	  "content": "主要想紀錄待在宿霧時，語言學校與宿霧市區各種生活日常，因為當時目標為考試取向，\n所以並沒有跳島或是夜生活等行程。\n日期 : 2019.11.17➝2020.03.21\n前言 來學校也一個禮拜了，因為學制與學區為斯巴達制，所以學校只開放六日能出校門，\n還有夜深門禁，在外過夜未成年得通過父母確認才准許。\n這些在來宿霧前，就已經從代辦那裡得知了，加上認為菲律賓蠻危險的，並沒有抱持著一定得出校門的打算。\n第一次出校外 想起當時，我對於校外還有點害怕，畢竟我就是個嬌生慣養理工肥宅，不過好在遇到一個好室友，\n室友為韓國人，大概快30歲，之前都在澳洲打工度假，因為有想移民的打算，特地與女朋友飛來這唸英文，\n比我早來大概一個多禮拜，聽到我在詢問校外的環境到底如何，就大方地邀請我一起出去逛逛。\n台灣珍奶 這是我在宿霧第一個行程，Formosa Taiwan Milk Tea Shop 因為室友也是認真念書型不太常出校閒晃，所以我們這一次純粹就只是以步行能到的距離範圍內散散步。\n其實如果是同國籍的人還真的沒什麼好聊的，但因為不同國籍光這家店的名字為Formosa，跟台灣有何關係，就能跟這對韓籍情侶解釋好久。😂\n整個店家的感覺呢，有點類似台灣流行的網紅打卡店，裝潢的有點華麗，至於口感的部分，\n因為本人在台灣不管經過什麼飲料店，就只會點珍奶，可以稱做珍奶王，所以整體還真的還沒達到我的標準。\n不過在國外喝到打著台灣名號的飲料店， 就算是假的也給過啦。😆\n馬殺雞按摩 接下來就是來到宿霧一定要體驗的馬殺雞按摩，\n其實整個市區超多按摩店，連大型購物商場也有一個區域直接提供按摩\u0026hellip; 在台灣還沒進過按摩店的我，畢竟對我來說消費還真是不便宜，\n但在看到這價格後，害我之後有一陣子很常自己一人無聊就跑來消費 (google地圖能搜尋到的店家就進去試試看😂)\n在宿霧基本上都能看到中文、韓文與日文的菜單，因為本地人薪資非常低的關係，\n大部分的娛樂消費都是提供給外國人，就連KTV也都有日韓中的歌曲。\n以上就是第一次走出校外的行程，非常感謝室友讓我有這個契機，讓我之後總是想往外走。😎\n校園生活 語言學校裡的環境還真的是蠻豐富的，有泳池，有食堂，有販賣部，洗衣部\u0026hellip;\n校園裡除了自習室，也隨處可見適合坐著聊天的地方，畢竟語言學校就是得有個環境讓不同國家的學生練習口說吧。\n戶外的桌子可吃東西可念書還有菲貓陪伴~ 如果覺得校園伙食太難吃，很多人是決定直接叫外送。\n菲律賓才有的jollibee，我是覺得好吃又便宜，但基本上每個套餐都會配一包飯。😂 基本上學校已經提供了所有生活所需，每個禮拜都也會有專人幫寢室換床單清潔整理，\n還真的是可以做到完全不出校門。\n因為每個禮拜都是同一時段請她來幫我們清潔，到最後也變很熟😎 生活雜務採買 基本上學校剛開始都會帶新生到Ayala Mall進行換匯或是購買些日用品，\n之後就得靠自己啦~! 剛開始我是還蠻不喜歡去Ayala Mall的，因為真的太大了，害我很常迷路\u0026hellip;\n地圖看看就好，我到最後是放棄認路，反正走久了就知道怎麼走了😎\n到最後熟悉了就蠻常來這吃個甜點，喝個下午茶~ 這邊要說一下，宿霧各個商城，甚至購物中心裡面各別的店面，門口都會有警衛，\n但通常就是做幫你開開門之類的事，我還真不知道原因是真的治安不好有需要，還是人工工資太便宜才會有這種情況，\n也很常發現明明沒什麼人的店面，卻有3、4個員工，這在台灣根本是不可能發生的事。\n除了Ayala Mall其實宿霧市區有蠻多購物中心的，像我平常如果只是買一些小零食，會選擇到離學校比較近的小商場，\n(因為我通常都是直接從語言學校步行走到Ayala Mall，沒為什麼就只是喜歡走在街上的感覺XD)\n不知為何現在在google地圖上找不到，名稱我也忘了\u0026hellip;。\n某些小商場，櫃台員工都還會主動幫你把買的東西打包裝箱\n在台灣我還沒受過這種待遇😆 SM mall，頗具特色的員工制服 剪髮 來語言學校遇到的同學，大部分都是短期衝刺，大部分是兩三個禮拜頂多兩個月的課程，所以同學總是來來去去。\n但我因為代辦的建議跟評估報名了六個月的課程😂，基本上待到最後很難找到比我年資久的人了哈哈哈。\n也因為待蠻久的勢必要在這剪頭髮。\n在宿霧的理髮店還蠻多元的，但因為韓國人普遍比較多的情況下，還真的是蠻多韓籍髮型師。\n本地的因為太便宜我真的不太敢嘗試，然後我又比較喜歡韓式髮型，所以都是找韓國的店家。\n這家真的是我的愛店，老闆是一個韓籍中年婦女，洗頭小妹都是請菲律賓人，\n我是覺得技術超好，剪完整個韓系爆表，走在路上還遇到小菲菲直接問我是韓國人嗎?🤨\n重點是才台幣大概200多元!!! 曾經試過其他甚至收費比較貴裝潢也很高級的店反而技術很爛\u0026hellip;\n某一次被剪爛後回去問我韓籍室友到底是什麼情況，他只跟我說可能髮型師也沒差\n反正就專門剪這種只會來一次的留學生，畢竟來來去去的學生真的很多。\n",
	  "pubDate": "2022-11-30T16:28:53+08:00",
	  "cover": "https://sunnote.xyz/img/thumbnail/009.IMG_0720.jpeg"

	}, 
	{
	
		
	  "url": "http://sunnote.xyz/zh-tw/cebu/pre-departure-mood-record/",
	  "title": "宿霧遊學-行前心情紀錄",
	  "summary": "",
	  "content": "日期 : 2019.11.17\n前言 最近回頭翻了一下照片，發現並沒有留下什麼行前的紀錄，\n畢竟當時報名的是著名的斯巴達式課程，知道等待著我的是補習班地獄，\n加上代辦也說了要注意菲律賓的治安、空汙還有課程真的很累等因素。\n我當時是抱持著沮喪的心情，踏上前往宿霧的旅程的。\n台灣搭機 為了便宜機票，特定前一天北上睡機場搭凌晨起飛的班機\n抵達麥克坦－宿霧國際機場 我的航班降落在第二航廈，下機第一印象其實還蠻好的，因為第二航廈雖小但還蠻新的外觀也很現代化，\n查網路第二航廈為2018年7月1開始啟用，看的出來是剛新建好的。😎\n接下來就是過海關拿行李，簽證為旅遊簽，因為有附帶語言學校的證明，\n海關根本也沒問什麼(可能也知道我英文不好只是要來學英文)就放行了。\n麥克坦－宿霧國際機場 ➝ 語言學校 出機場後，就得尋找語言學校聘請負責接送學員的司機，通常就是舉著所屬語言學校校名的牌子。\n順利找到後，就跟著上車，直達語言學校了。\n往語言學校的路途需要大概20~30分鐘，因為麥克坦機場位置是在拉普拉普市，\n如下圖飛機的位置，麥克坦機場是位於整個宿霧島的右側小島， 而我的語言學校則是在宿霧本島。\n在前往宿霧本島的橋上 中途真的沒留下什麼照片，當時心理只有一個念頭，\n天啊，怎麼出了機場城市市容會差那麼多😂\n抵達語言學校 到達時為禮拜日，所以學校裡沒什麼學生，\n其實學校環境還算不錯，有泳池，也很多戶外社交的地方\n還蠻有度假的氣氛，之後才知道還真的蠻多人來這度假順便加強英文。\n接下來的流程就是報到，學校的警衛會帶我參觀認識校園，警衛為菲律賓人，\n態度蠻和藹可親的，但因為當時英文聽力超級差，也不熟悉菲律賓人的口音， 我還真的不知道他在跟我講什麼XD。\n參觀完後就可以到自己的寢室了，✌ 三人一寢，對我這種剛當完兵已經睡大通鋪很久的人來說不錯了哈哈\n遇到的室友很幸運人都不錯，還記得第一次進房間，\n剛好遇到在休息的韓籍室友，在充滿尷尬的情境下只能盡可能的從腦袋擠出目前所能想到的字彙跟語法\n努力跟他溝通，兩人英文都沒很好，一邊手機翻譯卻還能大概了解雙方在講什麼，真的很好奇妙。😅\n那個晚上，我發誓我真的一天就講超過我在台灣活了20幾年說過的英文量\u0026hellip;。\n當然之後的課程更是讓我講英文講到爆。😉\n看看這滿滿的課表，比高中生還累阿 附上語言學校附近的街景，這好像是附近鄰居養的\n在台灣長大的我真的覺得太酷了。😆\n",
	  "pubDate": "2022-11-29T16:28:53+08:00",
	  "cover": "https://sunnote.xyz"

	}, 
	{
	
		
	  "url": "http://sunnote.xyz/zh-tw/%E8%8B%B1%E6%96%87%E5%BE%88%E7%88%9B%E8%83%BD%E5%8E%BB%E5%BF%B5%E8%AA%9E%E8%A8%80%E5%AD%B8%E6%A0%A1%E5%97%8E%E6%95%88%E7%9B%8A%E8%A9%95%E4%BC%B0/",
	  "title": "英文很爛能去念語言學校嗎(效益評估)",
	  "summary": "",
	  "content": "1.前言 此篇主要針對貧窮子弟、家裡沒礦窮二代、賣肝血汗上班族\n追求短時間英文提升，而不是去度假加減學個英文或是家裡有礦的族群。\n2.考慮層面 選擇去留學前，總是會考慮著，去了這趟是否有回報，花了這麼多錢是都丟到水溝還是很值得?\n依本人的經驗，英語能力的提升，最重要也最難短時間提升的，就是字彙量。\n考試技巧可以幾個月衝刺訓練，單字量只能長時間慢慢累積。\n當時在宿霧準備雅思考試時，覺得最急迫的就是字彙量真的沒辦法短時間累積。\n但這確實是考試最重要的一項因素，不管是寫作、口說、聽力，\n沒字彙量要怎麼寫?要怎麼說?沒背過怎麼聽得懂?\n大概就只有閱讀，並不是真的要考懂多少字彙，而是考藉由上下文搞懂脈絡。\n3.建議留學前語文程度需求 所以我認為如果英文程度還不到多益5、600，其實是可以先充實自己的單字量與文法。\n畢竟如果到菲律賓得先花時間背單字與念文法，才能順利溝通，是很浪費的。\n應該是要好好利用當地的資源、環境逼迫自己把腦中背過的字彙組合後流暢的說出來。\n這才是台灣沒有的環境，也是讀語言學校的價值。\n4.補充 題外話 : 筆者曾經很認真的跟菲律賓老師討論文法，但大部分會不知道怎麼回答你，因為他們是英文老師而不是英文文法老師。\n講英文憑藉著是語感與本能的覺得是否流暢。就像我們講中文，腦袋裡也是沒在管語法，但聽某些老外說中文就是會本能的覺得怪怪的。\n當然也有可能遇到著重在文法部分的老師，但我目前是沒遇到過就是了。\n就算讓你遇到了，外國人用英文跟你解釋文法，在學生程度連溝通都有困難的情況下，效率也不大吧。╮（╯＿╰）╭\n所以千萬不要想說連文法也不會，等到去那邊再學。會很好笑，先買一本中文文法書看看吧。\n英文字彙量提升，懂得基礎文法，再去念語言學校才會如魚得水。\n",
	  "pubDate": "2022-11-29T14:58:22+08:00",
	  "cover": "https://sunnote.xyz"

	}, 
	{
	
		
	  "url": "http://sunnote.xyz/zh-tw/%E8%AA%9E%E8%A8%80%E5%AD%B8%E6%A0%A1%E7%B4%80%E9%8C%84-%E8%A9%B2%E9%81%B8%E5%93%AA%E9%96%93%E8%AA%9E%E8%A8%80%E5%AD%B8%E6%A0%A1%E5%91%A2/",
	  "title": "語言學校紀錄-該選哪間語言學校呢",
	  "summary": "",
	  "content": "其實選校真的蠻難的，學生通常也是看代辦推哪裡就去哪裡\n畢竟大部分人可能連菲律賓都沒去過，看幾張圖片介紹是要選鬼喔\n而在選校前，又得先選擇城市，目前菲律賓有語言學校的城市大致有\n碧瑤、克拉克、宿霧、巴克羅、怡朗\u0026hellip;。\n因為我不是專業代辦，也沒有葉配，所以此篇文章只提供我當時選擇宿霧語言學校的想法與建議。\n身為工程師，最喜歡長話短說，那我就直接說重點。\n重點就是語言學校一間學生的人數多寡，也就是這間語言學校\n大不大間。 很多人不想選擇去菲律賓念英文的原因，主要是擔心老師口音、素質\u0026hellip;等。\n口音當然就是包含在師資程度的範疇。\n老師好不好專不專業，基本上也是跟學校大間與否有關。\n雖然有人會說小學校也會有專業的，大學校也會有廢的老師\n(我就遇過，但在老師很多的情況下我就把她換掉了✌~)。\n但這就跟公司一樣，一間公司如果大且蠻知名的，或是公司地段處於大城市、繁華地段，\n理所當然會更有機會擁有好的員工。\n畢竟知名代表好履歷，好履歷代表好跳槽，地段處於大城市代表來這工作機會很多，\n在意這些的員工普遍有上進心與企圖心，能力就不會差到哪裡。\n所以選校如果先以大間、人數多來篩選基本上不會差到哪裡去。\n剩餘的一些選校重點像伙食、周遭旅遊景點、證照課程、環境等，就讓你自己再去做第二輪的篩選吧。\n以上是我的選校心得，希望有幫助到你。\n如果有任何問題，也可以聯繫我。\n下一篇，我會分享 英文很爛能去念語言學校嗎(效益評估)\n",
	  "pubDate": "2022-11-29T13:57:21+08:00",
	  "cover": "https://sunnote.xyz"

	}, 
	{
	
		
	  "url": "http://sunnote.xyz/zh-tw/%E6%AD%90%E7%BE%8E%E8%AA%9E%E8%A8%80%E5%AD%B8%E6%A0%A1-vs-%E8%8F%B2%E5%BE%8B%E8%B3%93%E8%AA%9E%E8%A8%80%E5%AD%B8%E6%A0%A1/",
	  "title": "歐美語言學校 vs 菲律賓語言學校",
	  "summary": "",
	  "content": "比較表 此表為當時從代辦取得的一些資訊，僅供參考。\n歐美語言學校 菲律賓語言學校 價格 偏貴 便宜 課程 課堂較少採自主學習、快樂學習制 斯巴達(課程從早排到晚不念書也難)、考試證照取向、一對一 距離 遠 非常近(有什麼問題可以馬上飛回台) 飲食 普遍外食偏貴 學餐偏難吃、但外食消費與台灣差不多 安全 台灣最安全不同國家區域治安都不太相同請提前做好功課 台灣最安全不同國家區域治安都不太相同請提前做好功課 時差 有時差 相同(比較好與在台家人聯絡) 結論 沒有不好，只有適不適合\n接下來的分享，主要著重分享菲律賓語言學校的細節與優勢。\n因為我當初就是選擇菲律賓的語言學校，評價比較客觀。\n如果你本身偏害羞，人多團體班就不太說話，菲律賓的一對一學制非常適合你。\n一天基本上會有半天你都必須關在一個小房間與老師說話，除非你是啞巴，口說不進步都難!!\n如果你追求CP值，想用比較少的錢就達到英文能力提升，考過多益、雅思甚至托福， 菲律賓的學制非常適合你，像我參與的雅思課程強迫每個禮拜都有一次標準雅思的mock test， 上了一整天的課，晚上還必須得在考場待到結束的那種不是開玩笑的~!\n能讓你考試考到像在吃飯，全程參與不放棄，我是不相信證照考試不會通過啦。\n如果你讀書很吃氣氛環境，喜歡全神貫注不需要擔心任何事，那菲律賓的制度很適合你，\n語言學校供三餐、宿舍有人打掃、衣服有專門送洗、課堂排的滿滿滿，周遭也都是準備考試的戰友(雖然還是有純粹來度假的啦哈哈)。\n我讀到最後，真的是每天沉浸在英語的環境，每天都覺得自己的英語水平一直在進步，還不用擔心多餘的生活瑣事。\n接下來會分享 菲律賓語言學校選城市與選校的心得\n，\n",
	  "pubDate": "2022-11-28T15:35:05+08:00",
	  "cover": "https://sunnote.xyz"

	}, 
	{
	
		
	  "url": "http://sunnote.xyz/zh-tw/%E8%AA%9E%E8%A8%80%E5%AD%B8%E6%A0%A1%E7%B4%80%E9%8C%84-%E7%82%BA%E4%BB%80%E9%BA%BC%E8%A6%81%E5%8E%BB%E8%8F%B2%E5%BE%8B%E8%B3%93%E5%BF%B5%E8%8B%B1%E6%96%87/",
	  "title": "語言學校紀錄-為什麼要去菲律賓念英文?",
	  "summary": "",
	  "content": "前言 主要是覺得會飛去菲律賓念英文的原因很白癡，所以想留下紀錄。\n也不知道在飛去後的體驗對我人生影響極大，如果覺得有興趣就讓我們看下去~\n背景 人嚇人會嚇死人，自己嚇自己會跑到菲律賓。\n經歷了多益的奮戰，在考完試後本身對英文能力沒自信的我，\n心理覺得應該達不到自己想要的550門檻，一考完就擺著屎臉從考場走出來，跟老媽說情況很悽慘應該需要再考一次。 (多益那麼多題，對我這種英文猜猜樂等級，考完怎麼可能會知道自己考幾分\u0026hellip;)\n老媽可能也覺得我是個廢物，畢竟英文就是得靠時間累積，只能再加油要我準備下一場考試。\n契機 之後的幾天，剛好從已工作的朋友那聽來她準備辭職去菲律賓遊學，還有關於斯巴達式教學(從早上上課到晚上很拚很累的那種)，原先只是抱持著分享的想法，與我媽閒聊。\n她竟然提議的說 : 不然你也去去看吧!\n但我身上只剩下碩班快花完的薪水，與四個月兵役的薪水阿!!!!\n其實我老媽本來就是補習派的，一開始準備多益時就想要逼我去補習班，但我那時認為英文自己讀就好了，補習班根本就是在騙錢堅決反對。\n一抓到能出國念英文這個念頭(俗話說的類補習，甚至比補習班更好)，就全力迫使我甚至要幫我先出錢，叫我之後賺錢再還她。\n(非常感謝有她，個性沒什麼執行力的我現在想起來真的很需要人推一把跳脫舒適圈)\n接下來就是馬上找代辦詢問詳細資訊。\na few days later\u0026hellip;\n在一切都弄妥繳完訂金之後，我收到多益成績單了。\n690\u0026hellip; 已超出我原本要的分數\u0026hellip;😂 ，\n但因為已繳學費退款不能全額退、住宿租金等種種因素，我就在明明已經達到能找工作的門檻下，\n為了不浪費錢，前往菲律賓了\u0026hellip;。\n接下來會分享當初評估的 歐美語言學校與菲律賓語言學校的優缺點\n",
	  "pubDate": "2022-11-28T13:34:52+08:00",
	  "cover": "https://sunnote.xyz/img/thumbnail/3.%E8%AA%9E%E8%A8%80%E5%AD%B8%E6%A0%A1%E7%B4%80%E9%8C%84-%E7%82%BA%E4%BB%80%E9%BA%BC%E8%A6%81%E5%8E%BB%E8%8F%B2%E5%BE%8B%E8%B3%93%E5%BF%B5%E8%8B%B1%E6%96%87.jpg"

	}, 
	{
	
		
	  "url": "http://sunnote.xyz/zh-tw/%E5%A4%9A%E7%9B%8A350~690%E7%B6%93%E9%A9%97%E5%88%86%E4%BA%AB/",
	  "title": "多益350~690經驗分享",
	  "summary": "",
	  "content": "大家好，此篇是這個網站，第一篇文章，沒什麼原因，單純就只是網站剛架設好後，才發現自己好像沒什麼能分享的體驗。\n所以就回想一下當時剛畢業英文爛的要死，但各個公司錄取條件基本上就得先來個多益550up證明。萬念俱灰之下學習英文經驗。\n1.背景 自從國中1200單字有背完後，高中開始基本上沒什麼碰英文了，考試也完全看不懂，每次都是猜猜樂，在考學測時，英文只有拿個底標!!\n來到大學，相信有念過的都知道，特別是理工科系，如果沒特別去念原文書，英文基本上只會更差，我就這樣渾渾噩噩甚至直到碩班也唸完了。英文也還是維持那種程度(猜猜樂的程度)。\n碩班好不容易畢業後(一部分原因也是因為英文太差)，並且準備找工作時，嘗試著去做線上多益測驗(一種可以評估程度大概幾分的網站)，結果為350! 那時才驚覺到事情的嚴重性，自以為畢業的學校好像也還不錯，工作應該不難找，但卻有可能因為多益程度，連面試的機會都沒有\u0026hellip;。\n2.惡補方法 接下來就是分享我自己認為有效的學習方法，當然這不一定適用每個人，如果徬徨可以加減參考。\n心態面 首先，英文當然是可以快樂學習的，但多益不適用，特別是像我這種為了工作才去準備的人，而且我們總是幻想著幾個月從幾百到幾百，從沒證書到金色證書， 所以心態請建立好，為了多益成績我們之後會很辛苦。\n了解自己的程度 字彙量是一切\n此篇是寫給英文爛的跟狗屎一樣的人，畢竟690有人裸考也是輕輕鬆鬆get，但如果你的程度只停留在國中1200單字然後文法稍微懂一點點(文法不懂也請去買多益文法書來啃)的話，請先去買多益的單字本，為了容易記憶，單字本請找有主題相關的然後每個單字下方都有提供照樣照句，\n請善用句子來背單字\n很重要，因為背單字是為了要會使用，而不是只是知道單字的意思，而熟悉句子更能增加之後筆試的語感。有些教材也提供了老外口說版本，絕對要用聽力去增強記憶點，畢竟多益也需要考聽力。\n準備時程 準備考試建議訂個日期，才不會陷入永無止境的念書地獄。\n當然也依據個人口袋深度與時間，雖然考越多次理所當然越戰越勇，但前提是你生命值夠高，我認真不想再考這種雞巴考試一次。 我其實算那種對自己比較沒自信的人，所以當時花了一個月念完整個單字本，一個禮拜掃完題庫，當時覺得考得有夠爛，根本過不了門檻完全沒準備好，但還是被老媽強制報名了筆試，但這也給了我一個日期可以下定決心好好衝刺，所以剩下快一個月就是瘋狂的刷題刷題再刷題。\n(沒有一個已知的考試日期，很容易怠惰，或是剛開始很拚最後卻麻木沒衝勁)\n如果還是學生，不像我這種畢業還在啃老不孝仔那我覺得準備時程是可以拉長的，畢竟英文這種東西就是要時間累積，主要就是要有毅力維持英文環境，每天念一點念一點，時間夠久，甚至真的裸考也能考高分。 你要短時間要馬記憶力驚人要馬考試技巧過人。\n細節 厚厚的單字本請啃完，默背句子(在家可以喊出來)，用聽力增強記憶點，今天背新的並且同時複習昨天的。\n心理要想著，多益其實是很簡單的語言考試，單字量就那些，背熟了分數就是你的。\n等到單字量差不多了，可以開使寫題目，這時你應該還是會覺得馬的怎麼一堆單字不會但應該會有印象，曾經出現在單字本裡，這樣子重複幾遍一定會越來愈熟。\n當然如果有單字本沒出現過的單字可記可不記，畢竟這是考試，我們沒有要拿金色只是要過門檻，出現頻率高的單字先弄熟，才有機會把分數先拉上來。\n至於題庫，我只有寫過兩本，其實都是大同小異，對我們這種只要過門檻的咖小，單字量跟閱讀速度才是一切。 能多看就多看，就當作是閱讀課外讀物，讀到最後單字真的就那些，甚至一個句子幾個詞不懂還是能理解前後文意思，這時你應該就不會那麼害怕了。剩下的就是熟練與一些考試小訣竅了。\n5.考試技巧\n請等字彙量提升後再考慮專研考試技巧。\n技巧就請自己上網爬文吧~! 畢竟念到最後自己也是會有自己慣用的方法與訣竅。 我私心認為多益這種考試方式如果單字量達一定水準單純就只是考你的考試技巧，所以在我拿到690這個分數時，其實也是心虛覺得自己不值這個分數，純粹憑著熟練的考試直覺與技巧得來的。\n3.結語 曾經想要逃避英文，但學會了卻讓我看到更多的世界。\n考完多益測驗不是結束，只是一個開始，曾經的我總抱持著一輩子要待在台灣，英文什麼的不重要的想法。\n但因為工作而需要多益，而因為多益我卻陰錯陽差地飛去菲律賓念語言學校還順便準備雅思測驗(這又是另一個故事了)，\n經歷了各種體驗。增加的視野，看世界的廣度，都是我當初意想不到的收穫。\n出門鞋帶要綁好，體驗人生英文也要學好。\n當你可以自在跟不同文化的人用英文侃侃而談，那真的是一個很美好的回憶。\n以上，希望能幫助那些英文不好認為怎麼讀都不起色甚至想放棄的人。\n",
	  "pubDate": "2022-11-24T19:44:38+08:00",
	  "cover": "https://janstockcoin.com/wp-content/uploads/2021/06/pexels-photo-747964-2048x1293.jpeg"

	}, 
	{
	
		
	  "url": "http://sunnote.xyz/zh-tw/archives/",
	  "title": "文章歸檔",
	  "summary": "歷史文章按照年月歸檔",
	  "content": "",
	  "pubDate": "2022-11-20T00:00:00Z",
	  "cover": "https://sunnote.xyz"

	}, 
	{
	
		
	  "url": "http://sunnote.xyz/zh-tw/footprint/",
	  "title": "足跡",
	  "summary": "時間軸",
	  "content": " 存錢中\r~\n北海道-札幌、登別、函館\r札幌、登別、函館\r2023-05-05~\n2023-05-09\r菲律賓-宿霧\r4 months 宿霧\r2019-11-17~\n2020-03-21\rBackend Engineer\r3 years 4 months 2020-09-14~\nField Application Engineer\r1 month 2020-07-01~\n2020-08-26\r",
	  "pubDate": "2022-11-20T00:00:00Z",
	  "cover": "https://sunnote.xyz"

	}, 
	{
	
		
	  "url": "http://sunnote.xyz/zh-tw/timeline/",
	  "title": "時間軸",
	  "summary": "時間軸",
	  "content": " Backend Engineer\rBackend Engineer in Formosa Plastics Corporation\n2020-09-14~\nField Application Engineer\r1 month Field Application Engineer in Micro Star International co. ltd\n2020-07-01~\n2020-08-26\r",
	  "pubDate": "2022-11-20T00:00:00Z",
	  "cover": "https://sunnote.xyz"

	}, 
	{
	
		
	  "url": "http://sunnote.xyz/zh-tw/search/",
	  "title": "站內查詢",
	  "summary": "search",
	  "content": "",
	  "pubDate": "2022-11-20T00:00:00Z",
	  "cover": "https://sunnote.xyz"

	}, 
	{
	
		
	  "url": "http://sunnote.xyz/zh-tw/about/",
	  "title": "關於",
	  "summary": "關於",
	  "content": "\r於 2018 年匈牙利拍攝.\rAlivn，目前為軟體工程師，負責後端系統開發。\n技術: ASP.NET Core、Blazor、Node.js、Python、Azure、AWS、Docker\n期許自己能在未來達成工作不只是為了生存，而是成就感。\n主要分享一些生活體驗、旅遊心得與一點點的技術筆記。\n如果有任何問題、相同興趣或是技術交流歡迎聯繫我。\n如果喜歡本站，歡迎贊助以供網站的域名與營運費用🤗\r您的支持可以讓我知道，我的文章對世界上的某個人有所幫助\r可以透過以下幾種方式贊助我💪\r虛擬貨幣轉帳\rNetwork:\rPolygon-usdt\rBSC-usdt\rArbitrum-usdt\rETH-usdt\r街口支付轉帳\rBuy Me a Coffee\r2023/12/20...\n",
	  "pubDate": "2022-11-20T00:00:00Z",
	  "cover": "https://sunnote.xyz"

	}
  ]
  